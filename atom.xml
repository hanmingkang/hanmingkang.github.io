<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>纳兰寒明的博客</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2024-12-12T05:59:44.841Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>纳兰寒明</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RN快速上手-hooks</title>
    <link href="http://yoursite.com/2024/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF/rn/RN%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-hooks/"/>
    <id>http://yoursite.com/2024/12/11/%E7%A7%BB%E5%8A%A8%E7%AB%AF/rn/RN%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-hooks/</id>
    <published>2024-12-11T06:28:03.000Z</published>
    <updated>2024-12-12T05:59:44.841Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先说说客户端以后的发展吧！</p><p>无非以下几个选择：</p><ol><li>接着在客户端卷，从客户端卷到前端，做到整体大前端。</li><li>做终端底层，类似车载，学习机，路由器，穿戴设备，系统framework层等</li><li>去后端卷吧，java也有一席之地。业务的后端和算法，大数据，AI的差点还是挺大的，而且后三的门槛比较高，歧视链严重。</li></ol><p>直接上结论，如果还要继续做客户端的话，客户端掌握RN已经是必然，建议客户端同学都学习参与进来。</p><p>当前形势下，客户端百花齐放，前有安卓，苹果，后有华为。（主要还是华为的冲击比较大）公司如果还要在客户端发力，必然需要支持这三端开发，但是安卓使用java，kotlin，苹果使用swift，objectC，鸿蒙使用arkts。如果再加上RN，那就是4种。这4种技术栈如果需要3-4组人开发，那成本可想而知。在很久以前，众大厂都觉得双端人力成本过高，使用跨端技术RN,flutter减少开发人力成本。如果在加上鸿蒙系统的话，三端开发，更加促进了跨端技术的发展，会有更多的公司考虑引入跨端技术进行改进。</p><p>以我们公司来说，在android，iOS，hmos，rn中最少掌握2种，最好掌握三种技术栈</p><p>回归内容，如果客户端同学需要掌握RN技术，如何快速上手呢</p><h2 id="开发差异"><a href="#开发差异" class="headerlink" title="开发差异"></a>开发差异</h2><p>RN使用的是ts，js进行开发，使用React组件，其中比较出名的是redux数据流处理思想。</p><p>hmos使用的是arkts进行开发，可以理解他是更轻的ts语言，其中很多特性都删除了。</p><p>android使用的是kotlin，java进行开发。</p><p>其中可以看到，RN和hmos都是ts语言，android是kotlin，java语言。java和kotlin语言是面向对象的语言，new一个class走天下。ts虽然说是面向对象的js语言，但是ts的官方却在建议不要使用其面向对象的特性，那么对于我们来说，为了写的优雅，ts可以立即为和js一样都是面向编程的语言（函数式编程）</p><p>对于android出身的人来说，天塌了，不是万物皆是对象吗？犹豫不决new对象，怎么在RN中不允许new了。这其实需要客户端出身的人进行转变，RN说到底使用的是react前端技术栈，快速迭代，简单堆叠是前端的本性。</p><h2 id="如何上手？"><a href="#如何上手？" class="headerlink" title="如何上手？"></a>如何上手？</h2><p><a href="https://reactnative.cn/docs/getting-started">React Native 中文网</a>一定是圣经，但是还是建议看一下<a href="https://zh-hans.react.dev/learn">React</a>相关的，不懂React直接上手RN还是有一定难度的。</p><p>但是看这些确实需要很多时间，所以最好的学习方式其实是你上手一个小页面，在一知半解，各种不适应中进行开发迭代，看着前辈的代码照葫芦画瓢，他为什么这么写？这个关键词是什么意思？为什么要这么用？实践出真知！</p><p>如果你没时间看如上文档，那么在上手前还是建议你一定要踏实的先看下这篇文章。看完可以直接开发了。</p><p><a href="https://www.ruanyifeng.com/blog/2020/09/react-hooks-useeffect-tutorial.html">轻松学会 React 钩子：以 useEffect() 为例</a></p><h2 id="如何理解RN技术栈-hooks"><a href="#如何理解RN技术栈-hooks" class="headerlink" title="如何理解RN技术栈-hooks"></a>如何理解RN技术栈-hooks</h2><p>RN提供了两种组件模式：类组件、函数组件</p><p>对于类组件来说，对于android很好理解，快速上手没啥问题，但是</p><p>官方推荐函数组件，那么我们需要提供的组件都是一个函数，那么页面的逻辑和数据处理应该放在哪里？</p><p>函数组件的相关逻辑都放在hooks(勾子)中，可以说hooks是RN组件开发的精髓，懂了他，RN开发就没啥大问题了。</p><p>hooks会存在一些规范：</p><ul><li>不要在条件语句内或循环语句内调用 Hook。</li><li>不要在包含 <code>return</code> 的条件语句之后调用 Hook。</li><li>不要在事件监听中调用 Hook。</li><li>不要在类式组件内调用 Hook。</li><li>不要在那些传给 <code>useMemo</code>，<code>useReducer</code> 或 <code>useEffect</code> 的函数内调用 Hook。</li></ul><p>常用hooks： <a href="https://zh-hans.react.dev/reference/react/hooks">React内置Hook</a></p><ul><li><p><strong>useEffect</strong>：通用的函数组件勾子。如果监听属性不设置，则加载完成后会回调一次，如果设置数据变化，才会牵动勾子执行，最常用的是进行网络请求</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">fetchData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(</span><br><span class="line">        <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=redux&#x27;</span>,</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, []);</span><br></pre></td></tr></table></figure></li><li><p><strong><a href="https://zh-hans.react.dev/reference/react/useLayoutEffect">useLayoutEffect</a></strong>:在浏览器重新绘制屏幕前执行，可以在此处测量布局</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><a href="https://zh-hans.react.dev/reference/react/useState"><strong>useState</strong></a>:向组件添加一个状态变量</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(initialState)</span><br></pre></td></tr></table></figure></li><li><p><a href="https://zh-hans.react.dev/reference/react/useReducer"><strong>useReducer</strong></a>：引入redux组件reducer功能</p><p>Redux：(state, action) &#x3D;&gt; newState 收到action后通过reducer算出新的状态值，进行ui更新</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialArg, init?)</span><br></pre></td></tr></table></figure></li><li><p><a href="https://zh-hans.react.dev/reference/react/useContext"><strong>useContext</strong></a>：子使用父组件的属性，子公用，父存储</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">useContext</span>(<span class="title class_">SomeContext</span>)</span><br></pre></td></tr></table></figure></li><li><p><a href="https://zh-hans.react.dev/reference/react/useRef"><strong>useRef</strong></a>:存储非影响渲染的变量数据</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = <span class="title function_">useRef</span>(initialValue)</span><br></pre></td></tr></table></figure></li><li><p><a href=""><strong>useMemo</strong></a>:它在每次重新渲染的时候能够缓存计算的结果</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cachedValue = <span class="title function_">useMemo</span>(calculateValue, dependencies)</span><br></pre></td></tr></table></figure></li><li><p><strong>useMount</strong>:组件初始化时执行一次，使用usEffect的控监听特性实现</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;先说说客户端以后的发展吧！&lt;/p&gt;
&lt;p&gt;无非以下几个选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接着在客户端卷，从客户端卷</summary>
      
    
    
    
    <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="react native" scheme="http://yoursite.com/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>富文本选中状态方案</title>
    <link href="http://yoursite.com/2023/11/27/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%AF%8C%E6%96%87%E6%9C%AC%E9%80%89%E4%B8%AD%E7%8A%B6%E6%80%81%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2023/11/27/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%AF%8C%E6%96%87%E6%9C%AC%E9%80%89%E4%B8%AD%E7%8A%B6%E6%80%81%E6%96%B9%E6%A1%88/</id>
    <published>2023-11-27T08:30:49.000Z</published>
    <updated>2024-12-12T06:07:55.786Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>文本长按出现可复制，点赞，搜索等操作。</p><p><img src="/imageMd/section-1.png" alt="section-1"></p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li>首先TextView可以通过属性设置，允许选中，但弹出为系统弹窗</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:textIsSelectable=<span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure><p>   <img src="/../imageMd/section-2.png" alt="section-2"><br>2. 系统弹窗的样式与我们想要的还是有一些区别的，所以看起来弹窗的样式是需要我们自己定义的。<br>   这里其实有两套方案：<br>           1. 干掉所有系统的处理，即1，2部分都进行自定义<br>              .只进行弹窗的自定义部分，保留系统的选中状态，即保留2，自定义1<br>              这里同前端对了下方案，前端的方案与我们的2方案是一致的，所以我们可以保持一致，进行2方案的修改</p><ol start="3"><li>实现自定义弹窗的方案是找到系统弹窗的创建地方，直接替换成我们的弹窗，通过读取API，我们找到了这个方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">text.customSelectionActionModeCallback = object : ActionMode.Callback&#123;</span><br><span class="line">    override fun <span class="title function_">onCreateActionMode</span><span class="params">(mode: ActionMode?, menu: Menu?)</span>: Boolean &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    override fun <span class="title function_">onPrepareActionMode</span><span class="params">(mode: ActionMode?, menu: Menu?)</span>: Boolean &#123;</span><br><span class="line">        <span class="comment">//移除系统的menu项</span></span><br><span class="line">        menu?.clear()</span><br><span class="line">        <span class="comment">//替换为自定义的menu项</span></span><br><span class="line">        mode?.menuInflater?.inflate(R.menu.select_menu,menu)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    override fun <span class="title function_">onActionItemClicked</span><span class="params">(mode: ActionMode?, item: MenuItem?)</span>: Boolean &#123;</span><br><span class="line">        <span class="comment">//处理自定义menu项的交互，eg：点击</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    override fun <span class="title function_">onDestroyActionMode</span><span class="params">(mode: ActionMode?)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   接下来我们看效果：<br>   <img src="/imageMd/section-3.png" alt="section-3"><br>   OK，看起来没问题，但是这里有一个局限性，这里的view不可能做到完全自定义，这里的View说到底是一个menu菜单，和系统+AppTheme的设置有关，所以自由度有限</p><blockquote><p>实践后发现小米系统是不支持自定义menu的，并且不走customSelectionActionModeCallback回调</p></blockquote><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>不使用系统的选中复制功能，完全自定义选中效果</p><p>其一：可以减少系统的选中复制的crash量级</p><p>其二：可以越过某些厂商的限制。eg：小米</p><p><img src="/imageMd/section-4.png" alt="section-4"></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>弹窗分为3个部分，<strong>弹窗，左右游标，背景选中状态</strong></p><p>弹窗：可通过自定义popupWindow实现</p><p>左右游标：可通过自定义popupWindow实现</p><p>背景选中状态：通过BackgroundSpan实现</p><p>大概思路是通过一个管理器，通过textview长按触发，获取选中的索引，计算左右浮标和弹窗的位置，针对选中索引，动态设置BackgroundSpan，弹窗设置isOutsideTouchable &#x3D; true，当点击其他区域时使选中状态三部分消失，当点击左右浮标进行拖拽时，只消失弹窗，其他两者不消失，松手后，重新弹起弹窗。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;p&gt;文本长按出现可复制，点赞，搜索等操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/imageMd/section-1.p</summary>
      
    
    
    
    <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
    <category term="富文本" scheme="http://yoursite.com/tags/%E5%AF%8C%E6%96%87%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>基于IDE插件的代码实时检测</title>
    <link href="http://yoursite.com/2023/01/05/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%9F%BA%E4%BA%8EIDE%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%97%B6%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2023/01/05/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%9F%BA%E4%BA%8EIDE%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%97%B6%E6%A3%80%E6%B5%8B/</id>
    <published>2023-01-05T05:47:20.000Z</published>
    <updated>2023-12-19T06:50:38.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于IDEA插件的实时代码检测及推荐调研"><a href="#基于IDEA插件的实时代码检测及推荐调研" class="headerlink" title="基于IDEA插件的实时代码检测及推荐调研"></a>基于IDEA插件的实时代码检测及推荐调研</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>由于目前的移动端的崩溃和卡顿个数较多所以进行开发建设治理工具，通过工具化降低线上问题，提高App的稳定性</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>通过实时获取开发者当前的开发内容</p><ol><li>推荐适合当前语境的代码。eg：如使用Dialog时，提示其调用方式</li><li>发现当前代码存在问题，并提出解决方案。eg：文档汇总、MR中的优秀代码块</li></ol><h3 id="方案调研"><a href="#方案调研" class="headerlink" title="方案调研"></a>方案调研</h3><p>基于目前的目标，我们考虑了两种方案：IDEA插件、Lint工具</p><h4 id="Lint工具"><a href="#Lint工具" class="headerlink" title="Lint工具"></a>Lint工具</h4><p>lint规则书写是从问题角度出发，根据发生的问题进行规则书写，对推荐侧并不是强依赖，所以lint工具的局限性较强，局限在这些规则中。</p><h4 id="IDEA插件"><a href="#IDEA插件" class="headerlink" title="IDEA插件"></a>IDEA插件</h4><p>IDEA是当前主流的开发工具，当前开发Android的主流工具Android studio也是基于IDEA进行开发的。所以开发IDEA插件也可以在Android Studio中通用。</p><p>IDEA插件是什么？</p><p>以Android Studio为例，我们常用的project，Gradle的工具栏，底部的工具栏，如Logcat等都是IDEA插件，可以说在Android studio中你使用所有功能的绝大多数都是IDEA插件。如此强大的IDEA插件是因为，IDEA插件提供了多样化的SDK，可以使开发者在插件上实现各式各样的功能，满足多样化的需求。</p><h5 id="插件方式"><a href="#插件方式" class="headerlink" title="插件方式"></a>插件方式</h5><p>IDEA插件的创建有两种方式：DevKit插件 和 Gradle插件<br>而官方文档已经建议使用Gradle插件了，<a href="https://plugins.jetbrains.com/docs/intellij/migrating-plugin-devkit-to-gradle.html">将 DevKit 插件迁移到 Gradle</a>，所以本IDEA插件会采用基于Gradle的环境进行开发</p><h5 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h5><ol><li><p>koltin适配：<br>目前的IDEA插件允许行配置kotlin语言开发，并明确了kotlin开发在开发插件中的优势，<a href="https://plugins.jetbrains.com/docs/intellij/using-kotlin.html">配置Kotlin支持</a><br>同时，如果有一些UI的开发工作，不太会使用swing搭建的，可以使用kotlin的DSL进行UI搭建。<a href="https://plugins.jetbrains.com/docs/intellij/kotlin-ui-dsl-version-2.html">kotlin DLS 开发</a></p></li><li><p>Plugin Content（插件内容）：</p><p>插件进行打包后生成的.jar文件包含：</p><ol><li>配置文件（<strong>META-INF&#x2F;plugin.xml</strong>）</li><li>实现插件的功能类</li><li>插件的图标（<strong>META-INF&#x2F;pluginIcon*.svg</strong>）</li></ol></li><li><p>Bundling Plugin API Sources（绑定插件的API源）：<br>如果第三方插件使用<a href="https://plugins.jetbrains.com/docs/intellij/tools-gradle-intellij-plugin.html">Gradle IntelliJ 插件</a>并向插件添加依赖项，该插件捆绑 ZIP 分发中的源代码，则当开发人员导航到 API 类时，源代码将自动附加到插件库并在 IDE 中可见。</p></li><li><p>Plugin Class Loaders（插件类加载器）：<br>可以加载当前插件中找不到的类。</p></li><li><p>Plugin Actions（插件动作）：<br>Actions是绝大部分插件会使用的方式，他是IDEA提供的一个动作的概念，比如点击工具栏按钮，使用快捷键，命令行触发<br><img src="/imageMd/idea-2.png" alt="img"></p><p>通过add-to-group配置，对Actions的触发条件进行设置，eg：绑定Command-N快捷键</p></li><li><p>Plugin Extensions（插件拓展）：<br>可以理解为插件的入口，比如菜单栏，工具栏等众多拓展点，基本所有的东西都允许二次拓展，大概存在<code>1424</code>个<a href="https://plugins.jetbrains.com/docs/intellij/extension-point-list.html">扩展点</a>。</p></li><li><p>Plugin Listeners（插件监听器）：</p><p>IDEA插件中的监听器，通过消息总线的方式进行传输，插件方可根据自己的需求监听不同的监听器，执行不同的逻辑处理。目前存在<code>211</code>个<a href="https://plugins.jetbrains.com/docs/intellij/extension-point-list.html">监听器</a>。</p></li><li><p>Plugin Extension Points（插件拓展点）：</p><p>与Plugin Extensions对立，这里接入拓展点后，别的插件可以在你的基础上进行二次拓展</p><ol><li>接口拓展：其他插件实现你的接口，进行拓展调用</li><li>Bean拓展：其他插件可以使用你的data拓展你的插件，新增数据类型等</li></ol></li><li><p>Plugin Services（插件服务）：</p><p>插件服务的存在主要是确保只存在一个实例，即使他被多次调用</p><ul><li><code>com.intellij.applicationService</code> - 应用级别服务</li><li><code>com.intellij.projectService</code> - 项目级别服务</li><li><code>com.intellij.moduleService</code> - 模块级别服务（官方不推荐使用，会增加内存损耗）</li></ul></li><li><p>Components（组件）：</p><p>是一个被抛弃的东西，不支持动态加载，如果使用了，需要进行迁移</p></li><li><p>Plugin Configuration File（插件配置文件）：<br><strong>plugin.xml</strong>文件的语法</p></li><li><p>Plugin Logo (Icon)（插件图标）</p></li><li><p>Plugin Dependencies（插件依赖项）</p></li></ol><h5 id="IDEA插件结构"><a href="#IDEA插件结构" class="headerlink" title="IDEA插件结构"></a>IDEA插件结构</h5><p><img src="/imageMd/idea-1.png" alt="image-20221107212550157"></p><p>对于非用户触发的操作通过一个队列进行管理，防止逻辑时间点相近导致短时间内重复请求，造成项目卡顿，服务超载的问题<br>对于用户触发的操作则直接进行处理，请求推荐算法获取结论，并展示在IDEA或者直接修复代码</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>通过IDEA插件的Gradle形式可以实现对代码的动态监测，开发完毕后，需要对IDEA插件的性能进行分析，避免影响开发者的正常开发。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基于IDEA插件的实时代码检测及推荐调研&quot;&gt;&lt;a href=&quot;#基于IDEA插件的实时代码检测及推荐调研&quot; class=&quot;headerlink&quot; title=&quot;基于IDEA插件的实时代码检测及推荐调研&quot;&gt;&lt;/a&gt;基于IDEA插件的实时代码检测及推荐调研&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>lint方案调研</title>
    <link href="http://yoursite.com/2023/01/05/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/lint%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/"/>
    <id>http://yoursite.com/2023/01/05/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/lint%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/</id>
    <published>2023-01-05T03:42:17.000Z</published>
    <updated>2023-12-19T06:50:38.179Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>针对不同方向，如开发阶段，编译阶段，修复阶段等都进行提效，降低错误数量，便捷修复错误问题等。</p><p>android studio本身存在系统的lint检查工具，但功能有限，并不能囊括所有的问题，参考<a href="https://tech.meituan.com/2018/04/13/waimai-android-lint.html">美团外卖Android Lint代码检查实践</a>，我们可以自研一套lint工具体系，以此更好的治理移动端错误</p><p>目前在知乎的android组件中并没有成型的可用自定义lint方案，所以我们可以构建一个</p><h3 id="方案调研"><a href="#方案调研" class="headerlink" title="方案调研"></a>方案调研</h3><p>Android Studio 提供了一个名为 lint 的代码扫描工具，可帮助开发者发现并改正代码结构质量方面的问题。系统会报告该工具检测到的每个问题并提供问题的描述信息和严重级别。</p><p>lint可针对android的源文件，通过lint.xml进行配置后，通过lint工具进行在正确性、安全性、性能、易用性、无障碍性和国际化方面入手，优化改进。</p><p><img src="/imageMd/lint-1.png" alt="img"></p><h4 id="检测时机"><a href="#检测时机" class="headerlink" title="检测时机"></a>检测时机</h4><p>其可在开发阶段通过idea识别并提示开发者，亦可在编译时提示。</p><ol><li><p>在开发阶段<br>idea会识别lint工具，并根据级别展示不同提示<br><img src="/imageMd/lint-2.png" alt="image2022-8-24_13-48-3"><br>开发者可在弹窗中获取更多关于提示的信息，并根据提示修复问题</p></li><li><p>在编译阶段<br><img src="/imageMd/lint-3.png" alt="image2022-8-24_13-53-3"><br>会存在提示，如是error级别日志会阻断编译过程，必须修复后方可运行</p></li><li><p>除此之外，我们亦可手动调用 .&#x2F;gradlew lint 进行代码检查，之后会生成xml文件和html文件可供分析<br><img src="/imageMd/lint-4.png" alt="image2022-8-24_14-0-44"><br><img src="/imageMd/lint-5.png" alt="image2022-8-24_14-8-36"></p></li><li><p>commit增量检测<br>lint的原理是进行全盘扫描，如果项目较为庞大，那么可定耗时很长，所以可以通过分析每次commit生成的diff文件，进行增量lint检测</p></li><li><p>CI检测<br>可通过配置打包服务器Jenkins，在提交mr的时候进行检测</p></li></ol><h4 id="检测配置"><a href="#检测配置" class="headerlink" title="检测配置"></a>检测配置</h4><ol><li><p>配置可检测规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  lintOptions &#123;</span><br><span class="line">        <span class="comment">//设置只检查的类型</span></span><br><span class="line">        <span class="type">def</span> <span class="variable">checkList</span> <span class="operator">=</span> [</span><br><span class="line">                <span class="string">&#x27;SerializableClassCheck&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;HandleExceptionCheck&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;AvoidUsageApiCheck&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;DependencyApiCheck&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;ResourceNameCheck&#x27;</span></span><br><span class="line">        ] as String[]</span><br><span class="line">        check checkList</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>针对当前项目进行配置<br>右键点击项目<strong>Analyze→InspectCode</strong> 进行相关的lint有效范围配置<br><img src="/imageMd/lint-6.png" alt="image2022-8-24_15-54-10"></p></li><li><p>忽略历史问题<br>通过创建一个baseline.xml文件，将该时间点之前的所有项目产生的lint问题忽略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android&#123;  </span><br><span class="line">  lintOptions &#123;        </span><br><span class="line">    <span class="comment">//创建警告基准       </span></span><br><span class="line">    baseline <span class="title function_">file</span><span class="params">(<span class="string">&quot;lint-baseline.xml&quot;</span>)</span>    </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="方案优势"><a href="#方案优势" class="headerlink" title="方案优势"></a>方案优势</h3><p>采用lint方案，存在什么优势呢？</p><ol><li>功能强大，Lint支持Java和Kt源文件、class文件、资源文件、Gradle等文件的检查。</li><li>扩展性强，支持开发自定义Lint规则。</li><li>配套工具完善，Android Studio、Android Gradle插件原生支持Lint工具。</li><li>Lint专为Android设计，原生提供了几百个实用的Android相关检查规则。</li><li>有Google官方的支持，会和Android开发工具一起升级完善。</li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>可以采用lint工具，其推进的最大阻力在于lint的规则编写。</p><p>根据目前线上出现的高频问题，进行评估后列入表格中，按表格依次开发规则迭代lint工具。</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ol><li>lint规则可配置处理，无需手写规则</li><li>增量lint判断处理</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;p&gt;针对不同方向，如开发阶段，编译阶段，修复阶段等都进行提效，降低错误数量，便捷修复错误问题等。&lt;/p&gt;
&lt;p&gt;android studio本身</summary>
      
    
    
    
    <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>lint在AGP3.3.3失效的问题</title>
    <link href="http://yoursite.com/2023/01/05/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/lint%E5%9C%A8AGP3-3-3%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2023/01/05/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/lint%E5%9C%A8AGP3-3-3%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-01-05T03:23:57.000Z</published>
    <updated>2023-12-19T06:50:38.179Z</updated>
    
    <content type="html"><![CDATA[<p>自定义的lint规则在AGP3.3.3上存在问题，有一多半情况下，自定义lint规则是失效的，他并不能检查到lint问题，到底为什么？该怎么解决？</p><p>为什么？<br>为什么在AGP3.3.3上偶尔失效，而在AGP4.2上就没有问题，在网上搜了很多，这方面的资料很少。直到我找到这个 自定义lint规则不生效</p><p>其中表示，不生效的问题来源于lint SDK的 findRegistries方法的问题，在高版本之后才修复</p><p>而AGP3.3.3使用的是26.3.3，我们分析了下远吗，果然存在这个问题，那么下一个阶段是如何修复改问题。</p><p>问题修复<br>如何修复该问题：</p><p>升级AGP版本，使用最新的lint SDK，避免这个问题<br>修复26.3.3的lint SDK，然后在lint规则校验时指向已修复的lint SDK。<br>修复步骤：<br>下载26.3.3源码jar包<br>编译JarFileIssueRegistry文件，生成文件大概有4个<br>解压1中的jar包，并替换2文件<br>重新打包zip，在修改后缀名为jar<br>在使用lint规则的地方，添加</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lintClassPath <span class="string">&quot;com.android.tools.lint:lint-api:26.3.3.4-fix-service&quot;</span></span><br></pre></td></tr></table></figure><p>无论是在插件中还是代码中之遥添加如上代码，就会使用已修复的lint SDK，则修复了该问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自定义的lint规则在AGP3.3.3上存在问题，有一多半情况下，自定义lint规则是失效的，他并不能检查到lint问题，到底为什么？该怎么解决？&lt;/p&gt;
&lt;p&gt;为什么？&lt;br&gt;为什么在AGP3.3.3上偶尔失效，而在AGP4.2上就没有问题，在网上搜了很多，这方面的资料很</summary>
      
    
    
    
    <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView筛选框圆角实现</title>
    <link href="http://yoursite.com/2021/12/23/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/RecyclerView%E7%AD%9B%E9%80%89%E6%A1%86%E5%9C%86%E8%A7%92%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2021/12/23/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/RecyclerView%E7%AD%9B%E9%80%89%E6%A1%86%E5%9C%86%E8%A7%92%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-12-23T09:03:15.000Z</published>
    <updated>2023-12-19T06:50:38.179Z</updated>
    
    <content type="html"><![CDATA[<p>筛选框是app的常用功能，如何实现下图红圈功能呢？</p><p><img src="/imageMd/image-recyclerView.png" alt="image-recyclerView"><br>首先左侧目录可以通过一个RecyclerView实现，右侧同样可以实现一个RecyclerView，左侧的RecyclerView中我们想实现圆角的，但是该圆角的View已经不在ViewHolder中，我们很难在ViewHolder中画出两个圆角，所以我们通过其他方法实现</p><p>ItemDecoration有三个重要方法：</p><p>onDraw：在ViewHolder下方绘制</p><p>onDrawOver：在ViewHolder上方绘制</p><p>getItemOffsets：ViewHolder的偏移量</p><p>其中我们可以通过onDrawOver实现，将两个圆角绘制在ViewHolder上方显示出来</p><p>首先，我们搭建一个RecyclerView</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mRecyclerView <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        findViewById&lt;RecyclerView&gt;(R.id.recycler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mAdapter: MainAdapter? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mList: ArrayList&lt;Item&gt; = ArrayList()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        initData()</span><br><span class="line">        mAdapter = MainAdapter(mList, <span class="keyword">object</span> : MainAdapter.OnItemClick &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onItemClick</span><span class="params">(view: <span class="type">View</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> mList) &#123;</span><br><span class="line">                    i.apply &#123;</span><br><span class="line">                        isChecked = <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mList[position].apply &#123;</span><br><span class="line">                    isChecked = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                mAdapter?.notifyDataSetChanged()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        mRecyclerView.adapter = mAdapter</span><br><span class="line">        mRecyclerView.layoutManager = LinearLayoutManager(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mList.clear()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span>) &#123;</span><br><span class="line">            mList.add(Item(<span class="string">&quot;第<span class="subst">$&#123;i&#125;</span>个&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Item</span>(<span class="keyword">val</span> text: String, <span class="keyword">var</span> isChecked: <span class="built_in">Boolean</span> = <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MainAdapter</span>(<span class="keyword">private</span> <span class="keyword">val</span> list: ArrayList&lt;Item&gt;, <span class="keyword">private</span> <span class="keyword">val</span> onItemClick: OnItemClick? = <span class="literal">null</span>) : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> context: Context? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: RecyclerView.ViewHolder &#123;</span><br><span class="line">            <span class="keyword">val</span> view = LayoutInflater.from(parent.context).inflate(R.layout.vh_item, parent, <span class="literal">false</span>)</span><br><span class="line">            context = parent.context</span><br><span class="line">            <span class="keyword">return</span> MainViewHolder(view, onItemClick)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> item = list[position]</span><br><span class="line">            holder <span class="keyword">as</span> MainViewHolder</span><br><span class="line">            holder.setText(item.text)</span><br><span class="line">            (<span class="keyword">if</span> (item.isChecked) context?.let &#123; getColor(it, R.color.white) &#125; <span class="keyword">else</span> Color.parseColor(<span class="string">&quot;#F6F6F6&quot;</span>))?.let &#123; holder.setBackgroundColor(it) &#125;</span><br><span class="line">            holder.itemView.tag = <span class="keyword">if</span> (item.isChecked) <span class="string">&quot;true&quot;</span> <span class="keyword">else</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = list.size</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">MainViewHolder</span>(itemView: View, onItemClick: OnItemClick?) : RecyclerView.ViewHolder(itemView) &#123;</span><br><span class="line">            <span class="keyword">init</span> &#123;</span><br><span class="line">                itemView.setOnClickListener &#123;</span><br><span class="line">                    onItemClick?.onItemClick(it, adapterPosition)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">setText</span><span class="params">(text: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                itemView.findViewById&lt;TextView&gt;(R.id.item_text).text = text ?: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">setBackgroundColor</span><span class="params">(color: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">                itemView.setBackgroundColor(color)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">OnItemClick</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">onItemClick</span><span class="params">(view: <span class="type">View</span>, position: <span class="type">Int</span>)</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//activity_main</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/recycler&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#F6F6F6&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//vh_item</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#F6F6F6&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/item_text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;123&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;16sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@color/black&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当在选中的时候改变VH的颜色，之后我们需要添加一个ItemDecoration，在ItemDecoration中我们需要知道选中的View，获取View宽高后，进行上下圆角的绘制</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BorderItemDecoration</span>() : RecyclerView.ItemDecoration() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDrawOver</span><span class="params">(c: <span class="type">Canvas</span>, parent: <span class="type">RecyclerView</span>, state: <span class="type">RecyclerView</span>.<span class="type">State</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDrawOver(c, parent, state)</span><br><span class="line">        <span class="keyword">for</span> (view <span class="keyword">in</span> parent.children) &#123;</span><br><span class="line">            <span class="keyword">if</span> (view.tag == <span class="string">&quot;true&quot;</span>) &#123;</span><br><span class="line">                drawTop(c, view)</span><br><span class="line">                drawBottom(c, view)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawTop</span><span class="params">(c: <span class="type">Canvas</span>, view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> paint = Paint()</span><br><span class="line">        <span class="keyword">val</span> rect = Rect()</span><br><span class="line">        <span class="keyword">val</span> top = view.top</span><br><span class="line">        <span class="keyword">val</span> radius = view.resources.displayMetrics.density * <span class="number">40</span></span><br><span class="line">        rect.<span class="keyword">set</span>((view.width - radius).toInt(), (top - radius).toInt(), view.width, view.top)</span><br><span class="line">        paint.color = Color.WHITE</span><br><span class="line">        paint.style = Paint.Style.FILL</span><br><span class="line">        c.drawRect(rect, paint)</span><br><span class="line"></span><br><span class="line">        paint.color = Color.parseColor(<span class="string">&quot;#F6F6F6&quot;</span>)</span><br><span class="line">        c.drawCircle(view.width - radius, top - radius, radius, paint)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawBottom</span><span class="params">(c: <span class="type">Canvas</span>, view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> paint = Paint()</span><br><span class="line">        <span class="keyword">val</span> rect = Rect()</span><br><span class="line">        <span class="keyword">val</span> bottom = view.bottom</span><br><span class="line">        <span class="keyword">val</span> radius = view.resources.displayMetrics.density * <span class="number">40</span></span><br><span class="line">        c.translate(<span class="number">0f</span>, <span class="number">0f</span>)</span><br><span class="line">        rect.<span class="keyword">set</span>((view.width - radius).toInt(), (bottom + radius).toInt(), view.width, view.bottom)</span><br><span class="line">        paint.color = Color.WHITE</span><br><span class="line">        paint.style = Paint.Style.FILL</span><br><span class="line">        c.drawRect(rect, paint)</span><br><span class="line"></span><br><span class="line">        paint.color = Color.parseColor(<span class="string">&quot;#F6F6F6&quot;</span>)</span><br><span class="line">        c.drawCircle(view.width - radius, bottom + radius, radius, paint)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制的细节如下：</p><ol><li>先绘制获取选中view的坐标，计算出圆角半径的矩形位置，使用白色填充</li><li>在圆角半径内画圆，填充为#F6F6F6颜色，剩下的就是圆角白色</li></ol><p>上下方法相同。</p><p>效果如下：</p><p><img src="/imageMd/video-recyclerView.gif" alt="video_recyclerView"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;筛选框是app的常用功能，如何实现下图红圈功能呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/imageMd/image-recyclerView.png&quot; alt=&quot;image-recyclerView&quot;&gt;&lt;br&gt;首先左侧目录可以通过一个RecyclerView实现，右侧同样可</summary>
      
    
    
    
    <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>日夜间及换肤（二）-原理分析</title>
    <link href="http://yoursite.com/2021/07/28/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E6%97%A5%E5%A4%9C%E9%97%B4%E5%8F%8A%E6%8D%A2%E8%82%A4%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2021/07/28/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E6%97%A5%E5%A4%9C%E9%97%B4%E5%8F%8A%E6%8D%A2%E8%82%A4%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2021-07-28T11:36:04.000Z</published>
    <updated>2023-12-19T06:50:38.180Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>原始地址：<a href="https://hanmingkang.github.io/2021/07/28/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E6%97%A5%E5%A4%9C%E9%97%B4%E5%8F%8A%E6%8D%A2%E8%82%A4%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">日夜间及换肤（二）-原理分析</a></p><h2 id="官方原理"><a href="#官方原理" class="headerlink" title="官方原理"></a>官方原理</h2><p><img src="/imageMd/daynight-2.jpg" alt="img"></p><p>在官方的推荐方法中，我们发现了每次设置完Mode或者Theme都需要recreate()才会生效，这是为什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cause this Activity to be recreated with a new instance.  This results</span></span><br><span class="line"><span class="comment"> * in essentially the same flow as when the Activity is created due to</span></span><br><span class="line"><span class="comment"> * a configuration change -- the current instance will go through its</span></span><br><span class="line"><span class="comment"> * lifecycle to &#123;<span class="doctag">@link</span> #onDestroy&#125; and a new instance then created after it.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><blockquote><p>使用新实例重新创建此活动。 这导致与由于配置更改而创建 Activity 时的流程基本相同————当前实例将通过其生命周期到达onDestroy ，然后在它之后创建一个新实例</p></blockquote><p>即当前Activity进入onDestroy，重新创建一个Activity，所以会执行新Activity的生命周期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AppCompatDelegate</span> <span class="variable">delegate</span> <span class="operator">=</span> getDelegate();</span><br><span class="line">    delegate.installViewFactory();</span><br><span class="line">    delegate.onCreate(savedInstanceState);</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入delegate.onCreate()方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="comment">// attachBaseContext will only be called from an Activity, so make sure we switch this for</span></span><br><span class="line">    <span class="comment">// Dialogs, etc</span></span><br><span class="line">    mBaseContextAttached = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Our implicit call to applyDayNight() should not recreate until after the Activity is</span></span><br><span class="line">    <span class="comment">// created</span></span><br><span class="line">    applyDayNight(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击进入applyDayNight方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">applyDayNight</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> allowRecreation)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (mIsDestroyed) &#123;</span><br><span class="line">           <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">               Log.d(TAG, <span class="string">&quot;applyDayNight. Skipping because host is destroyed&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// If we&#x27;re destroyed, ignore the call</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@NightMode</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">nightMode</span> <span class="operator">=</span> calculateNightMode();</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>进入calculateNightMode()中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@NightMode</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calculateNightMode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mLocalNightMode != MODE_NIGHT_UNSPECIFIED ? mLocalNightMode : getDefaultNightMode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDefaultNightMode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sDefaultNightMode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setDefaultNightMode</span><span class="params">(<span class="meta">@NightMode</span> <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MODE_NIGHT_NO:</span><br><span class="line">        <span class="keyword">case</span> MODE_NIGHT_YES:</span><br><span class="line">        <span class="keyword">case</span> MODE_NIGHT_FOLLOW_SYSTEM:</span><br><span class="line">        <span class="keyword">case</span> MODE_NIGHT_AUTO_TIME:</span><br><span class="line">        <span class="keyword">case</span> MODE_NIGHT_AUTO_BATTERY:</span><br><span class="line">            <span class="keyword">if</span> (sDefaultNightMode != mode) &#123;</span><br><span class="line">                sDefaultNightMode = mode;</span><br><span class="line">                applyDayNightToActiveDelegates();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;setDefaultNightMode() called with an unknown mode&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取mode类型后进行加载日夜间效果，所以在该方式下要达到动态切换，势必要重新执行onCreate方法</p><blockquote><p>androidx中sdk中已经将recreate方法放入setDefaultNightMode()方法中，所以不需要手动调用</p></blockquote><p>无论通过<code>AppCompatDelegate.setDefaultNightMode</code>还是<code>delegate.setLocalNightMode</code>，都会执行到<code>updateForNightMode</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">updateForNightMode</span><span class="params">(<span class="meta">@ApplyableNightMode</span> <span class="keyword">final</span> <span class="type">int</span> mode,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">boolean</span> allowRecreation)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">        ActivityCompat.recreate((Activity) mHost);</span><br><span class="line">        handled = <span class="literal">true</span>;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行recreate重新构建Activity</p><h2 id="第三方库实现原理"><a href="#第三方库实现原理" class="headerlink" title="第三方库实现原理"></a>第三方库实现原理</h2><p><a href="https://github.com/ximsfei/Android-skin-support">Android-skin-support</a></p><h3 id="原理分析（SdkVersion-29）"><a href="#原理分析（SdkVersion-29）" class="headerlink" title="原理分析（SdkVersion &#x3D; 29）"></a>原理分析（SdkVersion &#x3D; 29）</h3><p><img src="/imageMd/daynight-3.jpg" alt="img"></p><p>怎么做到的呢？</p><p>我们回顾一下setContentView()的加载过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//androidx.appcompat.app.AppcompatActivity</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> layoutResID)</span> &#123;</span><br><span class="line">        getDelegate().setContentView(layoutResID);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入代理中查看实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//androidx.appcompat.app.AppcompatDelegateImpl</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="type">int</span> resId)</span> &#123;</span><br><span class="line">  <span class="comment">//初始化DecroView</span></span><br><span class="line">    ensureSubDecor();</span><br><span class="line">  <span class="comment">//获取Content根布局</span></span><br><span class="line">    <span class="type">ViewGroup</span> <span class="variable">contentParent</span> <span class="operator">=</span> mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">  <span class="comment">//移除所有布局</span></span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line"> <span class="comment">//加载布局</span></span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">  <span class="comment">//布局状态接口通知</span></span><br><span class="line">    mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入inflate方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android.view.LayoutInflater</span></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> inflate(resource, root, root != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Resources</span> <span class="variable">res</span> <span class="operator">=</span> getContext().getResources();</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"><span class="comment">// 根据XML预编译生成compiled_view.dex, 然后通过反射来生成对应的View，从而减少XmlPullParser解析Xml的时间</span></span><br><span class="line"><span class="comment">// 需要注意的是在目前的release版本中不支持使用</span></span><br><span class="line">    <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> tryInflatePrecompiled(resource, res, root, attachToRoot);</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//使用xml进行解析返回一个XmlResourceParser，内部最终会进入native方法进行解析</span></span><br><span class="line">    <span class="type">XmlResourceParser</span> <span class="variable">parser</span> <span class="operator">=</span> res.getLayout(resource);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入inflate中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android.view.LayoutInflater</span></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(XmlPullParser parser, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//找到START_TAG，否则报异常，说没有入口</span></span><br><span class="line">            advanceToRootNode(parser);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parser.getName();</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">              </span><br><span class="line">          <span class="comment">//如果是merge标签，查看merge是不是根节点，不然的话抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(<span class="string">&quot;&lt;merge /&gt; can be used only with a valid &quot;</span></span><br><span class="line">                            + <span class="string">&quot;ViewGroup root and attachToRoot=true&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Temp is the root view that was found in the xml</span></span><br><span class="line">              <span class="comment">//获取根节点View</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">temp</span> <span class="operator">=</span> createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line">               ...</span><br><span class="line">                <span class="comment">//渲染根节点的孩子们</span></span><br><span class="line">                rInflateChildren(parser, temp, attrs, <span class="literal">true</span>);</span><br><span class="line">              ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入rInflateChildren()中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">rInflateChildren</span><span class="params">(XmlPullParser parser, View parent, AttributeSet attrs,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> finishInflate)</span> <span class="keyword">throws</span> XmlPullParserException, IOException &#123;</span><br><span class="line">    rInflate(parser, parent, parent.getContext(), attrs, finishInflate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rInflate</span><span class="params">(XmlPullParser parser, View parent, Context context,</span></span><br><span class="line"><span class="params">        AttributeSet attrs, <span class="type">boolean</span> finishInflate)</span> <span class="keyword">throws</span> XmlPullParserException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> parser.getDepth();</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pendingRequestFocus</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//循环便利布局，直到布局完成</span></span><br><span class="line">    <span class="keyword">while</span> (((type = parser.next()) != XmlPullParser.END_TAG ||</span><br><span class="line">            parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">            <span class="comment">//获取当前布局的View</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> createViewFromTag(parent, name, context, attrs);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ViewGroup</span> <span class="variable">viewGroup</span> <span class="operator">=</span> (ViewGroup) parent;</span><br><span class="line">            <span class="keyword">final</span> ViewGroup.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> viewGroup.generateLayoutParams(attrs);</span><br><span class="line">      <span class="comment">//渲染当前布局View的孩子们</span></span><br><span class="line">            rInflateChildren(parser, view, attrs, <span class="literal">true</span>);</span><br><span class="line">      <span class="comment">//组合为ViewGroup</span></span><br><span class="line">            viewGroup.addView(view, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pendingRequestFocus) &#123;</span><br><span class="line">        parent.restoreDefaultFocus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (finishInflate) &#123;</span><br><span class="line">        parent.onFinishInflate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入createViewFromTag():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android.view.LayoutInflater</span></span><br><span class="line">View <span class="title function_">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> ignoreThemeAttr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;view&quot;</span>)) &#123;</span><br><span class="line">            name = attrs.getAttributeValue(<span class="literal">null</span>, <span class="string">&quot;class&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Apply a theme wrapper, if allowed and one is specified.</span></span><br><span class="line">        <span class="keyword">if</span> (!ignoreThemeAttr) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">TypedArray</span> <span class="variable">ta</span> <span class="operator">=</span> context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">themeResId</span> <span class="operator">=</span> ta.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (themeResId != <span class="number">0</span>) &#123;</span><br><span class="line">                context = <span class="keyword">new</span> <span class="title class_">ContextThemeWrapper</span>(context, themeResId);</span><br><span class="line">            &#125;</span><br><span class="line">            ta.recycle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> tryCreateView(parent, name, context, attrs);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lastContext</span> <span class="operator">=</span> mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">                mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                        view = onCreateView(context, parent, name, attrs);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        view = createView(context, name, <span class="literal">null</span>, attrs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InflateException e) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进行tryCreateView方法，如果view为null，则执行onCreateView或者createView方法，</p><p>无论是onCreateView还是createView最终都会进入如下函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title function_">createView</span><span class="params">(<span class="meta">@NonNull</span> Context viewContext, <span class="meta">@NonNull</span> String name,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> String prefix, <span class="meta">@Nullable</span> AttributeSet attrs)</span></span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException, InflateException &#123;</span><br><span class="line">    Objects.requireNonNull(viewContext);</span><br><span class="line">    Objects.requireNonNull(name);</span><br><span class="line">    Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">View</span>&gt; constructor = sConstructorMap.get(name);</span><br><span class="line">    <span class="keyword">if</span> (constructor != <span class="literal">null</span> &amp;&amp; !verifyClassLoader(constructor)) &#123;</span><br><span class="line">        constructor = <span class="literal">null</span>;</span><br><span class="line">        sConstructorMap.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">View</span>&gt; clazz = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (constructor == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Class not found in the cache, see if it&#x27;s real, and try to add it</span></span><br><span class="line">            clazz = Class.forName(prefix != <span class="literal">null</span> ? (prefix + name) : name, <span class="literal">false</span>,</span><br><span class="line">                    mContext.getClassLoader()).asSubclass(View.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mFilter != <span class="literal">null</span> &amp;&amp; clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">allowed</span> <span class="operator">=</span> mFilter.onLoadClass(clazz);</span><br><span class="line">                <span class="keyword">if</span> (!allowed) &#123;</span><br><span class="line">                    failNotAllowed(name, prefix, viewContext, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            constructor = clazz.getConstructor(mConstructorSignature);</span><br><span class="line">            constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            sConstructorMap.put(name, constructor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If we have a filter, apply it to cached constructor</span></span><br><span class="line">            <span class="keyword">if</span> (mFilter != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Have we seen this name before?</span></span><br><span class="line">                <span class="type">Boolean</span> <span class="variable">allowedState</span> <span class="operator">=</span> mFilterMap.get(name);</span><br><span class="line">                <span class="keyword">if</span> (allowedState == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// New class -- remember whether it is allowed</span></span><br><span class="line">                    clazz = Class.forName(prefix != <span class="literal">null</span> ? (prefix + name) : name, <span class="literal">false</span>,</span><br><span class="line">                            mContext.getClassLoader()).asSubclass(View.class);</span><br><span class="line"></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">allowed</span> <span class="operator">=</span> clazz != <span class="literal">null</span> &amp;&amp; mFilter.onLoadClass(clazz);</span><br><span class="line">                    mFilterMap.put(name, allowed);</span><br><span class="line">                    <span class="keyword">if</span> (!allowed) &#123;</span><br><span class="line">                        failNotAllowed(name, prefix, viewContext, attrs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allowedState.equals(Boolean.FALSE)) &#123;</span><br><span class="line">                    failNotAllowed(name, prefix, viewContext, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">lastContext</span> <span class="operator">=</span> mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">        mConstructorArgs[<span class="number">0</span>] = viewContext;</span><br><span class="line">        Object[] args = mConstructorArgs;</span><br><span class="line">        args[<span class="number">1</span>] = attrs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> constructor.newInstance(args);</span><br><span class="line">            <span class="keyword">if</span> (view <span class="keyword">instanceof</span> ViewStub) &#123;</span><br><span class="line">                <span class="comment">// Use the same context when inflating ViewStub later.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">ViewStub</span> <span class="variable">viewStub</span> <span class="operator">=</span> (ViewStub) view;</span><br><span class="line">                viewStub.setLayoutInflater(cloneInContext((Context) args[<span class="number">0</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单看一下可以确认是通过反射实现的</p><p>然后我们进入tryCreateView()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android.view.LayoutInflater</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title function_">tryCreateView</span><span class="params">(<span class="meta">@Nullable</span> View parent, <span class="meta">@NonNull</span> String name,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.equals(TAG_1995)) &#123;</span><br><span class="line">        <span class="comment">// Let&#x27;s party like it&#x27;s 1995!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BlinkLayout</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    View view;</span><br><span class="line">    <span class="keyword">if</span> (mFactory2 != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//系统一般会创建Factory2的对象</span></span><br><span class="line">        view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        view = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (view == <span class="literal">null</span> &amp;&amp; mPrivateFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这个<code>mFactory2/mFactory.onCreateView()</code>要走哪里呢？Factory实例在哪里呢？</p><p><strong>接下来</strong></p><p>我们需要分析setContenView()之前都做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击super.onCreate(saveInstanceState)方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//androidx.appcompat.app.AppCompatActivity</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AppCompatDelegate</span> <span class="variable">delegate</span> <span class="operator">=</span> getDelegate();</span><br><span class="line">    delegate.installViewFactory();</span><br><span class="line">    delegate.onCreate(savedInstanceState);</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入installViewFactory()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//androidx.appcompat.app.AppCompatDelegateImpl</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">installViewFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LayoutInflater</span> <span class="variable">layoutInflater</span> <span class="operator">=</span> LayoutInflater.from(mContext);</span><br><span class="line">    <span class="keyword">if</span> (layoutInflater.getFactory() == <span class="literal">null</span>) &#123;</span><br><span class="line">        LayoutInflaterCompat.setFactory2(layoutInflater, <span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(layoutInflater.getFactory2() <span class="keyword">instanceof</span> AppCompatDelegateImpl)) &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;The Activity&#x27;s LayoutInflater already has a Factory installed&quot;</span></span><br><span class="line">                    + <span class="string">&quot; so we can not install AppCompat&#x27;s&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过获取layoutInflater.getFactory()进行获取，如果没有就会setFactory2进行设置。</p><p>在其中进行setFactory初始化，注意第二个参数，传入的是this，那么，我们看一下这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AppCompatDelegateImpl</span> <span class="keyword">extends</span> <span class="title class_">AppCompatDelegate</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">MenuBuilder</span>.Callback, LayoutInflater.Factory2</span><br></pre></td></tr></table></figure><p>很好，他是一个实现Factory2接口的类，那么我们直接找onCreateView的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">createView</span><span class="params">(View parent, <span class="keyword">final</span> String name, <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        mAppCompatViewInflater = <span class="keyword">new</span> <span class="title class_">AppCompatViewInflater</span>();</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext,</span><br><span class="line">            IS_PRE_LOLLIPOP, <span class="comment">/* Only read android:theme pre-L (L+ handles this anyway) */</span></span><br><span class="line">            <span class="literal">true</span>, <span class="comment">/* Read read app:theme as a fallback at all times for legacy reasons */</span></span><br><span class="line">            VectorEnabledTintResources.shouldBeUsed() <span class="comment">/* Only tint wrap the context if enabled */</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实调用的是AppcompatViewInflater.createView()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> View <span class="title function_">createView</span><span class="params">(View parent, <span class="keyword">final</span> String name, <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">          <span class="meta">@NonNull</span> AttributeSet attrs, <span class="type">boolean</span> inheritContext,</span></span><br><span class="line"><span class="params">          <span class="type">boolean</span> readAndroidTheme, <span class="type">boolean</span> readAppTheme, <span class="type">boolean</span> wrapContext)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;TextView&quot;</span>:</span><br><span class="line">              view = createTextView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">              <span class="comment">// The fallback that allows extending class to take over view inflation</span></span><br><span class="line">              <span class="comment">// for other tags. Note that we don&#x27;t check that the result is not-null.</span></span><br><span class="line">              <span class="comment">// That allows the custom inflater path to fall back on the default one</span></span><br><span class="line">              <span class="comment">// later in this method.</span></span><br><span class="line">              view = createView(context, name, attrs);</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br><span class="line">      <span class="keyword">return</span> view;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">protected</span> AppCompatTextView <span class="title function_">createTextView</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppCompatTextView</span>(context, attrs);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过new的方式新建view，如果switch没有得到处理，则返回view为null，通过反射处理即可</p><h3 id="我们要怎么做？"><a href="#我们要怎么做？" class="headerlink" title="我们要怎么做？"></a>我们要怎么做？</h3><p><strong>Factory和Factory2的区别是什么？</strong></p><p>可惜我们不能从文档说明上获得什么，我们就直接看代码吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    View <span class="title function_">onCreateView</span><span class="params">(<span class="meta">@NonNull</span> String name, <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> AttributeSet attrs)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory2</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    View <span class="title function_">onCreateView</span><span class="params">(<span class="meta">@Nullable</span> View parent, <span class="meta">@NonNull</span> String name,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> Context context, <span class="meta">@NonNull</span> AttributeSet attrs)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段中多了一个View的父类，可以认为Factory2是对Factory的重载</p><p>在分析过程中，我们发现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//androidx.appcompat.app.AppCompatDelegateImpl</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">installViewFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LayoutInflater</span> <span class="variable">layoutInflater</span> <span class="operator">=</span> LayoutInflater.from(mContext);</span><br><span class="line">    <span class="keyword">if</span> (layoutInflater.getFactory() == <span class="literal">null</span>) &#123;</span><br><span class="line">        LayoutInflaterCompat.setFactory2(layoutInflater, <span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(layoutInflater.getFactory2() <span class="keyword">instanceof</span> AppCompatDelegateImpl)) &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;The Activity&#x27;s LayoutInflater already has a Factory installed&quot;</span></span><br><span class="line">                    + <span class="string">&quot; so we can not install AppCompat&#x27;s&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统的处理是默认会取Factory，如果没有，才会新建，走AppCompatDelegateImpl，如果我们在这个super.onCreate()方法之前设置Factory就可以让系统走我们的Factory实现</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>最终我们在Activity的onCreate方法之前执行我们的设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    LayoutInflaterCompat.setFactory(getLayoutInflater(), getSkinDelegate());</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时在createView方法中生成自己的view，在view中设置刷新接口，通过观察者模式在模式变化的时候通知所有的view，变更背景色，字体色等，不需要重新构建Activity，避免闪屏</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;原始地址：&lt;a href=&quot;https://hanmingkang.github.io/2021/07/28/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E6%97%A5%E5%A4</summary>
      
    
    
    
    <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>日夜间及换肤（一）-常用技巧</title>
    <link href="http://yoursite.com/2021/07/28/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E6%97%A5%E5%A4%9C%E9%97%B4%E5%8F%8A%E6%8D%A2%E8%82%A4%EF%BC%88%E4%B8%80%EF%BC%89-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2021/07/28/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E6%97%A5%E5%A4%9C%E9%97%B4%E5%8F%8A%E6%8D%A2%E8%82%A4%EF%BC%88%E4%B8%80%EF%BC%89-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2021-07-28T10:32:22.000Z</published>
    <updated>2023-12-19T06:50:38.180Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>原地址：<a href="https://hanmingkang.github.io/2021/07/28/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E6%97%A5%E5%A4%9C%E9%97%B4%E5%8F%8A%E6%8D%A2%E8%82%A4%EF%BC%88%E4%B8%80%EF%BC%89-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">日夜间及换肤（一）-常用技巧</a></p><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>实现日夜间的方式有多种，基本可以整理如下：</p><ol><li>设置UiMode来设置</li><li>对Activity设置主题来变换</li><li>动态设置资源，控制view刷新</li></ol><h3 id="UIMode实现"><a href="#UIMode实现" class="headerlink" title="UIMode实现"></a>UIMode实现</h3><ol><li><p>在value的同级目录下新建一个<code>values-night</code>的目录，其中新建colors.xml文件，themes.xml文件等需要日夜间切换</p><p><img src="/imageMd/daynight-1.jpg" alt="daynight-1"></p></li><li><p>比如colors文件，需要将color所对应的名字保持一致，只进行颜色上的更改，达到日夜间不同的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//normal</span></span><br><span class="line">&lt;color name=<span class="string">&quot;background&quot;</span>&gt;#FFFFFFFF&lt;/color&gt; <span class="comment">//白色</span></span><br><span class="line">&lt;color name=<span class="string">&quot;text_color&quot;</span>&gt;#FF000000&lt;/color&gt; <span class="comment">//黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//night</span></span><br><span class="line">&lt;color name=<span class="string">&quot;background&quot;</span>&gt;#FF000000&lt;/color&gt; <span class="comment">//黑色</span></span><br><span class="line">&lt;color name=<span class="string">&quot;text_color&quot;</span>&gt;#FFFFFFFF&lt;/color&gt; <span class="comment">//白色</span></span><br></pre></td></tr></table></figure></li><li><p>在需要触发切换的地方调用如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置所有的Activity生效</span></span><br><span class="line"><span class="keyword">if</span> (AppCompatDelegate.getDefaultNightMode() == AppCompatDelegate.MODE_NIGHT_YES) &#123;</span><br><span class="line">    <span class="comment">//切换白天</span></span><br><span class="line">    AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//切换夜间</span></span><br><span class="line">    AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置所在的Activity生效</span></span><br><span class="line"><span class="keyword">if</span>(delegate.localNightMode == AppCompatDelegate.MODE_NIGHT_YES)&#123;</span><br><span class="line">     <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123;</span><br><span class="line">           <span class="comment">//切换白天</span></span><br><span class="line">           delegate.localNightMode = AppCompatDelegate.MODE_NIGHT_NO</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123;</span><br><span class="line">          <span class="comment">//切换夜间</span></span><br><span class="line">          delegate.localNightMode = AppCompatDelegate.MODE_NIGHT_YES</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//五种参数类型</span></span><br><span class="line"><span class="comment">//跟随系统</span></span><br><span class="line">MODE_NIGHT_FOLLOW_SYSTEM</span><br><span class="line"><span class="comment">//跟随时间自动设置</span></span><br><span class="line">MODE_NIGHT_AUTO_TIME</span><br><span class="line"><span class="comment">//日间</span></span><br><span class="line">MODE_NIGHT_NO</span><br><span class="line"><span class="comment">//夜间</span></span><br><span class="line">MODE_NIGHT_YES</span><br><span class="line"><span class="comment">//根据系统电量决定暗色和亮色展示</span></span><br><span class="line">MODE_NIGHT_AUTO_BATTERY</span><br></pre></td></tr></table></figure></li></ol><p>系统会根据日夜间自动去取<code>*-night</code>或者正常的文件夹相对应的配置，配合持久化存储进行日夜间状态存储，二次打开加载上一次设置的模式</p><h3 id="设置Activity主题实现"><a href="#设置Activity主题实现" class="headerlink" title="设置Activity主题实现"></a>设置Activity主题实现</h3><ol><li><p>在colors.xml中新建日夜间两种颜色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;color name=<span class="string">&quot;background_day&quot;</span>&gt;#FFFFFFFF&lt;/color&gt;</span><br><span class="line">    &lt;color name=<span class="string">&quot;background_night&quot;</span>&gt;#FF000000&lt;/color&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></li><li><p>在res&#x2F;values目录下新建attrs.xml文件，添加自定义属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;attr name=<span class="string">&quot;custom_bg&quot;</span> format=<span class="string">&quot;color|reference&quot;</span>/&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></li><li><p>在res&#x2F;values目录下新建themes.xml文件，添加两种主题如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span><br><span class="line">    &lt;style name=<span class="string">&quot;Theme.MyDay&quot;</span> parent=<span class="string">&quot;Theme.AppCompat&quot;</span>&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;custom_bg&quot;</span>&gt;<span class="meta">@color</span>/background_day&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">    &lt;style name=<span class="string">&quot;Theme.MyNight&quot;</span> parent=<span class="string">&quot;Theme.AppCompat&quot;</span>&gt;</span><br><span class="line">        &lt;item name=<span class="string">&quot;custom_bg&quot;</span>&gt;<span class="meta">@color</span>/background_night&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></li><li><p>在布局文件中使用自定义属性颜色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;androidx.core.widget.NestedScrollView </span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:background=<span class="string">&quot;?attr/custom_bg&quot;</span></span><br><span class="line">    tools:context=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span><br><span class="line">      ...</span><br><span class="line">&lt;/androidx.core.widget.NestedScrollView&gt;</span><br></pre></td></tr></table></figure></li><li><p>在Activity中配置</p><ol><li><p>只在当前Activity中生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : AppCompatActivity() &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">var</span> <span class="variable">myTheme</span> <span class="operator">=</span> R.style.Theme_MyDay</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> lateinit <span class="keyword">var</span> binding:ActivityMainBinding</span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="comment">// 判断是否有主题存储</span></span><br><span class="line">        <span class="keyword">if</span>(savedInstanceState != <span class="literal">null</span>)&#123;</span><br><span class="line">            myTheme = savedInstanceState.getInt(<span class="string">&quot;theme&quot;</span>)</span><br><span class="line">            setTheme(myTheme)</span><br><span class="line">        &#125;</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        initView()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> fun <span class="title function_">initView</span><span class="params">()</span> &#123;</span><br><span class="line">        binding.button2.setOnClickListener &#123;</span><br><span class="line">            myTheme = <span class="keyword">if</span>(myTheme == R.style.Theme_MyDay)&#123;</span><br><span class="line">                R.style.Theme_MyNight</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                R.style.Theme_MyDay</span><br><span class="line">            &#125;</span><br><span class="line">            recreate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   override fun <span class="title function_">onSaveInstanceState</span><span class="params">(outState: Bundle)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onSaveInstanceState(outState)</span><br><span class="line">        outState.putInt(<span class="string">&quot;theme&quot;</span>, myTheme)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onRestoreInstanceState</span><span class="params">(savedInstanceState: Bundle)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onRestoreInstanceState(savedInstanceState)</span><br><span class="line">        myTheme = savedInstanceState.getInt(<span class="string">&quot;theme&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为setContentView()时进行主题加载和布局渲染，所以需要在setContentView()之前调用<code>setTheme</code>方法，如需动态替换日夜间模式，同样需要<code>recreate()</code>才能生效，因为牵扯到Activity的重建，所以我们第一反应是通过onSaveInstance存储主题，在onCreate中进行加载，当然也可以使用其他方式。</p></li><li><p>在所有Activity生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> : Application() &#123;</span><br><span class="line">    companion object&#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">myTheme</span> <span class="operator">=</span> R.style.Theme_MyDay</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">activityLifecycle</span> <span class="operator">=</span> object : ActivityLifecycleCallbacks &#123;</span><br><span class="line">        override fun <span class="title function_">onActivityCreated</span><span class="params">(activity: Activity, savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">            activity.setTheme(myTheme)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun <span class="title function_">onActivityStarted</span><span class="params">(activity: Activity)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun <span class="title function_">onActivityResumed</span><span class="params">(activity: Activity)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun <span class="title function_">onActivityPaused</span><span class="params">(activity: Activity)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun <span class="title function_">onActivityStopped</span><span class="params">(activity: Activity)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun <span class="title function_">onActivitySaveInstanceState</span><span class="params">(activity: Activity, outState: Bundle)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun <span class="title function_">onActivityDestroyed</span><span class="params">(activity: Activity)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate()</span><br><span class="line">        registerActivityLifecycleCallbacks(activityLifecycle)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Application中进行设置，用静态对象存储主题，监听应用下所有Activity的创建，在<code>onActivityCreate()</code>时，进行主题设置，这样对Activity来说是无感的，只需要设置主题即可。</p><blockquote><p>当然也可以做一个持久化存储，这里只是提供一个思路</p></blockquote></li></ol></li></ol><h3 id="动态设置资源，控制view刷新"><a href="#动态设置资源，控制view刷新" class="headerlink" title="动态设置资源，控制view刷新"></a>动态设置资源，控制view刷新</h3><p>比较代表性的就是<a href="https://github.com/ximsfei/Android-skin-support">Android-skin-support</a>这个库</p><p><a href="https://blog.csdn.net/studyofandroid/article/details/109445822">android-skin-support使用和原理分析</a></p><p>添加如下依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;skin.support:skin-support:4.0.5&#x27;</span>                   <span class="comment">// skin-support</span></span><br><span class="line">implementation <span class="string">&#x27;skin.support:skin-support-appcompat:4.0.5&#x27;</span>         <span class="comment">// skin-support 基础控件支持</span></span><br><span class="line">implementation <span class="string">&#x27;skin.support:skin-support-design:4.0.5&#x27;</span>            <span class="comment">// skin-support-design material design 控件支持[可选]</span></span><br><span class="line">implementation <span class="string">&#x27;skin.support:skin-support-cardview:4.0.5&#x27;</span>          <span class="comment">// skin-support-cardview CardView 控件支持[可选]</span></span><br><span class="line">implementation <span class="string">&#x27;skin.support:skin-support-constraint-layout:4.0.5&#x27;</span> <span class="comment">// skin-support-constraint-layout ConstraintLayout 控件支持[可选]</span></span><br></pre></td></tr></table></figure><p>在Application的onCreate中进行初始化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate();</span><br><span class="line">    SkinCompatManager.withoutActivity(<span class="built_in">this</span>)</span><br><span class="line">            .addInflater(<span class="keyword">new</span> <span class="title class_">SkinAppCompatViewInflater</span>())           <span class="comment">// 基础控件换肤初始化</span></span><br><span class="line">            .addInflater(<span class="keyword">new</span> <span class="title class_">SkinMaterialViewInflater</span>())            <span class="comment">// material design 控件换肤初始化[可选]</span></span><br><span class="line">            .addInflater(<span class="keyword">new</span> <span class="title class_">SkinConstraintViewInflater</span>())          <span class="comment">// ConstraintLayout 控件换肤初始化[可选]</span></span><br><span class="line">            .addInflater(<span class="keyword">new</span> <span class="title class_">SkinCardViewInflater</span>())                <span class="comment">// CardView v7 控件换肤初始化[可选]</span></span><br><span class="line">            .setSkinStatusBarColorEnable(<span class="literal">false</span>)                     <span class="comment">// 关闭状态栏换肤，默认打开[可选]</span></span><br><span class="line">            .setSkinWindowBackgroundEnable(<span class="literal">false</span>)                   <span class="comment">// 关闭windowBackground换肤，默认打开[可选]</span></span><br><span class="line">            .loadSkin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果项目中使用的Activity继承自AppCompatActivity，需要重载getDelegate()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AppCompatDelegate <span class="title function_">getDelegate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SkinAppCompatDelegateImpl.get(<span class="built_in">this</span>, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过如下方法触发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SkinCompatManager.getInstance().loadSkin(<span class="string">&quot;night&quot;</span>, SkinCompatManager.SKIN_LOADER_STRATEGY_BUILD_IN); <span class="comment">// 后缀加载</span></span><br></pre></td></tr></table></figure><p>详细用法查看<a href="https://github.com/ximsfei/Android-skin-support">README</a></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ol><li>UIMode和theme替换都需要重建Activity，所以会导致闪屏，动态替换会更加流畅</li><li>recreate()是在API 11添加进来的，所以会在Android 2.x中使用抛出异常</li><li>theme换肤起来会更加方便</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;原地址：&lt;a href=&quot;https://hanmingkang.github.io/2021/07/28/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E6%97%A5%E5%A4%</summary>
      
    
    
    
    <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>口腔挂号指南</title>
    <link href="http://yoursite.com/2021/07/28/%E9%9A%8F%E7%AC%94/%E5%8F%A3%E8%85%94%E6%8C%82%E5%8F%B7%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2021/07/28/%E9%9A%8F%E7%AC%94/%E5%8F%A3%E8%85%94%E6%8C%82%E5%8F%B7%E6%8C%87%E5%8D%97/</id>
    <published>2021-07-28T03:10:52.000Z</published>
    <updated>2023-12-19T06:50:38.183Z</updated>
    
    <content type="html"><![CDATA[<p>看牙难，口腔科的号无论是在哪，都是非常难挂的，但是牙疼不是病，腾起来要人命，以下是统计的挂号方式，均为线上，以供参考。</p><table><thead><tr><th>时间</th><th>医院</th><th>平台</th></tr></thead><tbody><tr><td>10点</td><td>北京大学口腔（总院）</td><td>北京市预约挂号统一平台</td></tr><tr><td>11点</td><td>北京大学口腔（大屯分院）</td><td>小程序（预约挂号）</td></tr><tr><td>12点</td><td>北京大学口腔（总院）</td><td>小程序（预约挂号）</td></tr><tr><td>15点30分</td><td>北京口腔</td><td>京医通</td></tr><tr><td>14点</td><td>安贞医院</td><td>京医通</td></tr><tr><td>17点</td><td>北京大学口腔（总院）</td><td>小程序（明日挂号）</td></tr><tr><td>18点</td><td>积水潭医院</td><td>京医通</td></tr></tbody></table><blockquote><p>我基本都抢不上，都是靠捡漏号源，时不时的上去看一眼，指不定就有号，运气连连！</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看牙难，口腔科的号无论是在哪，都是非常难挂的，但是牙疼不是病，腾起来要人命，以下是统计的挂号方式，均为线上，以供参考。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;时间&lt;/th&gt;
&lt;th&gt;医院&lt;/th&gt;
&lt;th&gt;平台&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;</summary>
      
    
    
    
    <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Kotlin初探</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/Kotlin%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/Kotlin%E5%88%9D%E6%8E%A2/</id>
    <published>2021-05-31T13:08:21.000Z</published>
    <updated>2023-12-19T06:50:38.178Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>以.kt结尾的程序文件</p><p>优点：</p><ul><li>简洁：大大减少样板代码的数量</li><li>安全：避免空指针异常等整个类的错误</li><li>互操作性：充分利用JVM、Android和游览器的现有库</li><li>工具友好：可用任何Java IDE或者使用命令行构建</li></ul><h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * a:入参   b:入参</span></span><br><span class="line"><span class="comment"> * 返回：Int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;   <span class="comment">// Int 参数，返回值 Int</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum2</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = a + b</span><br></pre></td></tr></table></figure><h4 id="可变长参数函数（vararg）"><a href="#可变长参数函数（vararg）" class="headerlink" title="可变长参数函数（vararg）"></a>可变长参数函数（vararg）</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多个Int参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">vars</span><span class="params">(<span class="keyword">vararg</span> v:<span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vt <span class="keyword">in</span> v)&#123;</span><br><span class="line">        print(<span class="string">&quot;----<span class="variable">$vt</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main :   </span><br><span class="line">vars(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sumLambda:(<span class="built_in">Int</span>,<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123;a,b -&gt;a+b&#125;</span><br><span class="line">println(sumLambda(<span class="number">1</span>,<span class="number">2</span>))  <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure><h4 id="val"><a href="#val" class="headerlink" title="val"></a>val</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修饰不可变的变量，类似于 final，只可被赋值一次</span></span><br><span class="line"><span class="keyword">val</span> &lt;标识符&gt; ：&lt;类型&gt; = &lt;初始化值&gt;</span><br></pre></td></tr></table></figure><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修饰可变的变量，声明时可不指定类型，由编译器判断</span></span><br><span class="line"><span class="keyword">var</span> &lt;标识符&gt; ：&lt;类型&gt; = &lt;初始化值&gt;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> b = <span class="number">1</span>       <span class="comment">// 系统自动推断变量类型为Int</span></span><br><span class="line"><span class="keyword">val</span> c: <span class="built_in">Int</span>      <span class="comment">// 如果不在声明时初始化则必须提供变量类型</span></span><br><span class="line">c = <span class="number">1</span>           <span class="comment">// 明确赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>        <span class="comment">// 系统自动推断变量类型为Int</span></span><br><span class="line">x += <span class="number">1</span>           <span class="comment">// 变量可修改</span></span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin中块注释的级联使用，其实个人觉得块注释的嵌套使用的意义不大，不过从视觉上确实能给人一种层次感</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    第一层块注释</span></span><br><span class="line"><span class="comment">    <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="comment">        第二层块注释</span></span></span><br><span class="line"><span class="comment"><span class="comment">        /*</span></span></span><br><span class="line"><span class="comment"><span class="comment">            第三层快注释</span></span></span><br><span class="line"><span class="comment"><span class="comment">            这种注释方式在java中是不支持的，但是在kotlin中是支持的。算是一个亮点吧（貌似意义不大）。</span></span></span><br><span class="line"><span class="comment"><span class="comment">         */</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h4 id="字符串模版"><a href="#字符串模版" class="headerlink" title="字符串模版"></a>字符串模版</h4><p>$ 表示一个变量名或者变量值<br>$varName 表示变量值<br>${varName.fun()} 表示变量的方法返回值:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// 模板中的简单名称：</span></span><br><span class="line"><span class="keyword">val</span> s1 = <span class="string">&quot;a is <span class="variable">$a</span>&quot;</span> </span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="comment">// 模板中的任意表达式：</span></span><br><span class="line"><span class="keyword">val</span> s2 = <span class="string">&quot;<span class="subst">$&#123;s1.replace(<span class="string">&quot;is&quot;</span>, <span class="string">&quot;was&quot;</span>)&#125;</span>, but now is <span class="variable">$a</span>&quot;</span></span><br></pre></td></tr></table></figure><h4 id="NULL检查机制"><a href="#NULL检查机制" class="headerlink" title="NULL检查机制"></a>NULL检查机制</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型后面加?表示可为空</span></span><br><span class="line"><span class="keyword">var</span> age: String? = <span class="string">&quot;23&quot;</span> </span><br><span class="line"><span class="comment">//抛出空指针异常</span></span><br><span class="line"><span class="keyword">val</span> ages = age!!.toInt()</span><br><span class="line"><span class="comment">//不做处理返回 null</span></span><br><span class="line"><span class="keyword">val</span> ages1 = age?.toInt()</span><br><span class="line"><span class="comment">//age为空返回-1</span></span><br><span class="line"><span class="keyword">val</span> ages2 = age?.toInt() ?: -<span class="number">1</span></span><br><span class="line"><span class="comment">//当 str 中的字符串内容不是一个整数时, 返回 null</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(str: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型检测及自动类型转换"><a href="#类型检测及自动类型转换" class="headerlink" title="类型检测及自动类型转换"></a>类型检测及自动类型转换</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">    <span class="comment">// 做过类型判断以后，obj会被系统自动转换为String类型</span></span><br><span class="line">    <span class="keyword">return</span> obj.length </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在这里还有一种方法，与Java中instanceof不同，使用!is</span></span><br><span class="line">  <span class="comment">// if (obj !is String)&#123;</span></span><br><span class="line">  <span class="comment">//   // XXX</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的obj仍然是Any类型的引用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.4</span>) print(i) <span class="comment">// 输出“1234”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4.</span><span class="number">.1</span>) print(i) <span class="comment">// 什么都不输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123; <span class="comment">// 等同于 1 &lt;= i &amp;&amp; i &lt;= 10</span></span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 step 指定步长</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.4</span> step <span class="number">2</span>) print(i) <span class="comment">// 输出“13”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">4</span> downTo <span class="number">1</span> step <span class="number">2</span>) print(i) <span class="comment">// 输出“42”</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 until 函数排除结束元素</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">10</span>) &#123;   <span class="comment">// i in [1, 10) 排除了 10</span></span><br><span class="line">     println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><table><thead><tr><th>类型</th><th>位宽度</th></tr></thead><tbody><tr><td>Double</td><td>64</td></tr><tr><td>Float</td><td>32</td></tr><tr><td>Long</td><td>64</td></tr><tr><td>Int</td><td>32</td></tr><tr><td>Short</td><td>16</td></tr><tr><td>Byte</td><td>8</td></tr></tbody></table><ul><li>十进制：123</li><li>长整型以大写的 L 结尾：123L</li><li>16 进制以 0x 开头：0x0F</li><li>2 进制以 0b 开头：0b00001011</li><li>Doubles 默认写法: <code>123.5</code>, <code>123.5e10</code></li><li>Floats 使用 f 或者 F 后缀：<code>123.5f</code></li></ul><blockquote><p> 注意：8进制不支持</p></blockquote><p>可以使用下划线使数字常量更易读:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oneMillion = <span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">val</span> creditCardNumber = <span class="number">1234_5678_9012_3456L</span></span><br><span class="line"><span class="keyword">val</span> socialSecurityNumber = <span class="number">999_99_9999L</span></span><br><span class="line"><span class="keyword">val</span> hexBytes = <span class="number">0xFF_EC_DE_5E</span></span><br><span class="line"><span class="keyword">val</span> bytes = <span class="number">0b11010010_01101001_10010100_10010010</span></span><br></pre></td></tr></table></figure><h4 id="比较两个数字"><a href="#比较两个数字" class="headerlink" title="比较两个数字"></a>比较两个数字</h4><blockquote><p>Kotlin 中没有基础数据类型，只有封装的数字类型，你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。</p></blockquote><p>三个等号 &#x3D;&#x3D;&#x3D; 表示比较对象地址，两个 &#x3D;&#x3D; 表示比较两个值大小</p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// OK, 字面值是静态检测的</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b.toInt() <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">toByte(): <span class="built_in">Byte</span></span><br><span class="line">toShort(): <span class="built_in">Short</span></span><br><span class="line">toInt(): <span class="built_in">Int</span></span><br><span class="line">toLong(): <span class="built_in">Long</span></span><br><span class="line">toFloat(): <span class="built_in">Float</span></span><br><span class="line">toDouble(): <span class="built_in">Double</span></span><br><span class="line">toChar(): <span class="built_in">Char</span></span><br></pre></td></tr></table></figure><h4 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shl(bits) – 左移位 (Java’s &lt;&lt;)</span><br><span class="line">shr(bits) – 右移位 (Java’s &gt;&gt;)</span><br><span class="line">ushr(bits) – 无符号右移位 (Java’s &gt;&gt;&gt;)</span><br><span class="line">and(bits) – 与</span><br><span class="line">or(bits) – 或</span><br><span class="line">xor(bits) – 异或</span><br><span class="line">inv() – 反向</span><br></pre></td></tr></table></figure><h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p>Char：使用单引号<code>&#39;</code>包含起来的</p><h4 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h4><p>Boolean：true和false</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|| – 短路逻辑或</span><br><span class="line">&amp;&amp; – 短路逻辑与</span><br><span class="line">! - 逻辑非</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><blockquote><p>注意: 与 Java 不同的是，Kotlin 中数组是不协变的（invariant）。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//[1,2,3]</span></span><br><span class="line">    <span class="keyword">val</span> a = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">//[0,2,4]</span></span><br><span class="line">    <span class="keyword">val</span> b = Array(<span class="number">3</span>, &#123; i -&gt; (i * <span class="number">2</span>) &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数组内容</span></span><br><span class="line">    println(a[<span class="number">0</span>])    <span class="comment">// 输出结果：1</span></span><br><span class="line">    println(b[<span class="number">1</span>])    <span class="comment">// 输出结果：2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了类Array，还有ByteArray, ShortArray, IntArray，用来表示各个类型的数组，省去了装箱操作，因此效率更高，其用法同Array一样</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>和 Java 一样，String 是不可变的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> str) &#123;</span><br><span class="line">    println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 支持三个引号 “”” 扩起来的字符串，支持多行字符串，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    多行字符串</span></span><br><span class="line"><span class="string">    多行字符串</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    println(text)   <span class="comment">// 输出有一些前置空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 可以通过 trimMargin() 方法来删除多余的空白。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    |多行字符串</span></span><br><span class="line"><span class="string">    |菜鸟教程</span></span><br><span class="line"><span class="string">    |多行字符串</span></span><br><span class="line"><span class="string">    |Runoob</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimMargin()</span><br><span class="line">    println(text)    <span class="comment">// 前置空格删除了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(&quot;&gt;&quot;)。</span></span><br></pre></td></tr></table></figure><h4 id="字符串模版表达式"><a href="#字符串模版表达式" class="headerlink" title="字符串模版表达式"></a>字符串模版表达式</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> i = <span class="number">10</span></span><br><span class="line">    <span class="keyword">val</span> s = <span class="string">&quot;i = <span class="variable">$i</span>&quot;</span> <span class="comment">// 求值结果为 &quot;i = 10&quot;</span></span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> s = <span class="string">&quot;runoob&quot;</span></span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;<span class="variable">$s</span>.length is <span class="subst">$&#123;s.length&#125;</span>&quot;</span> <span class="comment">// 求值结果为 &quot;runoob.length is 6&quot;</span></span><br><span class="line">    println(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> price = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;<span class="string">&#x27;$&#x27;</span>&#125;</span>9.99</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    println(price)  <span class="comment">// 求值结果为 $9.99</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="When表达式"><a href="#When表达式" class="headerlink" title="When表达式"></a>When表达式</h4><p>类似于其他语言的switch，else类似于default</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">&quot;x == 1&quot;</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">&quot;x == 2&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123; <span class="comment">// 注意这个块</span></span><br><span class="line">        print(<span class="string">&quot;x 不是 1 ，也不是 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> site = Runoob() <span class="comment">// Kotlin 中没有 new 关键字</span></span><br></pre></td></tr></table></figure><p>主构造器中不能包含任何代码，初始化代码可以放在初始化代码段中，初始化代码段使用 init 关键字作为前缀。</p><p>类也可以有二级构造函数，需要加前缀 constructor</p><p>类默认是不可变的，即是被final修饰的，使用open后，去除final</p><p>内部类使用 inner 关键字来表示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span>    <span class="comment">// 抽象类  </span></span><br><span class="line"><span class="keyword">final</span>       <span class="comment">// 类不可继承，默认属性</span></span><br><span class="line"><span class="keyword">enum</span>        <span class="comment">// 枚举类</span></span><br><span class="line"><span class="keyword">open</span>        <span class="comment">// 类可继承，类默认是final的</span></span><br><span class="line"><span class="keyword">annotation</span>  <span class="comment">// 注解类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>    <span class="comment">// 仅在同一个文件中可见</span></span><br><span class="line"><span class="keyword">protected</span>  <span class="comment">// 同一个文件中或子类可见</span></span><br><span class="line"><span class="keyword">public</span>     <span class="comment">// 所有调用的地方都可见</span></span><br><span class="line"><span class="keyword">internal</span>   <span class="comment">// 同一个模块中可见</span></span><br><span class="line"></span><br><span class="line">模块：</span><br><span class="line">一个 IntelliJ IDEA 模块；</span><br><span class="line">一个 Maven 项目；</span><br><span class="line">一个 Gradle 源集（例外是 test 源集可以访问 main 的 <span class="keyword">internal</span> 声明）；</span><br><span class="line">一次 &lt;kotlinc&gt; Ant 任务执行所编译的一套文件。</span><br></pre></td></tr></table></figure><h4 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">var</span> name:String)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**扩展函数**/</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    print(<span class="string">&quot;用户名 <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(arg:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user = User(<span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line">    user.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h4><h4 id="关键字整理"><a href="#关键字整理" class="headerlink" title="关键字整理"></a>关键字整理</h4><p><img src="https://img-blog.csdnimg.cn/20200603150606240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdlcmxvdmV4aWFvamll,size_16,color_FFFFFF,t_70" alt="img"></p><ol><li>lateinit：延迟初始化</li></ol><p>​作用：<strong>具体来讲，这个关键字告诉编译器，我无法声明的时候就初始化，但是我保证我在使用前一定会初始化，你就别给我检查了。</strong></p><ol start="2"><li>apply：用于对象配置，类似于构造者模式（Builder），调用某对象的apply函数，在函数范围内，可以任意调用该对象的任意方法，并返回该对象</li><li>with：返回是最后一行，然后可以直接调用对象的方法，感觉像是let和apply的结合。</li><li>let：默认当前这个对象作为闭包的it参数，返回值是函数里面最后一行，或者指定return</li><li>also：调用某对象的also函数，则该对象为函数的参数。在函数块内可以通过 it 指代该对象。返回值为该对象自己。</li><li>run：run函数和apply函数很像，只不过run函数是使用最后一行的返回，apply返回当前自己的对象。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;以.kt结尾的程序文件&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简洁：大大减少样板代码的数量&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>内存优化</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</id>
    <published>2021-05-31T13:02:06.000Z</published>
    <updated>2023-12-19T06:50:38.179Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>2895</p><h2 id="为什么要做内存优化？"><a href="#为什么要做内存优化？" class="headerlink" title="为什么要做内存优化？"></a>为什么要做内存优化？</h2><h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTQ4OTY2OS8yMDE4MTAvMTQ4OTY2OS0yMDE4MTAwOTE4NTUyNzMxNi0xNzA4NzkwOTc0LnBuZw" alt="image"></p><ul><li>虚拟机栈（<strong>线程私有</strong>）：局部变量表、操作数栈、动态链接、方法出口等信息</li><li>堆（<strong>线程共享</strong>）：实例对象</li><li>方法区（<strong>线程共享</strong>）：类信息，常量，即时编译器编译后的代码</li><li>程序计数器（<strong>线程私有</strong>）：字节码行号指示器，记录当前线程执行到多少行</li><li>本地方法栈（<strong>线程私有</strong>）：和虚拟机栈类似，两者的区别就是虚拟机栈是为虚拟机执行java方法服务，本地方法栈为虚拟机执行native方法服务 。</li></ul><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>线程计数器中如果正在执行java方法，计数器记录的是当前指令的地址，<br>如果是Native方法，计数器记录为空</p><h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>堆内存 &#x3D; 新生代(1) + 老年代(2)</p><ul><li>新生代：复制算法</li><li>老年代：标记整理算法</li></ul><h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>也叫“永久代”，1.8以后将方法区去除了，将方法区移动到直接内存</p><blockquote><p>内存回收主要考虑<strong>堆区</strong>和<strong>方法区</strong>的回收，其他部分会根据线程的产生和消亡</p></blockquote><h5 id="个版本区别"><a href="#个版本区别" class="headerlink" title="个版本区别"></a>个版本区别</h5><p><img src="https://img-blog.csdnimg.cn/20200608093848129.png" alt="image"><br><img src="https://img-blog.csdnimg.cn/20200608093926325.png" alt="image"><br><img src="https://img-blog.csdnimg.cn/20200608093956636.png" alt="image"></p><ul><li>1.6：运行常量池在方法区</li><li>1.7：运行常量池在堆中</li><li>1.8：删除方法区，引入直接内存，元空间概念，方法区中的静态变量被转移到堆中，只有class元数据在元空间。</li></ul><blockquote><p>堆中的老年代和方法区（永久代）是绑定的，无论哪一方满了，都会触发双方的GC回收</p></blockquote><h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><ol><li><p>堆和栈的区别：</p><ol><li>栈：基本数据类型变量（int、short、long、byte、float、double、boolean、char）以及对象的引用变量</li></ol><p>堆：存储java对象<br> 2. 堆中的对象对所有线程可见，栈内存只属于一个线程<br> 3. 堆的内存空间远远大于栈</p></li><li><p>为什么删除方法区？</p><ol><li>启动大小固定，很难调优，容易发生OOM</li><li>元空间在本地内存中分配，本地内存足够就不会溢出</li></ol></li></ol><h4 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h4><h5 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h5><ol><li>引用计数算法（缺点：循环引用，技数永远不为0）</li><li>可达性算法（二叉树中向下搜索，不存在引用链则对象不可用）</li></ol><h5 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h5><ol><li><p>标记清除算法：标记完后对对象进行回收，使用在<strong>老年代</strong></p><p>缺点：</p><ol><li>效率不高，标记和清除效率不高</li><li>差生大量碎片空间，导致空间浪费</li></ol></li><li><p>复制算法：将可用对象复制到新的连续空间，删除之前的空间</p><p>缺点：</p><ol><li>浪费50%的内存，复制长生存期的对象效率低下，所以该算法使用在<strong>新生代</strong></li></ol></li><li><p>标记整理算法：前期使用标记清除算法，后续使用整理算法，使对象排列称联系空间，使用在<strong>老年代</strong></p></li><li><p>分代收集算法：对数据进行分代，每一代执行不同的回收算法<br><img src="https://user-gold-cdn.xitu.io/2020/3/19/170f0726be006da5" alt="image"></p></li></ol><p>年轻代分为eden、s0、s1区，分别为8：1：1，年轻代和老年代为1：2</p><ol start="5"><li>元空间的gc：元空间中的类加载器存活，则元空间中元数据也存活</li></ol><blockquote><p>Minor GC ： 清理年轻代</p><p>Major GC ： 清理老年代</p><p>Full GC ： 清理整个堆空间，包括年轻代和永久代</p></blockquote><h4 id="四大引用介绍"><a href="#四大引用介绍" class="headerlink" title="四大引用介绍"></a>四大引用介绍</h4><h5 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h5><ul><li>强引用：Strong Reference，通常使用的对象方式，gc不会回收</li><li>软引用：SoftReference，当内存不足时进行回收</li><li>弱引用：WeakReference，下一次gc时回收</li><li>虚引用：PhantomReference，任何时候可回收</li></ul><blockquote><p>在内存泄露问题处理上，使用最多的是弱引用，许多源码、框架都是用<br>eg：</p><ol><li>ThreadLocalMap中存储以ThreadLocal的弱引用为键，具体内容为value</li><li>Glide中缓存使用activeResource，存储的是图片的弱引用</li><li>解决Handler的内存泄漏使用弱引用</li></ol></blockquote><h5 id="Reference理解"><a href="#Reference理解" class="headerlink" title="Reference理解"></a>Reference理解</h5><p>所有的引用都是继承自Reference，以下以WeakReference为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new weak reference that refers to the given object.  The new</span></span><br><span class="line"><span class="comment">     * reference is not registered with any queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referent object the new weak reference will refer to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeakReference</span><span class="params">(T referent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new weak reference that refers to the given object and is</span></span><br><span class="line"><span class="comment">     * registered with the given queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referent object the new weak reference will refer to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q the queue with which the reference is to be registered,</span></span><br><span class="line"><span class="comment">     *          or &lt;tt&gt;null&lt;/tt&gt; if registration is not required</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeakReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中存在两种构造方法，区别在于是否传入引用队列，如果不传入引用队列，说明只存在一种引用，不需要引用队列成链存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">disableIntrinsic</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">slowPathEnabled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//引用的对象，由垃圾回收器控制其引用</span></span><br><span class="line">    <span class="keyword">volatile</span> T referent;         <span class="comment">/* Treated specially by GC */</span></span><br><span class="line">    <span class="keyword">final</span> ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; queue;</span><br><span class="line">    Reference queueNext;</span><br><span class="line">    Reference&lt;?&gt; pendingNext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getReferent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FastNative</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">native</span> T <span class="title function_">getReferent</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        clearReferent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FastNative</span></span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">clearReferent</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnqueued</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Contrary to what the documentation says, this method returns false</span></span><br><span class="line">        <span class="comment">// after this reference object has been removed from its queue</span></span><br><span class="line">        <span class="comment">// (b/26647823). ReferenceQueue.isEnqueued preserves this historically</span></span><br><span class="line">        <span class="comment">// incorrect behavior.</span></span><br><span class="line">        <span class="keyword">return</span> queue != <span class="literal">null</span> &amp;&amp; queue.isEnqueued(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enqueue</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> queue != <span class="literal">null</span> &amp;&amp; queue.enqueue(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* -- Constructors -- */</span></span><br><span class="line"></span><br><span class="line">    Reference(T referent) &#123;</span><br><span class="line">        <span class="built_in">this</span>(referent, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Reference(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; queue) &#123;</span><br><span class="line">        <span class="built_in">this</span>.referent = referent;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类很简短，可以看出一个关键点，Reference是一个节点，保存next的引用，方法调用都是使用ReferenceQueue方法，直接进入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> Reference&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; head = <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">private</span> Reference&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; tail = <span class="literal">null</span>;</span><br><span class="line">   </span><br><span class="line"><span class="type">boolean</span> <span class="title function_">enqueue</span><span class="params">(Reference&lt;? extends T&gt; reference)</span> &#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">           <span class="keyword">if</span> (enqueueLocked(reference)) &#123;</span><br><span class="line">               lock.notifyAll();</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueLocked</span><span class="params">(Reference&lt;? extends T&gt; r)</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Cleaner) &#123;</span><br><span class="line">           <span class="type">Cleaner</span> <span class="variable">cl</span> <span class="operator">=</span> (sun.misc.Cleaner) r;</span><br><span class="line">           cl.clean();</span><br><span class="line">           r.queueNext = sQueueNextUnenqueued;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (tail == <span class="literal">null</span>) &#123;</span><br><span class="line">           head = r;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           tail.queueNext = r;</span><br><span class="line">       &#125;</span><br><span class="line">       tail = r;</span><br><span class="line">       tail.queueNext = r;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>入队方法中，</p><ol><li>使用synchronized添加锁，入队结束后释放锁，在ReferenceQueue中并不是标准的队列，使用的是Reference节点成链，行成单链表，类似于MessageQueue.</li><li>如果是Cleaner类，创建一个虚引用节点，即不如队。Cleaner是用来释放非堆内存，所以做特殊处理</li></ol><p>SoftReference</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//时间戳，由gc更新</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="type">long</span> clock;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SoftReference</span><span class="params">(T referent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent);</span><br><span class="line">        <span class="built_in">this</span>.timestamp = clock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new soft reference that refers to the given object and is</span></span><br><span class="line"><span class="comment">     * registered with the given queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referent object the new soft reference will refer to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q the queue with which the reference is to be registered,</span></span><br><span class="line"><span class="comment">     *          or &lt;tt&gt;null&lt;/tt&gt; if registration is not required</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SoftReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">        <span class="built_in">this</span>.timestamp = clock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">o</span> <span class="operator">=</span> <span class="built_in">super</span>.get();</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.timestamp != clock)</span><br><span class="line">            <span class="built_in">this</span>.timestamp = clock;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由gc管理时间戳</p><ul><li>clock：上一次gc时间</li><li>timestamp：访问get时最近一次的gc时间</li></ul><p>回收条件为：clock - timestamp &lt;&#x3D; free_heap * ms_per_mb</p><ul><li>free_heep为堆空间空闲大小</li><li>ms_per_mb是保留软引用时间&#x2F;MB</li></ul><p>PhantomReference</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PhantomReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚引用的get方法返回null，不做gc保留</p><blockquote><p>虚引用通过构造方法可以查看是<strong>持有对象引用</strong>的</p></blockquote><p>总结：所有引用都是继承自Reference基类的，该类是一个链表节点，ReferenceQueue通过这点形成单链表，称之为队列，进行引用管理，所有引用都可以通过Reference的isEnqueue方法判断引用是否存在。</p><h5 id="FinalizerReference理解"><a href="#FinalizerReference理解" class="headerlink" title="FinalizerReference理解"></a>FinalizerReference理解</h5><p>java堆中创建对象时，如果java类定义了finalize方法，就会新建一个FinalizerReference类，指向这个新建的对象</p><h3 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h3><ul><li>内存泄漏：内存没有按照预期在gc时回收</li><li>内存溢出：内存大小超出指定大小，导致OOM</li><li>内存抖动：短时间创建大量内存对象，然后回收，导致内存发生锯齿形抖动，内存空间不连续加上碎片会导致更大的空间，最终OOM</li></ul><h3 id="内存优化意义"><a href="#内存优化意义" class="headerlink" title="内存优化意义"></a>内存优化意义</h3><ul><li>减少OOM，提高系统稳定性</li><li>减少卡顿，提高流畅度</li><li>减少内存占用，提高应用存活率</li><li>减少异常发生和代码逻辑隐患</li></ul><h3 id="Android内存泄漏"><a href="#Android内存泄漏" class="headerlink" title="Android内存泄漏"></a>Android内存泄漏</h3><h4 id="常见内存泄漏"><a href="#常见内存泄漏" class="headerlink" title="常见内存泄漏"></a>常见内存泄漏</h4><ol><li>匿名内部类持有外部类引用，导致外部类内存泄漏（Handler）</li><li>单例传入Context导致调用单例方无法被回收。</li><li>非静态内部类创建静态实例</li><li>注册与反注册</li><li>资源对象关闭</li><li>集和及时清理</li></ol><h4 id="内存泄漏检测"><a href="#内存泄漏检测" class="headerlink" title="内存泄漏检测"></a>内存泄漏检测</h4><ol><li>Profiler,Memory Analyzer(MAT)</li></ol><p>Android studio自带内存、cpu、网络的变化，可以根据内存变化做具体分析<br>2. LeakCanary</p><p>框架集成，自动检测内存泄漏，生成app，提供内存泄漏栈堆情况</p><p>原理：绑定生命周期，对Activity和Fragment来说，在onDestory时将对象放入弱引用队列进行存储，触发gc后，如果还存在，则发生内存泄漏<br>3. StrictMode（很少用）</p><p>一款比较老的工具，ThreadPolicy可以检测主线程是否网络访问，是否读写。VMPolicy检测内存，Activity，Fragment是否泄漏，资源是否正确关闭</p><h3 id="内存优化空间"><a href="#内存优化空间" class="headerlink" title="内存优化空间"></a>内存优化空间</h3><ol><li>不必要的自动装箱</li></ol><p>自动装箱就是将基础数据类型转化为对应的复杂类型，在HashMap的增删改查中充满了自动装箱问题，所以尽量避免这中问题，如将HashMap替换为SparseArray和ArrayMap<br>2. 内存复用</p><ul><li>资源复用：通用字符串，颜色，布局</li><li>视图复用：类似于RecyclerView的优化复用</li><li>对象池：创建对象池，不用重复创建对象，类似于线程池，messae享元模式</li><li>Bitmap对象复用：使用inBitmap属性可以告知Bitmap解码器尝试使用已经存在的内存区域，新解码的bitmap会尝试使用之前那张bitmap在heap中占据的pixel data内存区域。</li></ul><ol start="3"><li><p>在App可用内存过低时主动释放内存<br>在App退到后台内存紧张即将被Kill掉时选择重写Application中 onTrimMemory&#x2F;onLowMemory 方法去释放掉图片缓存、静态缓存来自保。</p></li><li><p>其他场景优化</p><ol><li>item被回收不可见时释放掉对图片的引用<ul><li><strong>ListView</strong>：因此每次item被回收后再次利用都会重新绑定数据，只需在ImageView onDetachFromWindow的时候释放掉图片引用即可。</li><li><strong>RecyclerView</strong>：因为被回收不可见时第一选择是放进mCacheView中，这里item被复用并不会只需bindViewHolder来重新绑定数据，只有被回收进mRecyclePool中后拿出来复用才会重新绑定数据，因此重写Recycler.Adapter中的onViewRecycled()方法来使item被回收进RecyclePool的时候去释放图片引用。</li></ul></li><li>如果使用字符串拼接，尽量使用StringBuilder、StringBuffer（内存抖动）</li><li>自定义view减少onDraw的耗时和执行次数</li><li>尽量使用静态内部类</li><li>尽量使用基础数据类型</li><li>合适的时候使用软&#x2F;弱引用</li></ol></li></ol><h3 id="线上监控方案"><a href="#线上监控方案" class="headerlink" title="线上监控方案"></a>线上监控方案</h3><ol><li><p>常规监测</p><ol><li>当内存使用超过80%，使用 <strong>Debug.dumpHprofData(String fileName)</strong><br>获取dump文件回传至服务器，而后手动分析</li><li>LeakCanary集成并带到线上</li></ol></li><li><p>Probe线上监测工具</p></li><li><p>LeakInspector</p></li><li><p>ResourceCanary</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;2895&lt;/p&gt;
&lt;h2 id=&quot;为什么要做内存优化？&quot;&gt;&lt;a href=&quot;#为什么要做内存优化？&quot; class=&quot;headerlink&quot; title=&quot;为什么要做内存优化？&quot;&gt;&lt;/a&gt;为什么要做内存优化？&lt;/h2&gt;&lt;h3 id=&quot;Java虚拟机&quot;</summary>
      
    
    
    
    <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>包体积优化</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%8C%85%E4%BD%93%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%8C%85%E4%BD%93%E4%BC%98%E5%8C%96/</id>
    <published>2021-05-31T13:01:25.000Z</published>
    <updated>2023-12-19T06:50:38.179Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="优化好处"><a href="#优化好处" class="headerlink" title="优化好处"></a>优化好处</h3><ol><li>包体积减小，易于升级</li><li>多市场渠道有体积限制，避免二次处理</li><li>apk安装时间减小</li><li>运行时内存占用小</li><li>磁盘空间占用小，odex二进制文件小。</li></ol><h3 id="APK组成及分析"><a href="#APK组成及分析" class="headerlink" title="APK组成及分析"></a>APK组成及分析</h3><h4 id="APK组成"><a href="#APK组成" class="headerlink" title="APK组成"></a>APK组成</h4><ul><li>assets: 开发目录下assets目录</li><li>lib：所需要的so库</li><li>META-INF：签名文件</li><li>okhttp3：okhttp网络相关</li><li>org：org相关信息</li><li>res：布局信息，对应开发目录res下</li><li>AndroidManifest：四大组件配置</li><li>classes.dex：代码压缩文件</li></ul><h4 id="apk分析"><a href="#apk分析" class="headerlink" title="apk分析"></a>apk分析</h4><ol><li><p>使用常规apktool方法</p></li><li><p>使用jadx工具</p><p><a href="https://github.com/skylot/jadx">https://github.com/skylot/jadx</a></p><p>直接将apk拖入程序即可查看各种信息</p></li><li><p>Android Studio中的Analyze apk可以分析apk的组成</p></li></ol><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>代码全部存储在dex文件中，所以我们需要先搞懂什么是dex？</p><h5 id="dex理解"><a href="#dex理解" class="headerlink" title="dex理解"></a>dex理解</h5><p><strong>dex文件是专为Dalvik设计的一种压缩格式</strong></p><blockquote><p>.java–&gt;.class–&gt;.dex</p></blockquote><p>在.java–&gt;.class过程中，主要是jvm的操作，在.class–&gt;.dex过程中，需要将.class文件转化为Dalvik识别的.dex文件</p><p>dex主要结构如下：</p><p><img src="/imageMd/tiji-1.png" alt="image"></p><blockquote><p>同jar相比，dex文件的大小能够缩减50%左右</p></blockquote><h5 id="ProGuard代码混淆"><a href="#ProGuard代码混淆" class="headerlink" title="ProGuard代码混淆"></a>ProGuard代码混淆</h5><p>在build.gradle中开启混淆，将类名转化为没有意义的a,b,c等，提高阅读难度，其次通过缩短名称可以有效缩减dex大小，而且会移除在代码中没有使用的代码。</p><h5 id="D8与R8的优化"><a href="#D8与R8的优化" class="headerlink" title="D8与R8的优化"></a>D8与R8的优化</h5><ul><li>D8：把java字节码转化为dex代码，简单来说就是dex编译器</li><li>R8：混淆压缩与优化部分的替代品，但是不能完全替代proguard</li></ul><p>D8的提出是用来取代DX的，他的优化如下：</p><ul><li>编译时间缩短</li><li>.dex文件更小</li><li>.dex运行性能更好</li><li>包含java8语言支持</li></ul><p>R8与proguard非常相似，但不能完全替代proguard</p><ul><li>ProGuard 在将枚举类型简化为原始整数方面会更加强大</li><li>ProGuard 中应用的模式匹配算法可以识别和替换短指令序列，从而提高代码效率并为更多优化打开了机会。在优化遍历的顺序中，尤其是数学运算和字符串运算可从中受益</li><li>ProGuard 具有独特的能力来优化使用 GSON 库将对象序列化或反序列化为 JSON 的代码</li></ul><h5 id="Dex分包优化"><a href="#Dex分包优化" class="headerlink" title="Dex分包优化"></a>Dex分包优化</h5><p>当apk方法数超过65536时，必须采用分包策略，这样跨dex调用会出现一些重复信息：</p><ul><li>多余的 method id：跨 Dex 调用会导致当前dex保留被调用dex中的方法id，这种冗余会导致每一个dex中可以存放的class变少，最终又会导致编译出来的dex数量增多，而dex数据的增加又会进一步加重这个问题。</li><li>其它跨dex调用造成的信息冗余：除了需要多记录被调用的method id之外，还需多记录其所属类和当前方法的定义信息，这会造成 string_ids、type_ids、proto_ids 这几部分信息的冗余。</li></ul><p>所以使用ReDex进行分包优化，同时，去除dex文件中的debug信息及行号信息</p><h4 id="svg的使用"><a href="#svg的使用" class="headerlink" title="svg的使用"></a>svg的使用</h4><h4 id="使用指定语言，删除不必要的语言"><a href="#使用指定语言，删除不必要的语言" class="headerlink" title="使用指定语言，删除不必要的语言"></a>使用指定语言，删除不必要的语言</h4><h5 id="使用XZ-Utils进行Dex压缩"><a href="#使用XZ-Utils进行Dex压缩" class="headerlink" title="使用XZ Utils进行Dex压缩"></a>使用XZ Utils进行Dex压缩</h5><p><a href="https://tukaani.org/xz/">https://tukaani.org/xz/</a><br>将dex压缩后放在assets目录中，减少包体积，但是会提高安装时间</p><h5 id="三方库优化"><a href="#三方库优化" class="headerlink" title="三方库优化"></a>三方库优化</h5><p>在使用三方库中，小库可以完成目前业务就是用小库，减小三方库的大小，比如Picasso、Glide、Fresco的大小和功能</p><h5 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h5><p>使用Lint优化代码，移除没有使用的代码</p><h5 id="减少enum的使用"><a href="#减少enum的使用" class="headerlink" title="减少enum的使用"></a>减少enum的使用</h5><p><a href="https://www.liaohuqiu.net/cn/posts/android-enum-memory-usage/">Android 中的 Enum 到底占多少内存？该如何用？</a></p><h4 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h4><ul><li>Lint：使用lint去除冗余资源</li><li>shrinkResources：去除无用资源</li><li>重复资源优化：多模块使用同一个资源文件，去除重复资源文件，保留第一份资源</li><li>图片压缩：AAPT优化图片，选择webp格式的图片</li><li>使用针对性图片格式<ol><li>聊天表情出一套图 &#x3D;&gt; hdpi。</li><li>纯色小 icon 使用 VD &#x3D;&gt; raw。</li><li>背景大图出一套 &#x3D;&gt; xhdpi。</li><li>logo 等权重比较大的图片出两套 &#x3D;&gt; hdpi，xhdpi。</li><li>若某些图在真机中有异常，则用多套图。</li><li>若遇到奇葩机型，则针对性补图。</li></ol></li><li>资源路径混淆成单个资源的路径：使用AndroidResGuard，缩短资源路径</li><li>将资源文件放置在服务器上，通过网络加载</li></ul><h4 id="so库优化"><a href="#so库优化" class="headerlink" title="so库优化"></a>so库优化</h4><ul><li>通过abiFilters过滤so库</li><li>对于敏感的so库，不同架构全部放置在armeabi中，在程序中判断系统架构，加载不同的so库</li><li>Native Library压缩：XZ Utils，SoLoader</li><li>so库动态下载：<a href="https://mp.weixin.qq.com/s/X58fK02imnNkvUMFt23OAg">https://mp.weixin.qq.com/s/X58fK02imnNkvUMFt23OAg</a></li></ul><h4 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h4><ol><li><p>插件化</p><p>插件可以热插拔，从服务器下载</p></li><li><p>转变开发模式</p><p>使用混合式开发</p></li><li><p>梳理业务，简化逻辑和业务</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;优化好处&quot;&gt;&lt;a href=&quot;#优化好处&quot; class=&quot;headerlink&quot; title=&quot;优化好处&quot;&gt;&lt;/a&gt;优化好处&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;包体积减小，易于升级&lt;/li&gt;
&lt;li&gt;多市场渠道有体积限制，避免二次处理&lt;/li&gt;
</summary>
      
    
    
    
    <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>布局优化</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/</id>
    <published>2021-05-31T13:00:35.000Z</published>
    <updated>2023-12-19T06:50:38.179Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="绘画原理"><a href="#绘画原理" class="headerlink" title="绘画原理"></a>绘画原理</h3><p><strong>Android的绘制主要是借助cpu和gpu结合刷新机制共同完成的</strong></p><ul><li>cpu：负责执行measure、layout等方法，计算显示内容</li><li>gpu：负责栅格化（将UI元素绘制在屏幕上）<br><img src="https://user-gold-cdn.xitu.io/2020/1/14/16fa19bed0589207" alt="image"></li></ul><p>绘制过程使用skia库（2D），硬件本质是采用openGL库进行绘制</p><p>16ms内渲染一次，否则会掉帧</p><h3 id="布局加载原理"><a href="#布局加载原理" class="headerlink" title="布局加载原理"></a>布局加载原理</h3><p>Android中的布局加载入口为setContentView()，分析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> layoutResID)</span> &#123;</span><br><span class="line">       getDelegate().setContentView(layoutResID);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//AppCompatDelegate.java</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> resId)</span>;</span><br></pre></td></tr></table></figure><p>查看抽象接口实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="type">int</span> resId)</span> &#123;</span><br><span class="line">       ensureSubDecor();</span><br><span class="line">       <span class="comment">//获取content跟布局</span></span><br><span class="line">       <span class="type">ViewGroup</span> <span class="variable">contentParent</span> <span class="operator">=</span> (ViewGroup) mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">       <span class="comment">//移除所有布局</span></span><br><span class="line">       contentParent.removeAllViews();</span><br><span class="line">       <span class="comment">//加载新布局</span></span><br><span class="line">       LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">       <span class="comment">//接口状态通知</span></span><br><span class="line">       mOriginalWindowCallback.onContentChanged();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>进入inflate方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inflate(resource, root, root != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Resources</span> <span class="variable">res</span> <span class="operator">=</span> getContext().getResources();</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;INFLATING from resource: \&quot;&quot;</span> + res.getResourceName(resource) + <span class="string">&quot;\&quot; (&quot;</span></span><br><span class="line">                    + Integer.toHexString(resource) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">XmlResourceParser</span> <span class="variable">parser</span> <span class="operator">=</span> res.getLayout(resource);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            parser.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>getLayout方法返回一个XmlResourceParser对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> XmlResourceParser <span class="title function_">getLayout</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> id)</span> <span class="keyword">throws</span> NotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadXmlResourceParser(id, <span class="string">&quot;layout&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">XmlResourceParser <span class="title function_">loadXmlResourceParser</span><span class="params">(<span class="meta">@AnyRes</span> <span class="type">int</span> id, <span class="meta">@NonNull</span> String type)</span></span><br><span class="line">        <span class="keyword">throws</span> NotFoundException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">TypedValue</span> <span class="variable">value</span> <span class="operator">=</span> obtainTempTypedValue();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ResourcesImpl</span> <span class="variable">impl</span> <span class="operator">=</span> mResourcesImpl;</span><br><span class="line">        impl.getValue(id, value, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (value.type == TypedValue.TYPE_STRING) &#123;</span><br><span class="line">            <span class="keyword">return</span> impl.loadXmlResourceParser(value.string.toString(), id,</span><br><span class="line">                    value.assetCookie, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotFoundException</span>(<span class="string">&quot;Resource ID #0x&quot;</span> + Integer.toHexString(id)</span><br><span class="line">                + <span class="string">&quot; type #0x&quot;</span> + Integer.toHexString(value.type) + <span class="string">&quot; is not valid&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        releaseTempTypedValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入loadXmlResourceParser：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">   XmlResourceParser <span class="title function_">loadXmlResourceParser</span><span class="params">(<span class="meta">@NonNull</span> String file, <span class="meta">@AnyRes</span> <span class="type">int</span> id, <span class="type">int</span> assetCookie,</span></span><br><span class="line"><span class="params">           <span class="meta">@NonNull</span> String type)</span></span><br><span class="line">           <span class="keyword">throws</span> NotFoundException &#123;</span><br><span class="line">       <span class="keyword">if</span> (id != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (mCachedXmlBlocks) &#123;</span><br><span class="line">                   <span class="keyword">final</span> <span class="type">int</span>[] cachedXmlBlockCookies = mCachedXmlBlockCookies;</span><br><span class="line">                   <span class="keyword">final</span> String[] cachedXmlBlockFiles = mCachedXmlBlockFiles;</span><br><span class="line">                   <span class="keyword">final</span> XmlBlock[] cachedXmlBlocks = mCachedXmlBlocks;</span><br><span class="line">                   <span class="comment">// First see if this block is in our cache.</span></span><br><span class="line">                   <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> cachedXmlBlockFiles.length;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (cachedXmlBlockCookies[i] == assetCookie &amp;&amp; cachedXmlBlockFiles[i] != <span class="literal">null</span></span><br><span class="line">                               &amp;&amp; cachedXmlBlockFiles[i].equals(file)) &#123;</span><br><span class="line">                           <span class="keyword">return</span> cachedXmlBlocks[i].newParser();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// Not in the cache, create a new block and put it at</span></span><br><span class="line">                   <span class="comment">// the next slot in the cache.</span></span><br><span class="line">                   <span class="keyword">final</span> <span class="type">XmlBlock</span> <span class="variable">block</span> <span class="operator">=</span> mAssets.openXmlBlockAsset(assetCookie, file);</span><br><span class="line">                   <span class="keyword">if</span> (block != <span class="literal">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">final</span> <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> (mLastCachedXmlBlockIndex + <span class="number">1</span>) % num;</span><br><span class="line">                       mLastCachedXmlBlockIndex = pos;</span><br><span class="line">                       <span class="keyword">final</span> <span class="type">XmlBlock</span> <span class="variable">oldBlock</span> <span class="operator">=</span> cachedXmlBlocks[pos];</span><br><span class="line">                       <span class="keyword">if</span> (oldBlock != <span class="literal">null</span>) &#123;</span><br><span class="line">                           oldBlock.close();</span><br><span class="line">                       &#125;</span><br><span class="line">                       cachedXmlBlockCookies[pos] = assetCookie;</span><br><span class="line">                       cachedXmlBlockFiles[pos] = file;</span><br><span class="line">                       cachedXmlBlocks[pos] = block;</span><br><span class="line">                       <span class="keyword">return</span> block.newParser();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="keyword">final</span> <span class="type">NotFoundException</span> <span class="variable">rnf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotFoundException</span>(<span class="string">&quot;File &quot;</span> + file</span><br><span class="line">                       + <span class="string">&quot; from xml type &quot;</span> + type + <span class="string">&quot; resource ID #0x&quot;</span> + Integer.toHexString(id));</span><br><span class="line">               rnf.initCause(e);</span><br><span class="line">               <span class="keyword">throw</span> rnf;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotFoundException</span>(<span class="string">&quot;File &quot;</span> + file + <span class="string">&quot; from xml type &quot;</span> + type + <span class="string">&quot; resource ID #0x&quot;</span></span><br><span class="line">               + Integer.toHexString(id));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>加载指定布局文件的xml，生成XMLBlock：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="keyword">final</span> XmlBlock <span class="title function_">openXmlBlockAsset</span><span class="params">(<span class="type">int</span> cookie, String fileName)</span></span><br><span class="line">       <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!mOpen) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Assetmanager has been closed&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">long</span> <span class="variable">xmlBlock</span> <span class="operator">=</span> openXmlAssetNative(cookie, fileName);</span><br><span class="line">           <span class="keyword">if</span> (xmlBlock != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="type">XmlBlock</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBlock</span>(<span class="built_in">this</span>, xmlBlock);</span><br><span class="line">               incRefsLocked(res.hashCode());</span><br><span class="line">               <span class="keyword">return</span> res;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(<span class="string">&quot;Asset XML file: &quot;</span> + fileName);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">openXmlAssetNative</span><span class="params">(<span class="type">int</span> cookie, String fileName)</span>;</span><br></pre></td></tr></table></figure><p>最终指向了native方法</p><p>获取到XMLResourceParser后，进行渲染：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(XmlPullParser parser, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;inflate&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">inflaterContext</span> <span class="operator">=</span> mContext;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AttributeSet</span> <span class="variable">attrs</span> <span class="operator">=</span> Xml.asAttributeSet(parser);</span><br><span class="line">        <span class="type">Context</span> <span class="variable">lastContext</span> <span class="operator">=</span> (Context) mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">        mConstructorArgs[<span class="number">0</span>] = inflaterContext;</span><br><span class="line">        <span class="type">View</span> <span class="variable">result</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Look for the root node.</span></span><br><span class="line">            <span class="type">int</span> type;</span><br><span class="line">            <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                <span class="comment">// Empty</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(parser.getPositionDescription()</span><br><span class="line">                        + <span class="string">&quot;: No start tag found!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parser.getName();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Creating root view: &quot;</span></span><br><span class="line">                        + name);</span><br><span class="line">                System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是merge标签，查看是否是当前布局的父节点，不是的话抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(<span class="string">&quot;&lt;merge /&gt; can be used only with a valid &quot;</span></span><br><span class="line">                            + <span class="string">&quot;ViewGroup root and attachToRoot=true&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Temp is the root view that was found in the xml</span></span><br><span class="line">                <span class="comment">//获取xml中的根节点</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">temp</span> <span class="operator">=</span> createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用XmlPull解析布局，如果是merge标签，merge节点不是当前布局的父节点，则抛出异常，进入CreateViewFromTag：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> View <span class="title function_">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> createViewFromTag(parent, name, context, attrs, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  View <span class="title function_">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs,</span></span><br><span class="line"><span class="params">          <span class="type">boolean</span> ignoreThemeAttr)</span> &#123;</span><br><span class="line">      </span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          View view;</span><br><span class="line">          <span class="keyword">if</span> (mFactory2 != <span class="literal">null</span>) &#123;</span><br><span class="line">              view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">              view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              view = <span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (view == <span class="literal">null</span> &amp;&amp; mPrivateFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">              view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lastContext</span> <span class="operator">=</span> mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">              mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                      view = onCreateView(parent, name, attrs);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      view = createView(name, <span class="literal">null</span>, attrs);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>使用mFactory2、mFactory、mPrivateFactory创建view，如果null的情况下，就会调用createView方法，内部采用反射创建节点，过多的反射会造成性能问题，可以进行优化。</p><h3 id="获取界面布局耗时"><a href="#获取界面布局耗时" class="headerlink" title="获取界面布局耗时"></a>获取界面布局耗时</h3><ol><li>手动埋点，打印时间</li><li>AOP打印setContView的时间</li><li>重写LayoutInflaterCompat.setFactory2方法，打印每一个控件的耗时时间<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用LayoutInflaterCompat.Factory2全局监控Activity界面每一个控件的加载耗时，</span></span><br><span class="line">    <span class="comment">// 也可以做全局的自定义控件替换处理，比如：将TextView全局替换为自定义的TextView。</span></span><br><span class="line">    LayoutInflaterCompat.setFactory2(getLayoutInflater(), <span class="keyword">new</span> <span class="title class_">LayoutInflater</span>.Factory2() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (TextUtils.equals(name, <span class="string">&quot;TextView&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 生成自定义TextView</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> getDelegate().createView(parent, name, context, attrs);</span><br><span class="line">            LogHelper.i(name + <span class="string">&quot; cost &quot;</span> + (System.currentTimeMillis() - time));</span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//也可以直接调用这个方法</span></span><br><span class="line"><span class="comment">//    LayoutInflater.from(this).setFactory2(new LayoutInflater.Factory2() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                if (TextUtils.equals(name, &quot;TextView&quot;)) &#123;</span></span><br><span class="line"><span class="comment">//                    // 生成自定义TextView</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                long time = System.currentTimeMillis();</span></span><br><span class="line"><span class="comment">//                // 1</span></span><br><span class="line"><span class="comment">//                View view = getDelegate().createView(parent, name, context, attrs);</span></span><br><span class="line"><span class="comment">//                AppLog.E(name + &quot; cost &quot; + (System.currentTimeMillis() - time));</span></span><br><span class="line"><span class="comment">//                return view;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public View onCreateView(String name, Context context, AttributeSet attrs) &#123;</span></span><br><span class="line"><span class="comment">//               return null;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、setFactory2方法需在super.onCreate方法前调用，否则无效  </span></span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(getLayoutId());</span><br><span class="line">    unBinder = ButterKnife.bind(<span class="built_in">this</span>);</span><br><span class="line">    mActivity = <span class="built_in">this</span>;</span><br><span class="line">    ActivityCollector.getInstance().addActivity(<span class="built_in">this</span>);</span><br><span class="line">    onViewCreated();</span><br><span class="line">    initToolbar();</span><br><span class="line">    initEventAndData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="优化工具"><a href="#优化工具" class="headerlink" title="优化工具"></a>优化工具</h3><h4 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h4><p>Android Studio自带工具，可以进行代码校验，发现代码结构&#x2F;质量问题</p><h4 id="Layout-Inspector"><a href="#Layout-Inspector" class="headerlink" title="Layout Inspector"></a>Layout Inspector</h4><p>Android Studio推荐布局检测工具，可以查看整个布局的层级，进而优化处理</p><h4 id="GPU过度绘制"><a href="#GPU过度绘制" class="headerlink" title="GPU过度绘制"></a>GPU过度绘制</h4><p>手机中打开开发者选项-开启GPU过度绘制</p><h3 id="布局优化的必要性"><a href="#布局优化的必要性" class="headerlink" title="布局优化的必要性"></a>布局优化的必要性</h3><ol><li>减少页面卡顿，提高流畅度</li><li>减少线上bug产出</li></ol><h3 id="总体原则"><a href="#总体原则" class="headerlink" title="总体原则"></a>总体原则</h3><ol><li>避免层间嵌套</li><li>减少绘制时间，三个方法的执行时间</li></ol><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><ol><li><p>使用include标签重用公共布局</p></li><li><p>使用merge减少视图层级</p><p>当使用的是merge时，连续两个布局相似会合并，减少层级。</p></li><li><p>使用viewStub延迟加载，减少资源浪费</p></li><li><p>简单布局使用LinearLayout，复杂布局使用RelativeLayout或者ConstraintLayout减少层级嵌套。</p></li><li><p>善用控件属性</p><ul><li>TextView实现图片+文字显示</li><li>使用LinearLayout自带的分割线</li></ul></li><li><p>使用space控件</p></li><li><p>尽量少使用wrap_content，增加计算成本，绘制过久</p></li></ol><h3 id="主要布局比较"><a href="#主要布局比较" class="headerlink" title="主要布局比较"></a>主要布局比较</h3><table><thead><tr><th>名称</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>RelativeLayout</td><td>减少层级嵌套</td><td>onDraw执行两次，耗时</td></tr><tr><td>LinearLayout</td><td>不使用weight，onDraw执行一次</td><td>布局时容易层级嵌套</td></tr><tr><td>FrameLayout</td><td></td><td></td></tr><tr><td>ConstraintLayout</td><td>减少层级 + 比例布局</td><td>耗时</td></tr></tbody></table><p>总结：性能好的布局，FrameLayout和LinearLayout<br>功能复杂，需要层级嵌套使用RelativeLayout或者ConstraintLayout。</p><blockquote><p>优先考虑层级问题，在考虑单个布局性能问题</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;绘画原理&quot;&gt;&lt;a href=&quot;#绘画原理&quot; class=&quot;headerlink&quot; title=&quot;绘画原理&quot;&gt;&lt;/a&gt;绘画原理&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Android的绘制主要是借助cpu和gpu结合刷新机制共同完成的&lt;/strong</summary>
      
    
    
    
    <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-05-31T12:59:26.000Z</published>
    <updated>2023-12-19T06:50:38.180Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>确保某个类中只有一个实例，而且子性实例化并向整个系统提供整个实例</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="饿汉："><a href="#饿汉：" class="headerlink" title="饿汉："></a>饿汉：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//在静态初始化器中创建单例实例，这段代码保证了线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">//Singleton类只有一个构造方法并且是被private修饰的，所以用户无法通过new方法创建该对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="懒汉："><a href="#懒汉：" class="headerlink" title="懒汉："></a>懒汉：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//没有加入synchronized关键字的版本是线程不安全的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span>  Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断当前单例是否已经存在，若存在则返回，不存在则再建立单例</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="双重校验锁（DCL）："><a href="#双重校验锁（DCL）：" class="headerlink" title="双重校验锁（DCL）："></a>双重校验锁（DCL）：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>双重判断的原因？<ul><li>第一个判断减少锁的使用，提升性能</li><li>多个线程同时等待锁，当第一个创建后，就不需要其他线程重复重建</li></ul></li><li>volatile的理解<ul><li>禁止重排序导致instance获取失败。<ul><li>给Singleton的实例分配内存</li><li>调用构造函数，初始化成员</li><li>将instance对象指向分配的内存空间<blockquote><p>执行顺序有可能是1-2-3，1-3-2</p></blockquote></li></ul></li></ul></li></ol><p>如果是1-3-2，new Singleton()方法执行时可能导致分配了空间，并指向了内存空间，但是没有赋值，这样另一个线程拿到后会导致出错</p><p>缺点：部分情况下，这种单例模式会失效</p><h5 id="静态内部类："><a href="#静态内部类：" class="headerlink" title="静态内部类："></a>静态内部类：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首次加载Singleton不会初始化instance，当调用getInstance方法时，初始化SingletonHolder类，这样虚拟机加载该类是线程安全的，保证单例对象的唯一性</p><h5 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SingletonEnum</span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在反序列化时，会重新创建对象，不符合单例</p></blockquote><h5 id="容器单例"><a href="#容器单例" class="headerlink" title="容器单例"></a>容器单例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonManager</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; objMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonManager</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerService</span><span class="params">(String key,Object instance)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!objMap.containsKey(key))&#123;</span><br><span class="line">            objMap.put(key,instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getValue</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objMap.get(Key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对单例内容统一管理，放置在map中，但是HashMap线程不安全，所以最好使用ConcurrentHashMap，管理多个单例类</p><h4 id="源码应用"><a href="#源码应用" class="headerlink" title="源码应用"></a>源码应用</h4><ol><li>LayoutInflater.from(context)</li></ol><ul><li>进入main函数</li><li>新建ActivityThread，调用attach函数</li><li>AMS通信最终调用ahndlelauncherActivity</li><li>创建Activity</li><li>创建Application</li><li>获取Context对象</li><li>将context对象attach到activity中</li><li>调用Activity的onCreate方法</li></ul><p>在虚拟机第一次加载ContextImpl时会注册LayoutInflater Service，将这些服务存储在HashMap中，下次直接从缓存中读取，应用的是容器单例形式。</p><ol start="2"><li>深入LayoutInflater<br>LayoutInflater是抽象类，具体实现类是<strong>PhoneLayoutInflater</strong></li></ol><p>inflate方法：</p><ul><li>解析xml根标签（父布局）</li><li>判断merge，如果是merge直接将子布局添加到根布局</li><li>如果是普通标签，调用createViewFromTag对该元素进行解析</li><li>解析所有子view，将这些子view都添加到根布局temp下</li><li>返回解析到根视图</li></ul><p>q：为什么自定义view要使用全包名，而内置view（TextView）就不用?</p><p>a：因为在布局加载过程中，如果是内置view，直接执行onCreateView方法创建view，并将“android.widget.”加在内置view前（android.widget.TextView），然后执行createView方法。如果是自定义view，从xml中获取全量包名直接执行createView方法即可，默认前缀为null</p><blockquote><p>inflate通过<strong>深度优先</strong>遍历来构造视图树</p></blockquote><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ol><li>减少内存开支，避免创建和销毁的性能损耗</li><li>减少性能开销，永久驻留内存方式初始化复杂对象和依赖</li><li>避免对同一资源的多重占用，例如-个写文件操作，只有一个实例可以写，避免对这一个资源文件的同时写操作（避免线程不安全）</li><li>设置全局访问点，优化和共享资源访问，便于管理</li></ol><p>缺点：</p><ol><li>拓展困难，只能修改代码</li><li>如果持有context对象，会造成内存泄漏</li></ol><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>将一个复杂对象的构建与他的表示分离，是的同样的构建过程可以创建不同的表示</p><blockquote><p>核心思想是添加建造者构建主类，减少主类功能，建造者只负责构建主类</p></blockquote><h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="comment">//显示器</span></span><br><span class="line">    String display;</span><br><span class="line">    <span class="comment">//cpu型号</span></span><br><span class="line">    String cpu;</span><br><span class="line">    <span class="comment">//主板型号</span></span><br><span class="line">    String mainBoard;</span><br><span class="line">    <span class="comment">//显卡型号</span></span><br><span class="line">    String gpu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.display = builder.display;</span><br><span class="line">        <span class="built_in">this</span>.cpu = builder.cpu;</span><br><span class="line">        <span class="built_in">this</span>.mainBoard = builder.mainBoard;</span><br><span class="line">        <span class="built_in">this</span>.gpu = builder.gpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;显示器是&quot;</span> + display + <span class="string">&quot;\ncpu是&quot;</span> + cpu + <span class="string">&quot;\n主板是&quot;</span> + mainBoard + <span class="string">&quot;\n显卡是&quot;</span> + gpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">        <span class="comment">//显示器</span></span><br><span class="line">        String display;</span><br><span class="line">        <span class="comment">//cpu型号</span></span><br><span class="line">        String cpu;</span><br><span class="line">        <span class="comment">//主板型号</span></span><br><span class="line">        String mainBoard;</span><br><span class="line">        <span class="comment">//显卡型号</span></span><br><span class="line">        String gpu;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.display = <span class="string">&quot;三星曲屏&quot;</span>;</span><br><span class="line">            <span class="built_in">this</span>.cpu = <span class="string">&quot;i5 8400&quot;</span>;</span><br><span class="line">            <span class="built_in">this</span>.mainBoard = <span class="string">&quot;华硕Z360-B&quot;</span>;</span><br><span class="line">            <span class="built_in">this</span>.gpu = <span class="string">&quot;GTX 1050Ti&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setDisplay</span><span class="params">(String display)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.display = display;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setcpu</span><span class="params">(String cpu)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setMainBoard</span><span class="params">(String mainBoard)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.mainBoard = mainBoard;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setGpu</span><span class="params">(String gpu)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.gpu = gpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Computer <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>.Builder()</span><br><span class="line">                .setcpu(<span class="string">&quot;i9 4700u&quot;</span>)</span><br><span class="line">                .setGpu(<span class="string">&quot;GTX 2060Ti&quot;</span>)</span><br><span class="line">                .setMainBoard(<span class="string">&quot;华硕Z480&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(computer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="源码应用-1"><a href="#源码应用-1" class="headerlink" title="源码应用"></a>源码应用</h4><ol><li><p>AlertDialog<br>内部调用Buidler模式构建，最终通过WindowManager显示在手机屏幕上。</p></li><li><p>WindowManager源码分析<br>所有需要显示到屏幕上的内容都是通过WindowManager来操作的，WM的一个非常重要的子系统为WMS（WindowManagerService）<br>在android.app.SystemServiceRegistry中：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registerService(Context.WINDOW_SERVICE, WindowManager.class,</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">CachedServiceFetcher</span>&lt;WindowManager&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> WindowManager <span class="title function_">createService</span><span class="params">(ContextImpl ctx)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowManagerImpl</span>(ctx);</span><br><span class="line">           &#125;&#125;);</span><br></pre></td></tr></table></figure><p>WMS也是初始化的众多服务的一种，所以在ContentImpl中初始化,并将初始化的服务注册到一个map中，需要时通过键获取调用，属于单例模式的容器单例。</p><p>以PopupWindow为例，我们获取到popupWindow的初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br></pre></td></tr></table></figure><p>通过以上方法获取WM，显示时使用showAtLocation()方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAtLocation</span><span class="params">(IBinder token, <span class="type">int</span> gravity, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">   ......</span><br><span class="line">    invokePopup(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokePopup</span><span class="params">(WindowManager.LayoutParams p)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    mWindowManager.addView(decorView, p);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过一系列的调用，最终使用WM的addView方法添加布局，回溯之前的分析WM的实例是WindowManagerImpl，进入addView方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> &#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在WMImpl方法中调用WMGlobal.addView方法，进入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span><br><span class="line"><span class="params">           Display display, Window parentWindow)</span> &#123;</span><br><span class="line">       ......</span><br><span class="line">       </span><br><span class="line">       ViewRootImpl root;</span><br><span class="line">       <span class="type">View</span> <span class="variable">panelParentView</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">       <span class="comment">//构建ViewRootImpl</span></span><br><span class="line">       root = <span class="keyword">new</span> <span class="title class_">ViewRootImpl</span>(view.getContext(), display);</span><br><span class="line">       <span class="comment">//view设置参数</span></span><br><span class="line">       view.setLayoutParams(wparams);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//将view添加到列表</span></span><br><span class="line">       mViews.add(view);</span><br><span class="line">       <span class="comment">//将ViewRootImpl添加到列表</span></span><br><span class="line">       mRoots.add(root);</span><br><span class="line">       <span class="comment">//将参数添加在列表</span></span><br><span class="line">       mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// do this last because it fires off messages to start doingthings</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//调用viewRootImpl的setView方法添加布局</span></span><br><span class="line">           root.setView(view, wparams, panelParentView);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">           <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">           <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               removeViewLocked(index, <span class="literal">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>构建ViewRootImpl</li><li>将布局参数设置给view</li><li>存储ViewRootImpl、View、LayoutParam到列表</li><li>调用ViewRootImpl.setView将view显示在窗口</li></ul><p>进一步查看ViewRootImpl是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ViewRootImpl</span><span class="params">(Context context, Display display)</span> &#123;</span><br><span class="line">      mContext = context;</span><br><span class="line">      <span class="comment">//获取WindowSession，也就是和WMS建立连接</span></span><br><span class="line">      mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">      ......</span><br><span class="line">      <span class="comment">//创建线程为当前线程，因为主界面在UI线程，所以在子线程更新UI会抛出异常，但并不是只用UI线程才能更新UI</span></span><br><span class="line">      mThread = Thread.currentThread();</span><br><span class="line">      ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>进入WMGlobal.getWindowSession方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title function_">getWindowSession</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowSession == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">InputMethodManager</span> <span class="variable">imm</span> <span class="operator">=</span> InputMethodManager.getInstance();</span><br><span class="line">                <span class="comment">//获取WMS</span></span><br><span class="line">                <span class="type">IWindowManager</span> <span class="variable">windowManager</span> <span class="operator">=</span> getWindowManagerService();</span><br><span class="line">                <span class="comment">//建立一个WindowSession</span></span><br><span class="line">                sWindowSession = windowManager.openSession(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">IWindowSessionCallback</span>.Stub() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAnimatorScaleChanged</span><span class="params">(<span class="type">float</span> scale)</span> &#123;</span><br><span class="line">                                ValueAnimator.setDurationScale(scale);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        imm.getClient(), imm.getInputContext());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入getWindowManagerService，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IWindowManager <span class="title function_">getWindowManagerService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowManagerService == <span class="literal">null</span>) &#123;</span><br><span class="line">            sWindowManagerService = IWindowManager.Stub.asInterface(</span><br><span class="line">                    ServiceManager.getService(<span class="string">&quot;window&quot;</span>));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sWindowManagerService != <span class="literal">null</span>) &#123;</span><br><span class="line">                    ValueAnimator.setDurationScale(</span><br><span class="line">                            sWindowManagerService.getCurrentAnimatorScale());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowManagerService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过ServiceManager.getService()获取WMS，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IBinder <span class="title function_">getService</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">service</span> <span class="operator">=</span> sCache.get(name);</span><br><span class="line">        <span class="keyword">if</span> (service != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> service;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Binder.allowBlocking(getIServiceManager().getService(name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;error in getService&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过sCache获取到一个IBinder对象，所以FrameWork与WMS之间也是通过Binder机制进行通信的，回溯到之前，会调用IWindowManager.Stub.asInterface()，将IBinder对象转化为WM对象，然后通过openSession与WMS建立通信绘画，之后通过这个session进行交换信息，但是到现在还是没有显示view，所以继续走ViewRootImpl.setView方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="literal">null</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//请求布局</span></span><br><span class="line">            requestLayout();</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//通过Windowsession和WMS通信，请求显示</span></span><br><span class="line">                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                        mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">            &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>requestlayout：请求布局</li><li>向WMS请求显示布局</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestLayout</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        <span class="comment">//线程校验</span></span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="literal">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//开启屏障消息，优先处理</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">//通过handler回调执行MTraversalRunnable</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过handler回调执行MTraversalRunnable，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="literal">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.startMethodTracing(<span class="string">&quot;ViewAncestor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//view的具体操作</span></span><br><span class="line">        performTraversals();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.stopMethodTracing();</span><br><span class="line">            mProfile = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终进入performTraversals进行具体操作</p><ol><li>获取Surface对象，用于图形绘制</li><li>performMeasure函数，测量整个视图树各个view的大小</li><li>performLayout,布局整个view</li><li>performDraw，绘制整个view</li></ol><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>良好的封装性，使客户端不知道产品内部组成细节</li><li>独立，容易拓展</li></ul><p>缺点：</p><ul><li>产生多余Builder对象和Director对象，消耗内存</li></ul><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象</p><h4 id="简单例子-1"><a href="#简单例子-1" class="headerlink" title="简单例子"></a>简单例子</h4><h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p>原型模式实际上是浅拷贝，也称为影子拷贝。拷贝实际不是将所有字段重新构造一份，而是拷贝文档的字段引用原始文档的字段而已，所以会导致修改副本的字段，原始字段也会跟着修改，因为最终修改的是同一个内存单元，所以在原型模式中，要尽量使用深拷贝。</p><ul><li>深拷贝：复制引用对象的值</li><li>浅拷贝：复制引用</li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ol><li><p>ArrayList的clone方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//克隆自身</span></span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">//克隆数组对象</span></span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>克隆自身后，在克隆数组对象，并没有对size进行克隆是因为size是值类型，并不是引用类型。</p></li><li><p>Intent的clone方法分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Intent</span><span class="params">(Intent o)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(o, COPY_MODE_ALL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Intent</span><span class="params">(Intent o, <span class="meta">@CopyMode</span> <span class="type">int</span> copyMode)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mAction = o.mAction;</span><br><span class="line">    <span class="built_in">this</span>.mData = o.mData;</span><br><span class="line">    <span class="built_in">this</span>.mType = o.mType;</span><br><span class="line">    <span class="built_in">this</span>.mPackage = o.mPackage;</span><br><span class="line">    <span class="built_in">this</span>.mComponent = o.mComponent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o.mCategories != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.mCategories = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;(o.mCategories);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copyMode != COPY_MODE_FILTER) &#123;</span><br><span class="line">        <span class="built_in">this</span>.mFlags = o.mFlags;</span><br><span class="line">        <span class="built_in">this</span>.mContentUserHint = o.mContentUserHint;</span><br><span class="line">        <span class="built_in">this</span>.mLaunchToken = o.mLaunchToken;</span><br><span class="line">        <span class="keyword">if</span> (o.mSourceBounds != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.mSourceBounds = <span class="keyword">new</span> <span class="title class_">Rect</span>(o.mSourceBounds);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o.mSelector != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.mSelector = <span class="keyword">new</span> <span class="title class_">Intent</span>(o.mSelector);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copyMode != COPY_MODE_HISTORY) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.mExtras != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.mExtras = <span class="keyword">new</span> <span class="title class_">Bundle</span>(o.mExtras);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o.mClipData != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.mClipData = <span class="keyword">new</span> <span class="title class_">ClipData</span>(o.mClipData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.mExtras != <span class="literal">null</span> &amp;&amp; !o.mExtras.maybeIsEmpty()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.mExtras = Bundle.STRIPPED;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Also set &quot;stripped&quot; clip data when we ever log mClipData in the (broadcast)</span></span><br><span class="line">            <span class="comment">// history.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在Intent的clone方法中直接使用new方法构建了新intent</p><p>所以延伸出一个问题，new和clone怎么选择？</p><p>如果对象的构造成本太高或者构造比较麻烦，那么使用clone函数效率高，否则使用new</p><ol start="3"><li>intent的查找和匹配</li></ol><p>intent是怎么查找对应的组件然后跳转的呢？</p><p>在ContextImpl初始化的SystemServiceRegistry中初始化各种服务（WMS,AMS等），其中，初始化了PMS（PackageManagerService）</p><p>在ContextImpl中执行getPackageManager方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PackageManager <span class="title function_">getPackageManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageManager != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">IPackageManager</span> <span class="variable">pm</span> <span class="operator">=</span> ActivityThread.getPackageManager();</span><br><span class="line">    <span class="keyword">if</span> (pm != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Doesn&#x27;t matter if we make more than one instance.</span></span><br><span class="line">        <span class="keyword">return</span> (mPackageManager = <span class="keyword">new</span> <span class="title class_">ApplicationPackageManager</span>(<span class="built_in">this</span>, pm));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入ActivityThread.getPackageManager()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IPackageManager <span class="title function_">getPackageManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sPackageManager != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//Slog.v(&quot;PackageManager&quot;, &quot;returning cur default = &quot; + sPackageManager);</span></span><br><span class="line">        <span class="keyword">return</span> sPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取PackageManagerService</span></span><br><span class="line">    <span class="type">IBinder</span> <span class="variable">b</span> <span class="operator">=</span> ServiceManager.getService(<span class="string">&quot;package&quot;</span>);</span><br><span class="line">    <span class="comment">//Slog.v(&quot;PackageManager&quot;, &quot;default service binder = &quot; + b);</span></span><br><span class="line">    sPackageManager = IPackageManager.Stub.asInterface(b);</span><br><span class="line">    <span class="comment">//Slog.v(&quot;PackageManager&quot;, &quot;default service = &quot; + sPackageManager);</span></span><br><span class="line">    <span class="keyword">return</span> sPackageManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到PackageManagerService服务，这个服务是在系统初始化时通过SystemServer启动的，现在只是获取，查看PackageManagerService类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PMS为IPackageManager.Stub的具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageManagerService</span> <span class="keyword">extends</span> <span class="title class_">IPackageManager</span>.Stub</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">PackageSender</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">PackageManagerService</span><span class="params">(Context context, Installer installer,<span class="type">boolean</span> factoryTest, <span class="type">boolean</span> onlyCore)</span> &#123;</span><br><span class="line">        <span class="comment">// Collect privileged system packages.</span></span><br><span class="line">        <span class="comment">// 扫描特殊系统包</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">File</span> <span class="variable">privilegedAppDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(Environment.getRootDirectory(), <span class="string">&quot;priv-app&quot;</span>);</span><br><span class="line">        scanDirTracedLI(privilegedAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM</span><br><span class="line">                | SCAN_AS_PRIVILEGED,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collect ordinary system packages.</span></span><br><span class="line">        <span class="comment">// 扫描普通系统包</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">File</span> <span class="variable">systemAppDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(Environment.getRootDirectory(), <span class="string">&quot;app&quot;</span>);</span><br><span class="line">        scanDirTracedLI(systemAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collect privileged vendor packages.</span></span><br><span class="line">        <span class="comment">// 扫描特殊vendor下包</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">privilegedVendorAppDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(Environment.getVendorDirectory(), <span class="string">&quot;priv-app&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            privilegedVendorAppDir = privilegedVendorAppDir.getCanonicalFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// failed to look up canonical path, continue with original one</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanDirTracedLI(privilegedVendorAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM</span><br><span class="line">                | SCAN_AS_VENDOR</span><br><span class="line">                | SCAN_AS_PRIVILEGED,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collect ordinary vendor packages.</span></span><br><span class="line">        <span class="comment">// 扫描普通vendor下包</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">vendorAppDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(Environment.getVendorDirectory(), <span class="string">&quot;app&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            vendorAppDir = vendorAppDir.getCanonicalFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// failed to look up canonical path, continue with original one</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanDirTracedLI(vendorAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM</span><br><span class="line">                | SCAN_AS_VENDOR,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collect privileged odm packages. /odm is another vendor partition</span></span><br><span class="line">        <span class="comment">// other than /vendor.</span></span><br><span class="line">        <span class="comment">// 扫描特殊odm下包/odm时vendor的一部分</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">privilegedOdmAppDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(Environment.getOdmDirectory(),</span><br><span class="line">                    <span class="string">&quot;priv-app&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            privilegedOdmAppDir = privilegedOdmAppDir.getCanonicalFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// failed to look up canonical path, continue with original one</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanDirTracedLI(privilegedOdmAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM</span><br><span class="line">                | SCAN_AS_VENDOR</span><br><span class="line">                | SCAN_AS_PRIVILEGED,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collect ordinary odm packages. /odm is another vendor partition</span></span><br><span class="line">        <span class="comment">// other than /vendor.</span></span><br><span class="line">        <span class="comment">// 扫描普通odm下包/odm时vendor的一部分</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">odmAppDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(Environment.getOdmDirectory(), <span class="string">&quot;app&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            odmAppDir = odmAppDir.getCanonicalFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// failed to look up canonical path, continue with original one</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanDirTracedLI(odmAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM</span><br><span class="line">                | SCAN_AS_VENDOR,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collect all OEM packages.</span></span><br><span class="line">        <span class="comment">// 扫描所有OEM包</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">File</span> <span class="variable">oemAppDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(Environment.getOemDirectory(), <span class="string">&quot;app&quot;</span>);</span><br><span class="line">        scanDirTracedLI(oemAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM</span><br><span class="line">                | SCAN_AS_OEM,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collected privileged product packages.</span></span><br><span class="line">        <span class="comment">// 扫描特殊product包</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">privilegedProductAppDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(Environment.getProductDirectory(), <span class="string">&quot;priv-app&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            privilegedProductAppDir = privilegedProductAppDir.getCanonicalFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// failed to look up canonical path, continue with original one</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanDirTracedLI(privilegedProductAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM</span><br><span class="line">                | SCAN_AS_PRODUCT</span><br><span class="line">                | SCAN_AS_PRIVILEGED,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collect ordinary product packages.</span></span><br><span class="line">         <span class="comment">// 扫描普通product包</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">productAppDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(Environment.getProductDirectory(), <span class="string">&quot;app&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            productAppDir = productAppDir.getCanonicalFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// failed to look up canonical path, continue with original one</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanDirTracedLI(productAppDir,</span><br><span class="line">                mDefParseFlags</span><br><span class="line">                | PackageParser.PARSE_IS_SYSTEM_DIR,</span><br><span class="line">                scanFlags</span><br><span class="line">                | SCAN_AS_SYSTEM</span><br><span class="line">                | SCAN_AS_PRODUCT,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PMS会加载一系列，在不同目录下的包执行scanDirTracedLI方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scanDirTracedLI</span><span class="params">(File dir, <span class="keyword">final</span> <span class="type">int</span> parseFlags, <span class="type">int</span> scanFlags, <span class="type">long</span> currentTime)</span> &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;scanDir [&quot;</span> + dir.getAbsolutePath() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        scanDirLI(dir, parseFlags, scanFlags, currentTime);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scanDirLI</span><span class="params">(File dir, <span class="type">int</span> parseFlags, <span class="type">int</span> scanFlags, <span class="type">long</span> currentTime)</span> &#123;</span><br><span class="line">    <span class="comment">//获取目录下所有文件</span></span><br><span class="line">    <span class="keyword">final</span> File[] files = dir.listFiles();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isPackage</span> <span class="operator">=</span> (isApkFile(file) || file.isDirectory())</span><br><span class="line">                &amp;&amp; !PackageInstallerService.isStageName(file.getName());</span><br><span class="line">        <span class="keyword">if</span> (!isPackage) &#123;</span><br><span class="line">            <span class="comment">// Ignore entries which are not packages</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parallelPackageParser.submit(file, parseFlags);</span><br><span class="line">        fileCount++;</span><br><span class="line">    &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">for</span> (; fileCount &gt; <span class="number">0</span>; fileCount--) &#123;</span><br><span class="line">            scanPackageLI(parseResult.pkg, parseResult.scanFile, parseFlags, scanFlags,</span><br><span class="line">                            currentTime, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扫描目录下的子目录，对apk文件进行解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(File scanFile, <span class="type">int</span> parseFlags)</span> &#123;</span><br><span class="line">       mService.submit(() -&gt; &#123;</span><br><span class="line">           <span class="type">ParseResult</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParseResult</span>();</span><br><span class="line">           Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;parallel parsePackage [&quot;</span> + scanFile + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//创建一个包解析器</span></span><br><span class="line">               <span class="type">PackageParser</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageParser</span>();</span><br><span class="line">               pp.setSeparateProcesses(mSeparateProcesses);</span><br><span class="line">               pp.setOnlyCoreApps(mOnlyCore);</span><br><span class="line">               pp.setDisplayMetrics(mMetrics);</span><br><span class="line">               pp.setCacheDir(mCacheDir);</span><br><span class="line">               pp.setCallback(mPackageParserCallback);</span><br><span class="line">               pr.scanFile = scanFile;</span><br><span class="line">               <span class="comment">//执行apk包解析</span></span><br><span class="line">               pr.pkg = parsePackage(pp, scanFile, parseFlags);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">               pr.throwable = e;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               mQueue.put(pr);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               Thread.currentThread().interrupt();</span><br><span class="line">               <span class="comment">// Propagate result to callers of take().</span></span><br><span class="line">               <span class="comment">// This is helpful to prevent main thread from getting stuck waiting on</span></span><br><span class="line">               <span class="comment">// ParallelPackageParser to finish in case of interruption</span></span><br><span class="line">               mInterruptedInThread = Thread.currentThread().getName();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@VisibleForTesting</span></span><br><span class="line">   <span class="keyword">protected</span> PackageParser.Package <span class="title function_">parsePackage</span><span class="params">(PackageParser packageParser, File scanFile,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> parseFlags)</span> <span class="keyword">throws</span> PackageParser.PackageParserException &#123;</span><br><span class="line">       <span class="keyword">return</span> packageParser.parsePackage(scanFile, parseFlags, <span class="literal">true</span> <span class="comment">/* useCaches */</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>创建一个PackageParser，调用parsePackage函数解析apk</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Package <span class="title function_">parsePackage</span><span class="params">(File packageFile, <span class="type">int</span> flags, <span class="type">boolean</span> useCaches)</span></span><br><span class="line">        <span class="keyword">throws</span> PackageParserException &#123;</span><br><span class="line">    <span class="type">Package</span> <span class="variable">parsed</span> <span class="operator">=</span> useCaches ? getCachedResult(packageFile, flags) : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (parsed != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> parsed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是文件夹类型</span></span><br><span class="line">    <span class="keyword">if</span> (packageFile.isDirectory()) &#123;</span><br><span class="line">        parsed = parseClusterPackage(packageFile, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//解析单个apk</span></span><br><span class="line">        parsed = parseMonolithicPackage(packageFile, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cacheResult(packageFile, flags, parsed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parsed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是文件夹类型，加载多个apk文件，如果是单个apk，只加载一个apk</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> Package <span class="title function_">parseMonolithicPackage</span><span class="params">(File apkFile, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> PackageParserException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AssetManager</span> <span class="variable">assets</span> <span class="operator">=</span> newConfiguredAssetManager();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">PackageLite</span> <span class="variable">lite</span> <span class="operator">=</span> parseMonolithicPackageLite(apkFile, flags);</span><br><span class="line">        <span class="keyword">if</span> (mOnlyCoreApps) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lite.coreApp) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PackageParserException</span>(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED,</span><br><span class="line">                        <span class="string">&quot;Not a coreApp: &quot;</span> + apkFile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行具体解析</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> parseBaseApk(apkFile, assets, flags);</span><br><span class="line">            pkg.setCodePath(apkFile.getAbsolutePath());</span><br><span class="line">            pkg.setUse32bitAbi(lite.use32bitAbi);</span><br><span class="line">            <span class="keyword">return</span> pkg;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IoUtils.closeQuietly(assets);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入parseBaseApk:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Package <span class="title function_">parseBaseApk</span><span class="params">(File apkFile, AssetManager assets, <span class="type">int</span> flags)</span></span><br><span class="line">           <span class="keyword">throws</span> PackageParserException &#123;</span><br><span class="line">       <span class="comment">//获取apk路径</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">String</span> <span class="variable">apkPath</span> <span class="operator">=</span> apkFile.getAbsolutePath();</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">volumeUuid</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (apkPath.startsWith(MNT_EXPAND)) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> apkPath.indexOf(<span class="string">&#x27;/&#x27;</span>, MNT_EXPAND.length());</span><br><span class="line">           volumeUuid = apkPath.substring(MNT_EXPAND.length(), end);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mParseError = PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line">       mArchiveSourcePath = apkFile.getAbsolutePath();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (DEBUG_JAR) Slog.d(TAG, <span class="string">&quot;Scanning base APK: &quot;</span> + apkPath);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> <span class="variable">cookie</span> <span class="operator">=</span> loadApkIntoAssetManager(assets, apkPath, flags);</span><br><span class="line"></span><br><span class="line">       <span class="type">Resources</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">XmlResourceParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//获取apk资源文件</span></span><br><span class="line">           res = <span class="keyword">new</span> <span class="title class_">Resources</span>(assets, mMetrics, <span class="literal">null</span>);</span><br><span class="line">           <span class="comment">//解析AndroidManifest</span></span><br><span class="line">           parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> String[] outError = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">final</span> <span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> parseBaseApk(apkPath, res, parser, flags, outError);</span><br><span class="line">           <span class="keyword">if</span> (pkg == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PackageParserException</span>(mParseError,</span><br><span class="line">                       apkPath + <span class="string">&quot; (at &quot;</span> + parser.getPositionDescription() + <span class="string">&quot;): &quot;</span> + outError[<span class="number">0</span>]);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           pkg.setVolumeUuid(volumeUuid);</span><br><span class="line">           pkg.setApplicationVolumeUuid(volumeUuid);</span><br><span class="line">           pkg.setBaseCodePath(apkPath);</span><br><span class="line">           pkg.setSignatures(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> pkg;</span><br><span class="line">           ......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>获取apk路径，解析apk资源文件及AndroidManifest</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">parseBaseApkChild</span><span class="params">(Package parentPkg, Resources res, XmlResourceParser parser,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> flags, String[] outError)</span> <span class="keyword">throws</span> XmlPullParserException, IOException &#123;</span><br><span class="line">    <span class="comment">//创建package对象，将版本信息存储进来</span></span><br><span class="line">    <span class="comment">// Go ahead and parse the child</span></span><br><span class="line">    <span class="type">Package</span> <span class="variable">childPkg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Package</span>(childPackageName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Child package inherits parent version code/name/target SDK</span></span><br><span class="line">    childPkg.mVersionCode = parentPkg.mVersionCode;</span><br><span class="line">    childPkg.baseRevisionCode = parentPkg.baseRevisionCode;</span><br><span class="line">    childPkg.mVersionName = parentPkg.mVersionName;</span><br><span class="line">    childPkg.applicationInfo.targetSdkVersion = parentPkg.applicationInfo.targetSdkVersion;</span><br><span class="line">    childPkg.applicationInfo.minSdkVersion = parentPkg.applicationInfo.minSdkVersion;</span><br><span class="line"></span><br><span class="line">    childPkg = parseBaseApkCommon(childPkg, CHILD_PACKAGE_TAGS, res, parser, flags, outError);</span><br><span class="line">    <span class="keyword">if</span> (childPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If we got null then error was set during child parsing</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the parent-child relation</span></span><br><span class="line">    <span class="keyword">if</span> (parentPkg.childPackages == <span class="literal">null</span>) &#123;</span><br><span class="line">        parentPkg.childPackages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    parentPkg.childPackages.add(childPkg);</span><br><span class="line">    childPkg.parentPackage = parentPkg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建package对象，将版本信息存储进来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Package <span class="title function_">parseBaseApkCommon</span><span class="params">(Package pkg, Set&lt;String&gt; acceptedTags, Resources res,</span></span><br><span class="line"><span class="params">        XmlResourceParser parser, <span class="type">int</span> flags, String[] outError)</span> <span class="keyword">throws</span> XmlPullParserException,</span><br><span class="line">        IOException &#123;</span><br><span class="line">        .......</span><br><span class="line">    <span class="comment">//解析AndroidManifest的深度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">outerDepth</span> <span class="operator">=</span> parser.getDepth();</span><br><span class="line">    <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">            &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (tagName.equals(TAG_APPLICATION)) &#123;</span><br><span class="line">           ......</span><br><span class="line">           <span class="comment">//解析Application标签</span></span><br><span class="line">            <span class="keyword">if</span> (!parseBaseApplication(pkg, res, parser, flags, outError)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(TAG_PERMISSION)) &#123;</span><br><span class="line">            <span class="comment">//解析权限标签</span></span><br><span class="line">            <span class="keyword">if</span> (!parsePermission(pkg, res, parser, outError)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> pkg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取AndroidManifest的深度，然后深度遍历获取所有的标签并依次处理，这里以Application为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">parseBaseApplication</span><span class="params">(Package owner, Resources res,</span></span><br><span class="line"><span class="params">        XmlResourceParser parser, <span class="type">int</span> flags, String[] outError)</span></span><br><span class="line">    <span class="keyword">throws</span> XmlPullParserException, IOException &#123;</span><br><span class="line">    <span class="comment">//获取应用信息</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ApplicationInfo</span> <span class="variable">ai</span> <span class="operator">=</span> owner.applicationInfo;</span><br><span class="line">    <span class="comment">//获取包名</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">pkgName</span> <span class="operator">=</span> owner.applicationInfo.packageName;</span><br><span class="line">    <span class="comment">//获取Application的TypedArray</span></span><br><span class="line">    <span class="type">TypedArray</span> <span class="variable">sa</span> <span class="operator">=</span> res.obtainAttributes(parser,</span><br><span class="line">            com.android.internal.R.styleable.AndroidManifestApplication);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//获取应用名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">manageSpaceActivity</span> <span class="operator">=</span> sa.getNonConfigurationString(</span><br><span class="line">            com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity,</span><br><span class="line">            Configuration.NATIVE_CONFIG_VERSION);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//获取Application的allowBackUp</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">allowBackup</span> <span class="operator">=</span> sa.getBoolean(</span><br><span class="line">            com.android.internal.R.styleable.AndroidManifestApplication_allowBackup, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//获取主题</span></span><br><span class="line">    ai.theme = sa.getResourceId(</span><br><span class="line">            com.android.internal.R.styleable.AndroidManifestApplication_theme, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//获取描述</span></span><br><span class="line">    ai.descriptionRes = sa.getResourceId(</span><br><span class="line">            com.android.internal.R.styleable.AndroidManifestApplication_description, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取taskAffinity</span></span><br><span class="line">    ai.taskAffinity = buildTaskAffinityName(ai.packageName, ai.packageName,</span><br><span class="line">            str, outError);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">innerDepth</span> <span class="operator">=</span> parser.getDepth();</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="comment">//迭代Application元素下的所有子元素</span></span><br><span class="line">    <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">            &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取标签名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">tagName</span> <span class="operator">=</span> parser.getName();</span><br><span class="line">        <span class="comment">//如果是Activity</span></span><br><span class="line">        <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;activity&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> parseActivity(owner, res, parser, flags, outError, <span class="literal">false</span>,</span><br><span class="line">                    owner.baseHardwareAccelerated);</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="literal">null</span>) &#123;</span><br><span class="line">                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            owner.activities.add(a);</span><br><span class="line">            <span class="comment">//如果是receiver</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;receiver&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> parseActivity(owner, res, parser, flags, outError, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="literal">null</span>) &#123;</span><br><span class="line">                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            owner.receivers.add(a);</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析Application的其他属性及其子标签,而后返回方法直到scanDirLI方法，执行scanPackageLI函数</p><p>scanPackageLI—&gt;scanPackageInternalLI—&gt;scanPackageLI—&gt;scanPackageDirtyLI—&gt;commitPackageSettings</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">commitPackageSettings</span><span class="params">(PackageParser.Package pkg, PackageSetting pkgSetting,</span></span><br><span class="line"><span class="params">            UserHandle user, <span class="type">int</span> scanFlags, <span class="type">boolean</span> chatty)</span> <span class="keyword">throws</span> PackageManagerException &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//获取activities的大小</span></span><br><span class="line">            N = pkg.activities.size();</span><br><span class="line">            r = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                PackageParser.<span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> pkg.activities.get(i);</span><br><span class="line">                a.info.processName = fixProcessName(pkg.applicationInfo.processName,</span><br><span class="line">                        a.info.processName);</span><br><span class="line">                <span class="comment">//将activity添加到mActivies</span></span><br><span class="line">                mActivities.addActivity(a, <span class="string">&quot;activity&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (chatty) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                        r = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">256</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    r.append(a.info.name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//其他标签忽略</span></span><br><span class="line">            ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>将解析的标签，例activity记载到PMS的缓存中。至此，apk的所有信息就被存储在系统中，当使用intent跳转时会在该信息表中进行查找，然后跳转。</p><p>我们使用intent时，一般是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>,MainActivity.class);</span><br><span class="line"><span class="built_in">this</span>.startActivity(intent);</span><br></pre></td></tr></table></figure><p>跟踪源码，最终跳转到startActivityForResult：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startActivityForResult</span><span class="params">(<span class="meta">@RequiresPermission</span> Intent intent, <span class="type">int</span> requestCode,</span></span><br><span class="line"><span class="params">           <span class="meta">@Nullable</span> Bundle options)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (mParent == <span class="literal">null</span>) &#123;</span><br><span class="line">           options = transferSpringboardActivityOptions(options);</span><br><span class="line">           <span class="comment">//启动Activity</span></span><br><span class="line">           Instrumentation.<span class="type">ActivityResult</span> <span class="variable">ar</span> <span class="operator">=</span></span><br><span class="line">               mInstrumentation.execStartActivity(</span><br><span class="line">                   <span class="built_in">this</span>, mMainThread.getApplicationThread(), mToken, <span class="built_in">this</span>,</span><br><span class="line">                   intent, requestCode, options);</span><br><span class="line">           <span class="keyword">if</span> (ar != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">//发送启动请求</span></span><br><span class="line">               mMainThread.sendActivityResult(</span><br><span class="line">                   mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                   ar.getResultData());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               mStartedActivity = <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           cancelInputsAndStartExitTransition(options);</span><br><span class="line">           <span class="comment">// TODO Consider clearing/flushing other event sources and events for child windows.</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (options != <span class="literal">null</span>) &#123;</span><br><span class="line">               mParent.startActivityFromChild(<span class="built_in">this</span>, intent, requestCode, options);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Note we want to go through this method for compatibility with</span></span><br><span class="line">               <span class="comment">// existing applications that may have overridden it.</span></span><br><span class="line">               mParent.startActivityFromChild(<span class="built_in">this</span>, intent, requestCode);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过instrumentation启动Activity，并向主线程发送启动请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ActivityResult <span class="title function_">execStartActivity</span><span class="params">(</span></span><br><span class="line"><span class="params">     Context who, IBinder contextThread, IBinder token, String target,</span></span><br><span class="line"><span class="params">     Intent intent, <span class="type">int</span> requestCode, Bundle options)</span> &#123;</span><br><span class="line">     <span class="type">IApplicationThread</span> <span class="variable">whoThread</span> <span class="operator">=</span> (IApplicationThread) contextThread;</span><br><span class="line">     ......</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//将Intent中的数据迁移到粘贴板</span></span><br><span class="line">         intent.migrateExtraStreamToClipData();</span><br><span class="line">         <span class="comment">//准备离开当前进程</span></span><br><span class="line">         intent.prepareToLeaveProcess(who);</span><br><span class="line">         <span class="comment">//通过AMS启动Activity</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ActivityManager.getService()</span><br><span class="line">             .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                     intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                     token, target, requestCode, <span class="number">0</span>, <span class="literal">null</span>, options);</span><br><span class="line">         <span class="comment">//检测结果，并且回调给调用端</span></span><br><span class="line">         checkStartActivityResult(result, intent);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failure from system&quot;</span>, e);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>进入AMS方法，调用</p><p>startActivityAsUser—&gt;ActivityStarter.startActivityMayWait—&gt;ActivityStackSupervisor.resolveIntent—&gt;AMS.getPackageManagerInternalLocked—&gt;PMS.resolveIntent—&gt;PMS.resolveIntentInternal—&gt;PMS.queryIntentActivitiesInternal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="meta">@NonNull</span> List&lt;ResolveInfo&gt; <span class="title function_">queryIntentActivitiesInternal</span><span class="params">(Intent intent,</span></span><br><span class="line"><span class="params">        String resolvedType, <span class="type">int</span> flags, <span class="type">int</span> filterCallingUid, <span class="type">int</span> userId,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> resolveForStart)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//获取包名</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">pkgName</span> <span class="operator">=</span> intent.getPackage();</span><br><span class="line">    <span class="comment">//获取component对象</span></span><br><span class="line">    <span class="type">ComponentName</span> <span class="variable">comp</span> <span class="operator">=</span> intent.getComponent();</span><br><span class="line">    <span class="comment">//如果component不为null</span></span><br><span class="line">    <span class="keyword">if</span> (comp != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ResolveInfo&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ResolveInfo&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//直接getActivityInfo获取ActivityInfo对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ActivityInfo</span> <span class="variable">ai</span> <span class="operator">=</span> getActivityInfo(comp, flags, userId);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//如果是隐式intent</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        <span class="comment">//如果包名为null</span></span><br><span class="line">        <span class="keyword">if</span> (pkgName == <span class="literal">null</span>) &#123;</span><br><span class="line">            List&lt;CrossProfileIntentFilter&gt; matchingFilters =</span><br><span class="line">                    getMatchingCrossProfileIntentFilters(intent, resolvedType, userId);</span><br><span class="line">            <span class="comment">// Check for results that need to skip the current profile.</span></span><br><span class="line">            <span class="comment">//获取resolveInfo对象</span></span><br><span class="line">            <span class="type">ResolveInfo</span> <span class="variable">xpResolveInfo</span>  <span class="operator">=</span> querySkipCurrentProfileIntents(matchingFilters, intent,</span><br><span class="line">                    resolvedType, flags, userId);</span><br><span class="line">            <span class="keyword">if</span> (xpResolveInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">                List&lt;ResolveInfo&gt; xpResult = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ResolveInfo&gt;(<span class="number">1</span>);</span><br><span class="line">                xpResult.add(xpResolveInfo);</span><br><span class="line">                <span class="keyword">return</span> applyPostResolutionFilter(</span><br><span class="line">                        filterIfNotSystemUser(xpResult, userId), instantAppPkgName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//通过包名获取Package对象</span></span><br><span class="line">            <span class="keyword">final</span> PackageParser.<span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> mPackages.get(pkgName);</span><br><span class="line">            result = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (pkg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//通过package获取ActivityInfo</span></span><br><span class="line">                result = filterIfNotSystemUser(</span><br><span class="line">                        mActivities.queryIntentForPackage(</span><br><span class="line">                                intent, resolvedType, flags, pkg.activities, userId),</span><br><span class="line">                        userId);</span><br><span class="line">            &#125;</span><br><span class="line">           ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果intent指明了Component（即MainActivity），直接获取到ActivityInfo并且数量只有一个，直接返回。如果Component为空，会检测发起方所在的包名，如果有包名，通过包名获取ActivityInfo，反之，根据其他信息比如外部拉起，action，Category等判断。</p><p>总结：在系统启动时，PMS启动分析所有apk的信息，创建一个信息表，当用胡使用Intent跳转时，会根据intent中包含的信息到PMS的信息表查找，最后跳转到目标组件</p><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>内存中二进制流的拷贝，其比直接new一个对象性能会好很多<br>缺点：</li><li>直接在内存中拷贝，不会执行构造函数，使用过程中对比new和clone方法的区别</li></ul><blockquote><p>原型模式就是要实现深拷贝</p></blockquote><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>用于创建对象的接口，让子类决定实例化那个类，解决对象之间的解耦</p><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><h5 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类具体实现方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;制造ProductA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductB</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;制造ProductB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">create</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;A&quot;</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;B&quot;</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line">    <span class="type">Product</span> <span class="variable">a</span> <span class="operator">=</span> factory.create(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    a.method();</span><br><span class="line">    <span class="type">Product</span> <span class="variable">b</span> <span class="operator">=</span> factory.create(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    b.method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后：</p><p>制造ProductA</p><p>制造ProductB</p><h5 id="工厂方法抽象"><a href="#工厂方法抽象" class="headerlink" title="工厂方法抽象"></a>工厂方法抽象</h5><p>产品类不变，工厂变为抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂具体实现方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title function_">create</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryA</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryB</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="type">FactoryA</span> <span class="variable">factoryA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryA</span>();</span><br><span class="line">    <span class="type">FactoryB</span> <span class="variable">factoryB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryB</span>();</span><br><span class="line">    factoryA.create().method();</span><br><span class="line">    factoryB.create().method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后：</p><p>制造ProductA</p><p>制造ProductB</p><h5 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h5><p>需要多个产品最终组成为一个产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Cpu</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cpu子类的具体执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CpuA</span> <span class="keyword">extends</span> <span class="title class_">Cpu</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A型号CPU&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CpuB</span> <span class="keyword">extends</span> <span class="title class_">Cpu</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B型号CPU&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示屏的子类执行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisplayA</span> <span class="keyword">extends</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A型号显示屏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisplayB</span> <span class="keyword">extends</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B型号显示屏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Cpu</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> Cpu <span class="title function_">createCpu</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建显示屏</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> Display <span class="title function_">createDisplay</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryA</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Cpu <span class="title function_">createCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CpuA</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Display <span class="title function_">createDisplay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DisplayA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryB</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Cpu <span class="title function_">createCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CpuB</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Display <span class="title function_">createDisplay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DisplayB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">FactoryA</span> <span class="variable">factoryA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryA</span>();</span><br><span class="line">        <span class="type">FactoryB</span> <span class="variable">factoryB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FactoryB</span>();</span><br><span class="line">        factoryA.createCpu().method();</span><br><span class="line">        factoryA.createDisplay().method();</span><br><span class="line">        factoryB.createCpu().method();</span><br><span class="line">        factoryB.createDisplay().method();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p>A型号CPU</p><p>A型号显示屏</p><p>B型号CPU</p><p>B型号显示屏</p><blockquote><p>抽象工厂的核心是复杂的工厂模式。存在多个工厂，多种产品类型，就会使用抽象工厂，在android源码中使用较少，并没有那么多产品种类，大部分使用简单工厂或者工厂方法就可以解决。</p></blockquote><h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><ol><li>ArrayList和HashSet都继承自Collection接口，collection接口继承自Iterator接口。</li><li>xxxActivity都继承自Activity，其onCreate方法就是工厂方法，两个Activity构建不同的view，可以将view看成product，Activity为Factory。</li><li>xxService都继承自Service，其onBind方法也可以看作是一个工厂方法</li><li></li></ol><h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>功能逻辑解耦</li></ul><p>缺点：</p><ul><li>拓展新功能需要添加新类，复杂类结构</li></ul><p>抽象工厂的优点:</p><ul><li>分离接口与实现,使用方不知道具体的实现是什么,同时使抽象该工厂方法模式在切换产品类时更加灵活,容易</li></ul><p>抽象工厂的缺点:</p><ul><li>类文件结构复杂</li><li>不容易拓展新类</li></ul><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>定义一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，策略模式让算法独立于使用他们的客户而独立存在，解决if-else滥用的问题</p><h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatePrice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TransPortType</span> &#123;</span><br><span class="line">        BUS,</span><br><span class="line">        SUBWAY</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算公交车车费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">calculateBus</span><span class="params">(<span class="type">int</span> km)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;公交车&quot;</span> + km + <span class="string">&quot;公里的车票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算地铁车费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">calculateSubWay</span><span class="params">(<span class="type">int</span> km)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;地铁&quot;</span> + km + <span class="string">&quot;公里的车票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> km, TransPortType transPortType)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (transPortType) &#123;</span><br><span class="line">            <span class="keyword">case</span> BUS:</span><br><span class="line">                calculateBus(km);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUBWAY:</span><br><span class="line">                calculateSubWay(km);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">CalculatePrice</span> <span class="variable">calculatePrice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalculatePrice</span>();</span><br><span class="line">        calculatePrice.calculate(<span class="number">16</span>,TransPortType.BUS);</span><br><span class="line">        calculatePrice.calculate(<span class="number">15</span>,TransPortType.SUBWAY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br>公交车16公里的车票</p><p>地铁15公里的车票</p><p>当需要拓展时，比如多了一个出租车，需要这样做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatePrice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TransPortType</span> &#123;</span><br><span class="line">        BUS,</span><br><span class="line">        SUBWAY,</span><br><span class="line">        TAXI</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算公交车车费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">calculateBus</span><span class="params">(<span class="type">int</span> km)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;公交车&quot;</span> + km + <span class="string">&quot;公里的车票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算地铁车费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">calculateSubWay</span><span class="params">(<span class="type">int</span> km)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;地铁&quot;</span> + km + <span class="string">&quot;公里的车票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算出租车车费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">calculateTaxi</span><span class="params">(<span class="type">int</span> km)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;出租车&quot;</span> + km + <span class="string">&quot;公里的车票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> km, TransPortType transPortType)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (transPortType) &#123;</span><br><span class="line">            <span class="keyword">case</span> BUS:</span><br><span class="line">                calculateBus(km);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUBWAY:</span><br><span class="line">                calculateSubWay(km);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TAXI:</span><br><span class="line">                calculateTaxi(km);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">CalculatePrice</span> <span class="variable">calculatePrice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalculatePrice</span>();</span><br><span class="line">        calculatePrice.calculate(<span class="number">16</span>,TransPortType.BUS);</span><br><span class="line">        calculatePrice.calculate(<span class="number">15</span>,TransPortType.SUBWAY);</span><br><span class="line">        calculatePrice.calculate(<span class="number">17</span>,TransPortType.TAXI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>公交车16公里的车票</p><p>地铁15公里的车票</p><p>出租车17公里的车票</p><p>改动还是比较大的，对源代码的基础上做了更改，并且添加了if-else判断taxi类型。<br>如果把他改成策略模式，试试效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CalculateStrategy</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类具体执行车票计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">getPrice</span><span class="params">(<span class="type">int</span> km)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusCalculateStrategy</span> <span class="keyword">extends</span> <span class="title class_">CalculateStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPrice</span><span class="params">(<span class="type">int</span> km)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;公交车&quot;</span> + km + <span class="string">&quot;公里的车票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubWayCalculateStrategy</span> <span class="keyword">extends</span> <span class="title class_">CalculateStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPrice</span><span class="params">(<span class="type">int</span> km)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;地铁&quot;</span> + km + <span class="string">&quot;公里的车票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">CalculateStrategy</span> <span class="variable">calculateStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BusCalculateStrategy</span>();</span><br><span class="line">        calculateStrategy.getPrice(<span class="number">16</span>);</span><br><span class="line">        <span class="type">CalculateStrategy</span> <span class="variable">calculateStrategy1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubWayCalculateStrategy</span>();</span><br><span class="line">        calculateStrategy1.getPrice(<span class="number">15</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>公交车16公里的车票</p><p>地铁15公里的车票</p><p>当需要拓展出租车时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaxiCalculateStrategy</span> <span class="keyword">extends</span> <span class="title class_">CalculateStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPrice</span><span class="params">(<span class="type">int</span> km)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;出租车&quot;</span> + km + <span class="string">&quot;公里的车票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">CalculateStrategy</span> <span class="variable">calculateStrategy2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaxiCalculateStrategy</span>();</span><br><span class="line">        calculateStrategy2.getPrice(<span class="number">17</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>只需要添加Taxi类继承自策略类，执行具体车费计算方法，在main中调用即可，这样对代码的侵入性最小，不用修改原有逻辑代码，在咋付逻辑出引用效果优秀</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>当一个对象的内在行为改变时，允许改变其行为，整个对象看起来像是改变了其类</p><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><ol><li>wifi状态管理</li></ol><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>使多个对象都有机会处理请求，这些对象形成一条链，依次执行，直到结束。</p><h4 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h4><ol><li>view的事件传递</li></ol><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p>定义对象间一种一对多的一栏关系，使得每当一个对象改变状态，则所有依赖与他的对象都会得到通知并被自动更新</p><h4 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mode2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IObserver</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> temp)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IObservable</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(IObserver iObserver)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">(IObserver iObserver)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被观察者（发布者）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Observable</span> <span class="keyword">implements</span> <span class="title class_">IObservable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> ArrayList&lt;IObserver&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(IObserver iObserver)</span> &#123;</span><br><span class="line">            list.add(iObserver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">(IObserver iObserver)</span> &#123;</span><br><span class="line">            list.remove(iObserver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                list.get(i).update(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTemp</span><span class="params">(<span class="type">int</span> temp)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.temp = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察者1（订阅者）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Observer1</span> <span class="keyword">implements</span> <span class="title class_">IObserver</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> temp)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Observable1更新为 = &quot;</span> + temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察者2(订阅者)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Observer2</span> <span class="keyword">implements</span> <span class="title class_">IObserver</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> temp)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Observable2更新为 = &quot;</span> + temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Observable</span> <span class="variable">observable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Observable</span>();</span><br><span class="line">        <span class="type">Observer1</span> <span class="variable">observer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Observer1</span>();</span><br><span class="line">        <span class="type">Observer2</span> <span class="variable">observer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Observer2</span>();</span><br><span class="line">        observable.register(observer1);</span><br><span class="line">        observable.register(observer2);</span><br><span class="line">        observable.setTemp(<span class="number">32131232</span>);</span><br><span class="line">        observable.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h3&gt;&lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>启动优化</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</id>
    <published>2021-05-31T12:58:13.000Z</published>
    <updated>2023-12-19T06:50:38.179Z</updated>
    
    <content type="html"><![CDATA[<h4 id="app启动过程"><a href="#app启动过程" class="headerlink" title="app启动过程"></a>app启动过程</h4><ol><li>点击图标启动</li><li>LauncherApp通知AMS进行启动，LauncherActivity onPause</li><li>AMS新建app进程，创建ActivityThread，创建ApplicationThread</li><li>通过ApplicationThread向AMS注册Binder</li><li>执行Application的onCreate方法</li><li>新建进入的Activity</li><li>执行Activity的onCreate方法，进行UI绘制等操作</li></ol><h4 id="启动分类"><a href="#启动分类" class="headerlink" title="启动分类"></a>启动分类</h4><ul><li>冷启动：从点击应用图标到UI界面完全显示且用户可操作的全部过程。</li></ul><p>Click Event    -&gt;     IPC     -&gt;     Process.start     -&gt;      ActivityThread -&gt;    bindApplication      -&gt;      LifeCycle    -&gt;     ViewRootImpl</p><ul><li>热启动：直接从后台切换到前台。</li></ul><h4 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h4><p>可优化Application、Activity的创建以及回调过程</p><ol><li>提前展示一个window（欢迎页），给用户友好的提示</li><li>避免启动做繁重密集的初始化操作</li><li>过度绘制，网络，io等优化</li></ol><h4 id="优化检测"><a href="#优化检测" class="headerlink" title="优化检测"></a>优化检测</h4><ol><li>adb命令检测<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中的AppstartActivity全路径可以省略前面的packageName</span></span><br><span class="line">adb shell am start -W [packageName]/[AppstartActivity全路径]</span><br></pre></td></tr></table></figure></li></ol><ul><li>ThisTime：最后一个Activity的启动耗时</li><li>TotalTime：所有Activity的启动耗时</li><li>WaitTime：表示AMS启动Activity的总耗时。</li></ul><p>一般读取WaitTime，为Application和Activity的初始化过程耗时。（冷启动耗时）</p><p>优缺点：</p><ul><li>线下使用方便，不能带到线上</li><li>非精确时间</li></ul><ol start="2"><li>自定义打点查看耗时</li></ol><ul><li>应用生命周期节点</li><li>启动的初始化方法节点</li><li>其他耗时业务，算法节点</li></ul><p>优缺点：</p><ul><li>精确，可上线</li><li>修改成本高</li></ul><p>3.AOP打点<br>加入aspectjx库，打印出Application，Activity的耗时时间，进行针对优化</p><p>根路径build.gradle中添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath <span class="string">&#x27;com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.0&#x27;</span></span><br></pre></td></tr></table></figure><p>app中build.gradle中添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;android-aspectjx&#x27;</span></span><br><span class="line">...</span><br><span class="line">implementation <span class="string">&#x27;org.aspectj:aspectjrt:1.8.+&#x27;</span></span><br></pre></td></tr></table></figure><p>使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LauncherAop</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;call(* com.jw.myapplication.MainActivity.**(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> signature.toShortString();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(<span class="string">&quot;kangkang = &quot;</span>,<span class="string">&quot;kangaop = &quot;</span> +name+ <span class="string">&quot; cost &quot;</span> + (System.currentTimeMillis() - time));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.TraceView</p><p>代码中开启</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Debug.startMethodTracing();</span><br><span class="line">method();</span><br><span class="line">Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure><p>生成.trace文件，导入Android Studio，使用profile中的cpu查看文件生成的火炬图</p><h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><ol><li>主题切换</li></ol><p>设置自定义主题设置背景图，执行到onCreate方法后替换为Activiy的真实布局<br>2. 初始化分化<br><img src="/imageMd/appStartUp-1.png" alt="img"></p><ul><li>MultiDex以及Tinker的初始化操作</li><li>Application中的第三方组件的初始化<ol><li>异步初始化组件，不阻塞主线程，设置异步线程为THREAD_PRIORITY_BACKGROUND</li><li>延迟初始化操作，再线程空闲时加载，</li><li>EventBus、ota、bugly、migu、Linphone、Butterknife、地图、IOT</li></ol></li><li>设置线程池初始化任务<ol><li>仿照AsyncTask新建线程池，核心线程数为2-4个</li><li>任务使用该线程池加载，如有顺序，使用CountDownLatch进行处理</li></ol></li><li>部分任务可以延迟加载，使用IdleHandler，在主线程空闲时加载</li><li>Multidex预加载优化</li></ul><h4 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h4><p>在使用Aspect进行时间的监测时，发现Application和Activity中的初始化三方进程耗费了大量时间，在初始化时，我们开启了百度OTA服务，Bugly监测服务，咪咕音乐服务，阿里IOT服务，日志监测服务，Linphone语音服务，Ifly语音服务等，这些串行起来是比较耗时的。<br>所以我们采用开启一个线程池的方案，在子线程启动这些服务，对于OTA，IOT，日志检测，Linphone等服务不需要在第一时间初始化，所以放到线程池中根据执行顺序分别初始化。但是对于咪咕、Ifly和bugly来说，需要第一时间初始化，才能进行后边的逻辑，所以我们将这些服务优先初始化，并联合CountDownLatch，当必须的服务初始化完成后，才进入下面的流程。<br>对于必须要在主线程进行初始化的操作，可能会造成主线程繁忙卡顿，所以使用IdleHandler方法，在主线程空闲时执行，</p><p>具体优化了40%，由2.3s压缩到1.4s。</p><p>如果由任务A，B，C，D，要求C在A之后执行，D在B之后执行，那么直接将A,C合并为一个任务，放入线程池中运行，B、D合并为一个任务，放入线池程中执行，如需决定AC和BD的顺序，那么可以按照AC、BD的顺序依次放入子线程中。</p><h4 id="如何对IDLEHandler进行顺序划分？比如先执行B，在执行A"><a href="#如何对IDLEHandler进行顺序划分？比如先执行B，在执行A" class="headerlink" title="如何对IDLEHandler进行顺序划分？比如先执行B，在执行A"></a>如何对IDLEHandler进行顺序划分？比如先执行B，在执行A</h4><p>规划一个空闲队列，在Handler空闲时进行处理，每次出队优先级最高的，其他等到下次空闲在执行</p><h4 id="2-4是怎么计算的？"><a href="#2-4是怎么计算的？" class="headerlink" title="2-4是怎么计算的？"></a>2-4是怎么计算的？</h4><p>核心线程数位2-4，计算方式是cpu核数-1，如果比2小，就选择2，比4大就选择4，中间就选它自己，<br>之所以 减掉这个1，是因为为了避免后台任务将 CPU 资源完全耗尽， 减掉的这个1 是留给我们 主线程 使用的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;app启动过程&quot;&gt;&lt;a href=&quot;#app启动过程&quot; class=&quot;headerlink&quot; title=&quot;app启动过程&quot;&gt;&lt;/a&gt;app启动过程&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;点击图标启动&lt;/li&gt;
&lt;li&gt;LauncherApp通知AMS进行启动，Launche</summary>
      
    
    
    
    <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>注解原理</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86/</id>
    <published>2021-05-31T12:56:54.000Z</published>
    <updated>2023-12-19T06:50:38.180Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="简析"><a href="#简析" class="headerlink" title="简析"></a>简析</h3><p>元注解：修饰注解的注解，</p><ul><li>@Target：注解的作用目标（修饰方法，类还是字段）</li><li>@Retention：注解的生命周期<ul><li>SOURCE：仅存在java源文件中，经过编译器后就丢弃，适用于一些检查行的操作，比如@Override</li><li>CLASS：编译class文件时生效，适用于在编译时女性一些预处理操作，比如Butterknife的@BindView，在编译时，通过注解器生成一些辅助代码，完成完整的功能</li><li>RUNTIME：保留在运行时VM中可以通过反射获取注解。适用于一些需要运行时动态获取注解信息，类似反射获取注解等，比如EventBus的@Subscribe</li></ul></li><li>@Documented：注解是否应当被包含在JavaDoc文档中</li><li>@Inherited：是否允许子类继承该注解</li><li>AnnotationInvocationHandler：专门处理注解的Handler</li></ul><p>代码的生命周期包含：编码(SOURCE)—-&gt;编译(CLASS)—-&gt;运行(RUNTIME)</p><blockquote><p>默认时注解在编译阶段，即CLASS阶段</p></blockquote><p>本质：一个继承了Annotation接口的接口</p><ul><li>运行时处理：使用反射获取当前的所需要的东西</li><li>编译时处理：APT技术，即编译期扫描java文件的注解，并传递到注解处理器，注解处理器可根据注解生成新的java文件</li></ul><h3 id="注解器"><a href="#注解器" class="headerlink" title="注解器"></a>注解器</h3><p>注解器通常是以Java代码（或者编译过的字节码）作为输入，生成.java文件作为输出</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/29/166bf16b90b04e6c" alt="image"></p><p>使用google的AutoService（@AutoService）可以自动生成resources&#x2F;META-INF.services中的注册目录</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/29/166bf16ca4f2434d" alt="image"></p><p>包含注解处理器，注解声明库，实际使用APT的Android&#x2F;Java项目</p><h4 id="为什么把注解处理器独立抽成一个库呢？"><a href="#为什么把注解处理器独立抽成一个库呢？" class="headerlink" title="为什么把注解处理器独立抽成一个库呢？"></a>为什么把注解处理器独立抽成一个库呢？</h4><p>对于Android项目默认是不包含 APT相关类的。所以要使用APT技术，那么就必须创建一个Java Library。对于Java项目，独立抽成一个库，更容易维护与扩展。</p><h4 id="为什么把注解声明也单独抽成一个库，而不放到注解处理工具库中呢？"><a href="#为什么把注解声明也单独抽成一个库，而不放到注解处理工具库中呢？" class="headerlink" title="为什么把注解声明也单独抽成一个库，而不放到注解处理工具库中呢？"></a>为什么把注解声明也单独抽成一个库，而不放到注解处理工具库中呢？</h4><p>这样可以不用将注解处理器的相关代码大报道使用者的项目中去</p><h4 id="注解器声明"><a href="#注解器声明" class="headerlink" title="注解器声明"></a>注解器声明</h4><p>其方法包含四个主要重写方法</p><ul><li>init() ：初始化调用</li><li>process()：实际处理方法</li><li>getSupportedAnnotationTypes()：返回当前注解器处理注解的类型</li><li>getSupportedSourceVersion()：指定你使用的java版本</li></ul><p>在注解处理过程中，会扫描所有的java源文件，查询注解，在java源代码中，每一部分都代表一个特定类型的Element，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jennifer.andy.aptdemo.domain;<span class="comment">//PackageElement</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;<span class="comment">//TypeElement </span></span><br><span class="line">    <span class="keyword">private</span> String where;<span class="comment">//VariableElement</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123; &#125;<span class="comment">//ExecutableElement</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//ExecutableElement</span></span><br><span class="line">        <span class="type">int</span> runTime;<span class="comment">//VariableElement</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注解处理器是运行在它自己的虚拟机JVM中，javac启动一个完整Java虚拟机来运行注解处理器。</p></blockquote><p>最终是通过自定义注解器在编译时期生成加载注解后的类，在process方法中具体做了执行，编译了程序模版信息进行添加。</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>如果是单一属性，可以使用value字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> MyAnno1 &#123;</span><br><span class="line">    <span class="comment">//格式：类型名 属性名（）</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnno1(&quot;kang&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> MyAnno2 &#123;</span><br><span class="line">    <span class="comment">//格式：类型名 属性名（）</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnno2(name = &quot;kang&quot;)</span></span><br></pre></td></tr></table></figure><p>如果不是value字段的话，需要（指定属性 &#x3D; 值）</p><blockquote><p>注解中只允许八中基本数据类型、字符串、类类型，注解类型，枚举类型及其一维数组</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;注解&quot;&gt;&lt;a href=&quot;#注解&quot; class=&quot;headerlink&quot; title=&quot;注解&quot;&gt;&lt;/a&gt;注解&lt;/h2&gt;&lt;h3 id=&quot;简析&quot;&gt;&lt;a href=&quot;#简析&quot; class=&quot;headerlink&quot; title=&quot;简析&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>LiveData和ViewModel源码分析</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/LiveData%E5%92%8CViewModel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/LiveData%E5%92%8CViewModel%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2021-05-31T12:55:45.000Z</published>
    <updated>2023-12-19T06:50:38.178Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><h4 id="ViewModel的定义"><a href="#ViewModel的定义" class="headerlink" title="ViewModel的定义"></a>ViewModel的定义</h4><p>ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存。</p><p><strong>历史方式的缺点</strong>：</p><ol><li>对于简单的数据，Activity 可以使用 onSaveInstanceState() 方法从 onCreate() 中的捆绑包恢复其数据，但此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图。</li><li>需要处理异步调用，内存泄漏等问题</li><li>使界面控制器类越发膨胀</li></ol><blockquote><p>ViewModel将数据存储和界面控制进行分离，独立出来<br>ViewModel 存在的时间范围是从您首次请求 ViewModel 直到 Activity 完成并销毁。</p></blockquote><h4 id="ViewModel生命周期"><a href="#ViewModel生命周期" class="headerlink" title="ViewModel生命周期"></a>ViewModel生命周期</h4><p><img src="/imageMd/LiveData&ViewModel-1.png" alt="img"></p><p>ViewModel在onCreate中初始化，在finish()后会调用onCleared()方法，</p><blockquote><p>所以ViewModel生命周期长于Activity,ViewModel不持有UI的引用，通过观察者通知界面更新</p></blockquote><h4 id="ViewModel在Fragment之间共享数据"><a href="#ViewModel在Fragment之间共享数据" class="headerlink" title="ViewModel在Fragment之间共享数据"></a>ViewModel在Fragment之间共享数据</h4><p>为什么能在Fragment中共享数据？<br>因为在Fragment中初始化ViewModel时传入的宿主Activity，ViewModelStore中取出当前Activity对应的ViewModel对象，返回给Fragment，这样他们获取的是同一个ViewModel实例，数据当然也会共享</p><h4 id="ViewModel源码分析"><a href="#ViewModel源码分析" class="headerlink" title="ViewModel源码分析"></a>ViewModel源码分析</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>我们通常使用这种方式初始化ViewModel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProgressViewModel</span> <span class="variable">processViewModel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>(<span class="built_in">this</span>).get(ProcessViewModel.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStoreOwner owner)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(owner.getViewModelStore(), owner <span class="keyword">instanceof</span> HasDefaultViewModelProviderFactory</span><br><span class="line">                ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()</span><br><span class="line">                : NewInstanceFactory.getInstance());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从ViewModelStoreOwer中获取ViewModelStore，ViewModelStore是从AppCompatActivity-&gt;FragmentActivity-&gt;ComponentActivity中获取，本质还是new ViewModelStore()。<br>Factory在AppCompatActivity和Fragment中的是HasDefaultViewModelProviderFactory，具体实现是SavedStateViewModelFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStore store, <span class="meta">@NonNull</span> Factory factory)</span> &#123;</span><br><span class="line">    mFactory = factory;</span><br><span class="line">    mViewModelStore = store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将ViewModelStore和Factory进行赋值</p><h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><p>进入get方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">    <span class="comment">//返回该类的规范名称，如果它是本地或匿名类或其组件类型没有规范名称的数组，则返回null。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">canonicalName</span> <span class="operator">=</span> modelClass.getCanonicalName();</span><br><span class="line">    <span class="keyword">if</span> (canonicalName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Local and anonymous classes can not be ViewModels&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//key = DEFAULT_KEY + &quot;:&quot; + canonicalName</span></span><br><span class="line">    <span class="keyword">return</span> get(DEFAULT_KEY + <span class="string">&quot;:&quot;</span> + canonicalName, modelClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">    <span class="comment">//从ViewModelStore中获取ViewModel，首次进入获取为空</span></span><br><span class="line">    <span class="type">ViewModel</span> <span class="variable">viewModel</span> <span class="operator">=</span> mViewModelStore.get(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//等效于instanceOf，判断是否是所需viewModel</span></span><br><span class="line">    <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> OnRequeryFactory) &#123;</span><br><span class="line">            ((OnRequeryFactory) mFactory).onRequery(viewModel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//noinspection StatementWithEmptyBody</span></span><br><span class="line">        <span class="keyword">if</span> (viewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> KeyedFactory) &#123;</span><br><span class="line">        viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        viewModel = (mFactory).create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">    mViewModelStore.put(key, viewModel);</span><br><span class="line">    <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可知<br>Factory放入具体实现是SavedStateViewModelFactory，SavedStateViewModelFactory又继承于KeyedFactory，我们看下create方法，值得一提的是，这里的mFactory是AndroidViewModelFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">create</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">        <span class="comment">//是否为AndroidViewModel类，或者其子类</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isAndroidViewModel</span> <span class="operator">=</span> AndroidViewModel.class.isAssignableFrom(modelClass);</span><br><span class="line">        Constructor&lt;T&gt; constructor;</span><br><span class="line">        <span class="keyword">if</span> (isAndroidViewModel) &#123;</span><br><span class="line">            constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// doesn&#x27;t need SavedStateHandle</span></span><br><span class="line">        <span class="comment">//如果constructor为null，create内部什么也不处理</span></span><br><span class="line">        <span class="keyword">if</span> (constructor == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mFactory.create(modelClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">SavedStateHandleController</span> <span class="variable">controller</span> <span class="operator">=</span> SavedStateHandleController.create(</span><br><span class="line">                mSavedStateRegistry, mLifecycle, key, mDefaultArgs);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T viewmodel;</span><br><span class="line">            <span class="keyword">if</span> (isAndroidViewModel) &#123;</span><br><span class="line">                viewmodel = constructor.newInstance(mApplication, controller.getHandle());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                viewmodel = constructor.newInstance(controller.getHandle());</span><br><span class="line">            &#125;</span><br><span class="line">            viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);</span><br><span class="line">            <span class="keyword">return</span> viewmodel;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to access &quot;</span> + modelClass, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;A &quot;</span> + modelClass + <span class="string">&quot; cannot be instantiated.&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;An exception happened in constructor of &quot;</span></span><br><span class="line">                    + modelClass, e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>判断ViewModel类型，获取不同的构造方法，通过反射实现ViewModel的初始化，然后使用mViewModelStore.put(key, viewModel); 将viewModel以key的形式存入ViewModelStore<br>进入ViewModelStore：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewModelStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, ViewModel viewModel)</span> &#123;</span><br><span class="line">        <span class="type">ViewModel</span> <span class="variable">oldViewModel</span> <span class="operator">=</span> mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ViewModel <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; <span class="title function_">keys</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Clears internal storage and notifies ViewModels that they are no longer used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>内部实现就是一个HashMap，Key为String，value为ViewModel，put后新放入的ViewModel覆盖新的ViewModel，这里的key强调一下，统一格式为<code>androidx.lifecycle.ViewModelProvider.DefaultKey:com.zz.chatright.ChatViewModel</code></p><h5 id="SavedState"><a href="#SavedState" class="headerlink" title="SavedState"></a>SavedState</h5><p>在源码分析中我们看到构造函数中都包含了一个SavedStateHandleController类，这里保存了数据类，使其不受生命周期影响，例如发生屏幕旋转等。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8zLzE5LzE3MGYzNWYyZjgyMmIwMWM?x-oss-process=image/format,png" alt="img"></p><ul><li>SaveStateHandle：<br>内部存储数据格式为*Map&lt;String, Object&gt;<em>，亦存在</em>Map&lt;String, SavingStateLiveData&lt;?&gt;&gt;*完成值的通知</li><li>SaveStateHandleController：<br>将SaveStateHandle同Lifecycle生命周期进行绑定</li><li>SavedStateRegistry：<br>管理 SavedStateProvider 列表的组件，此注册表绑定了其所有者的生命周期（即 activity 或 fragment）</li><li>SavedStateProvider：<br>保存状态的组件，此状态将在以后恢复并使用</li></ul><blockquote><p>activity 的状态保存分为 view 状态和成员状态</p></blockquote><h6 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h6><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8zLzE5LzE3MGYzNWYyY2Y0NGU1ZDQ?x-oss-process=image/format,png" alt="img"></p><h4 id="如何保证viewModel的唯一性？"><a href="#如何保证viewModel的唯一性？" class="headerlink" title="如何保证viewModel的唯一性？"></a>如何保证viewModel的唯一性？</h4><p>通过反射进行初始化操作，带入的是Application的Context对象，这样就保证不会持有Activity或者Fragment的引用。然后会将创建出来的实例对象存储在ViewModelStore（内部HashMap）中，每次使用都会去ViewModelStore中查看是否存在，如果存在，则直接使用，不需要实例化<br>key就是DEFAULT_KEY + “:” + canonicalName（viewmModel类名路径，eg：com.zz.test.MyViewModel）</p><h4 id="为什么viewModel能管理生命周期，并且不受重建情况的影响"><a href="#为什么viewModel能管理生命周期，并且不受重建情况的影响" class="headerlink" title="为什么viewModel能管理生命周期，并且不受重建情况的影响"></a>为什么viewModel能管理生命周期，并且不受重建情况的影响</h4><p>2.0以前：创建了一个无view的HolderFragment同步Activity的生命周期，并关联ViewModelStore，而且设置setRetainInstance(true)时，会保证屏幕切换时生命周期不会改变，让fragment在Activity重建时存活下来</p><p>2.0以后：运用了androidx新库，用到了AppCompatActivity的父类ComponentActivity，重写onRetainNonConfigurationInstance()方法保存了ViewModelStore，Activity通过onRetainNonConfigurationInstance()方法获取ViewModelStore实例，保证了ViewModel不会随着Activity的重建而重建。<br>不论是Activity还是Fragment都实现了LifecycleOwner，所以生命周期通过Lifecycles组件感知每个页面的生命周期</p><blockquote><p>onRetainNonConfigurationInstance()和onSaveInstanceState的调用时机是一样的，但是onRetainNonConfigurationInstance()的Bundle数据不限制大小，所以更倾向这个</p></blockquote><p>当Activity因为配置需要重建时，系统会调用onRetainNonConfigurationInstance()方法，将ViewModelStore存储在NonConfigurationInstances中，最终交给ActivityClientRecord类，因为ActivityClientRecord不受Activity重建的影响，所以NoConfigurationInstances也不受Activity重建的影响</p><h4 id="ViewModel同onSaveInstanceState-的区别"><a href="#ViewModel同onSaveInstanceState-的区别" class="headerlink" title="ViewModel同onSaveInstanceState()的区别"></a>ViewModel同onSaveInstanceState()的区别</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>在Activity变得“容易”销毁时，就会触发onSaveInstanceState()</p><ol><li>当按下HOME键后，系统就会触发调用</li><li>当长按HOME键，选择运行其他程序时</li><li>按电源键息屏的时候</li><li>从Activity A中启动一个新的Activity</li><li>横竖屏切换时</li></ol><blockquote><p>而使用ViewModel恢复数据 则 只有在 因配置更改界面销毁重建 的情况。</p></blockquote><h5 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h5><p>ViewModel存储在内存中，onSaveInstanceState()是序列化到磁盘中存储的</p><h5 id="存储大小"><a href="#存储大小" class="headerlink" title="存储大小"></a>存储大小</h5><p>ViewModel存储大小限制时app的可用内存<br>onSaveInstanceState()因为使用了序列化和反序列化，那么通过Bundle存储大小限制为1M</p><h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h2><h4 id="LiveData的定义"><a href="#LiveData的定义" class="headerlink" title="LiveData的定义"></a>LiveData的定义</h4><p><img src="https://developer.android.google.cn/images/topic/libraries/architecture/lifecycle-states.svg?hl=zh-cn" alt="img"></p><blockquote><p>当在onStart后，onResume,onPause都是STARTED&#x2F;RESUMED的，即为活跃的（onActive），当在onStop后，则为非活跃状态（onInActive）<br>LiveData 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。</p></blockquote><p>如果观察者（由 Observer 类表示）的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。LiveData 只会将更新通知给活跃的观察者。为观察 LiveData 对象而注册的非活跃观察者不会收到更改通知。</p><p>您可以注册与实现 LifecycleOwner 接口的对象配对的观察者。有了这种关系，当相应的 Lifecycle 对象的状态变为 DESTROYED 时，便可移除此观察者。这对于 Activity 和 Fragment 特别有用，因为它们可以放心地观察 LiveData 对象，而不必担心泄露（当 Activity 和 Fragment 的生命周期被销毁时，系统会立即退订它们）。</p><h4 id="LiveData的优势"><a href="#LiveData的优势" class="headerlink" title="LiveData的优势"></a>LiveData的优势</h4><ol><li>及时更新界面数据</li><li>不会发生内存泄漏，当其关联的生命周期被摧毁，则回收自己</li><li>不会因为Activity停止而崩溃，准确判断生命周期，决定是否通知</li><li>不需要自己手动处理生命周期</li><li>在再次活跃时会接收到最新的数据，保持数据最新状态</li><li>如果由于配置更改（如设备旋转）而重新创建了 Activity 或 Fragment，它会立即接收最新的可用数据。</li><li>共享资源。<br>您可以使用单例模式扩展 LiveData 对象以封装系统服务，以便在应用中共享它们。LiveData 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 LiveData 对象。</li></ol><h4 id="LiveData源码分析"><a href="#LiveData源码分析" class="headerlink" title="LiveData源码分析"></a>LiveData源码分析</h4><p>建立号viewModel后，我们在Activity中这样使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">processViewModel.isBigScreen.observe(appCompatActivity, it -&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>进入observe方法进行查看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;? <span class="built_in">super</span> T&gt; observer)</span> &#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;observe&quot;</span>);</span><br><span class="line">    <span class="comment">//如果该生命周期为onDestory之后，则return，不做处理</span></span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LifecycleBoundObserver</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LifecycleBoundObserver</span>(owner, observer);</span><br><span class="line">    <span class="comment">//将观察者注册到mObservers中，如果存在，则返回wrapper，否则，返回null</span></span><br><span class="line">    <span class="type">ObserverWrapper</span> <span class="variable">existing</span> <span class="operator">=</span> mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加到LifeCycle中</span></span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们使用setValue和postValue的方法进行数据更新<br>进入setValue下查看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;setValue&quot;</span>);</span><br><span class="line">    mVersion++;</span><br><span class="line">    mData = value;</span><br><span class="line">    dispatchingValue(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入dispatchingValue()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDispatchingValue = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (initiator != <span class="literal">null</span>) &#123;</span><br><span class="line">            considerNotify(initiator);</span><br><span class="line">            initiator = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//便利订阅者集合</span></span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="built_in">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">            </span><br><span class="line">                considerNotify(iterator.next().getValue());</span><br><span class="line">                <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">    mDispatchingValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>便利订阅者集合，进行分发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">considerNotify</span><span class="params">(ObserverWrapper observer)</span> &#123;</span><br><span class="line">    <span class="comment">//如果改订阅者不活跃，直接过滤</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">    <span class="comment">// the observer moved to an active state, if we&#x27;ve not received that event, we better not</span></span><br><span class="line">    <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">    <span class="comment">//如果不是onResume状态</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过version判断是否是最新数据</span></span><br><span class="line">    <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    <span class="comment">//执行分发逻辑</span></span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在active的生命周期下，如果是onResume状态且是最新数据，则进行数据分发，否则，进入activeStateChanged方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">activeStateChanged</span><span class="params">(<span class="type">boolean</span> newActive)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// immediately set active state, so we&#x27;d never dispatch anything to inactive</span></span><br><span class="line">        <span class="comment">// owner</span></span><br><span class="line">        mActive = newActive;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasInactive</span> <span class="operator">=</span> LiveData.<span class="built_in">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">        LiveData.<span class="built_in">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">            onActive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (LiveData.<span class="built_in">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">            onInactive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">            <span class="comment">//调用具体分发逻辑</span></span><br><span class="line">            dispatchingValue(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当不是active状态下，则不会进行分发处理，当页面从后台回到前台时，也会触发该方法，那么会取最新的mData并分发给该页面。</p><p>如果是post请求，会通过handler传递到主线程，调用setvalue方法，所有的回掉，observer方法都是在主线程中的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;ViewModel&quot;&gt;&lt;a href=&quot;#ViewModel&quot; class=&quot;headerlink&quot; title=&quot;ViewModel&quot;&gt;&lt;/a&gt;ViewModel&lt;/h2&gt;&lt;h4 id=&quot;ViewModel的定义&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android大厂面试题</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/Android%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/Android%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-05-31T12:53:14.000Z</published>
    <updated>2023-12-19T06:50:38.177Z</updated>
    
    <content type="html"><![CDATA[<p>京1:</p><ol><li>butterknife原理，R2文件？</li><li>Handler异步消息，同步屏障？同步消息？looper.perpare()何时创建？message.obtain()?</li><li>Vsync，垂直同步信号？</li><li>UI滑动渲染优化？</li><li>内存泄漏？leakcarray原理？</li><li>oom的条件？<ol><li>开辟多个线程导致oom？</li></ol></li><li>bitmap的存储形式在系统中的存储？存储在哪？</li><li>布局优化？LinearLayout   draw几次？</li><li>IPC机制，binder机制的理解？为什么使用线程池？（一个服务端对多个客户端）</li><li>flutter渲染机制？flutter的树？</li></ol><p>京2:</p><ol><li>移动端自动化开发</li><li>EventBus原理？优点？缺点？切换线程的方式</li><li>ViewModel+LiveData</li><li>音箱和手机的差异化？android版本，厂商room，客户群体不同</li><li>apk瘦身？</li><li><strong>启动优化的时间检测？启动器优化方式</strong></li><li>组件化？如何设计一个组件</li></ol><p>小米1：</p><ol><li><p>Activity的生命周期？activityA在下拉框的时候的生命周期？（不变化）onDestory有立即执行吗？</p></li><li><p>activity启动后在最后一帧绘制在哪？</p></li><li><p>android启动打点？AOP？启动优化？开启一个线程？AMS，反射？如何对函数进行插桩？</p><p>ASM对.class文件修改，生成.dex文件前搞定，在.class和.dex文件转化中间作修改</p></li><li><p>leakcanary原理？自己如何做内存泄漏器？各个函数之间的耗时情况？</p></li><li><p>亮点？有向无环图？contentprovider的初始化？</p></li><li><p>Handler内存泄漏的原因？怎么处理？handler持有Activity强引用，messageQueue持有handler的强引用</p></li><li><p>view的绘制？dispatchDraw()和onDraw()的执行顺序？</p></li><li><p>如果绘制一个圆，保证这个圆的中间不被绘制？cavas进行裁剪，画布上就缺一块，则子view绘制不上</p></li><li><p>view的事件分发？如果dispatch返回true，会拦截到onInterrcept和onTouch</p></li><li><p>bitmap的优化？bitmap的大小的计算？2x的大小图片放大1x的图片中，bitmap会变大</p></li><li><p>线程池？阻塞的处理？exectue和submit的区别，如何捕获线程池错误（ThreadFactory）</p></li><li><p>生产者消费者通知？</p></li><li><p>线程同步？加锁，Sychronized，ReentrantLock</p></li><li><p>Hashmap，hash值计算？为什么这么计算？arraymap和hashmap？</p></li><li><p>数组和链表的区别？</p></li><li><p>https加密形式</p></li></ol><p>小米2面：</p><ol><li>启动优化？bitmap预加载？如何更快加载图片？还有别的什么优化？</li><li>Glide的into方法是怎么执行的，如何显示到imageView中的？</li><li>Glide的加载流程？fragment如何绑定？imageView正在加载，再次加载另一个图片，具体会执行什么？</li><li>Android启动流程？Activity启动流程？</li><li>ViewModel？LiveData的理解 ？mvvm的理解？</li><li>网络请求异步框架？线程池？</li><li>链表反转（逆置）</li></ol><p>Yy1:</p><ol><li><p>okhttp io的方式？okio，java中io的方式？责任链模式？连接池复用？</p></li><li><p>Glide的缓存结构？为什么要用activieResource？</p></li><li><p>EventBus的简述？字节码&#x3D;.class文件，注解方式？</p></li><li><p>RecyclerView缓存形式？</p></li><li><p>MotionLayout的内部原理</p></li><li><p>Mvvm需要注意什么？内存泄漏？持有view的引用</p></li><li><p>leakCanary原理，gc间隔&#x3D;5s，在idleHandler中使用延迟5s的操作，大概是主线程闲置后在等待5s中进行验证后执行gc？Fragment怎么监听内存泄漏的？fragmentManager.registerFragmentLifecycleCallbacks中检测</p></li><li><p>apk瘦身？so库合并</p><p>先把所有要打包的库编译生成静态库，然后使用如下命令把它们合并成一个*.so:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o c.so -Wl,--whole-archive a.a b.a -Wl,--no-whole-archive</span><br></pre></td></tr></table></figure></li><li><p>启动优化？其他的优化框架，</p></li><li><p>线程，进程，协程？时间分片？协程是怎么做的？那个io？</p></li><li><p>handler机制？子线程中如何使用handler？handler中的Looper.prepareMain和Looper.prepare的区别？主线程永不退出，死循环？同步屏障？</p></li></ol><p>Yy2:</p><ol><li>音频协议？</li><li>协程，进程，线程的区别？</li><li>mvvm？组件化？</li><li>websocket协议和http协议的区别？</li><li>butterknife原理？注解的三种形式？</li><li>动态代理的方式？2中？动态代理的关联？</li><li>类型擦出？范性？</li><li>类加载过程？类什么时候初始化？静态类的初始化过程？</li><li>编译器优化？</li><li>GCroot？栈溢出？（递归）</li><li>java异常有几种？可以捕获oom异常吗？可以，在bitmap中如果触发oom可以进行try catch</li><li>动画？差值器，估值器？</li><li>二叉树之字形打印</li></ol><p>581:</p><ol><li><p>组件化ARouter框架原理？</p><p>编译时注解生成类文件，存储全局路由管理，通过反射创建对象。</p><p>如果是Activity，通过Intent进行跳转传参，Fragment，BroadCastReceiver，Service等都是通过反射创建对象的</p></li><li><p>LiveData，viewModel机制，如何绑定生命周期，viewModel中持久化是怎么做的，LiveData中的粘性事件</p><p>粘性事件是通过版本号控制的，当进入active状态后，会比对version版本，进行订阅者的通知</p></li><li><p>Activity的启动过程</p></li><li><p>RecyclerView机制</p></li><li><p>Handler机制</p></li><li><p>java中锁的机制，volatile的可见性怎么理解？Synchronized怎么理解？自旋锁怎么理解？ReentrantLock怎么理解？</p></li><li><p>kotlin中的协程？</p><p>kotlin中协程通过挂起函数来实现协程的处理，使用CPS变换，suspend</p><p>每个挂起函数都会被编译为Continuation ，将函数体编译为状态机</p></li><li><p>ASM</p></li><li><p>flutter理解？fish-redux的分层？数据流向？</p><p>view—–&gt;action—-&gt;effect—–&gt;reducer—–&gt;store—–&gt;view</p></li></ol><p>58 2:</p><ol><li>项目相关。。。</li></ol><p>36012:</p><ol><li><p>Fragment切换，add和replace，复用的问题？</p></li><li><p>Fragment可见性准确保证？</p></li><li><p>Fragment构造传参的劣势？</p><p>在Activity异常退出重建Fragment的时候，会执行Fragment的无参构造方法，如果通过setArguments进行传递参数，Activity在构造Fragment时会通过反射午餐构造实力</p></li><li><p>内联优化？</p></li><li><p>aapt1和aapt2的区别</p><p>aapt1进行全量编译</p><p>aapt2进行差量编译</p></li><li><p>垃圾加载的GC root</p></li><li><p>LRU算法怎么实现的</p></li><li><p>java中的容器有哪些？线程安全的有哪些？</p><p>Vector   与ArrayList几乎相同，但是线程安全</p><p>Stack     继承自Vector</p><p>CopyOnWriteArrayList 写实拷贝</p><p>ConcurrentLinkedQueue　基础链表同步队列</p><p>LinkedBlockingQueue</p><p>HashTable</p><p>ConcurrentHashMap</p></li></ol><p>58 3:</p><ol><li>对排序？</li><li>http请求过程，https的过程</li><li>数组和链表的区别</li><li>栈中调用方法的过程</li><li>LRU算法的实现</li></ol><p>美团 1:</p><p>携程 1:</p><p>快手 1:</p><p>知乎 1:</p><ol><li>Activity的生命后期</li><li>onConfigurationChanged？其他回掉时机？onSaveInstanceState回调？分屏？</li><li>ARouter？</li><li>Fragment的生命周期？onCreateView可以返回null吗？</li><li>fragment怎么初始化？fragment为什么不推荐携带参数？androidx中提供fragment传参？Fragment重建？</li><li>viewModel持久化？viewmodel重建？可以存储Bundle？</li><li>java内存模型？volatile原理？可见性，非原子性，禁止指令重排</li><li>组件化开发？</li><li>二叉树镜像？</li></ol><p>知乎 2:</p><ol><li>mvvm的理解</li><li>离开公司的原因</li><li>未来的方向，2c方向，架构方向</li><li>架构师主要负责，技术选型</li><li>为什么选择知乎？</li><li>知乎界面的分析+选型+排期</li><li>你的优势，为什么给你发offer？</li><li>android启动器？线程池选型？</li><li>大文件查找方案？</li><li>整数的逆置，头和尾是0的情况排除</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;京1:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;butterknife原理，R2文件？&lt;/li&gt;
&lt;li&gt;Handler异步消息，同步屏障？同步消息？looper.perpare()何时创建？message.obtain()?&lt;/li&gt;
&lt;li&gt;Vsync，垂直同步信号？&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>面试指南</title>
    <link href="http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2021/05/31/%E7%A7%BB%E5%8A%A8%E7%AB%AF/Android%E5%8E%9F%E7%94%9F/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/</id>
    <published>2021-05-31T12:47:57.000Z</published>
    <updated>2023-12-19T06:50:38.182Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="框架篇"><a href="#框架篇" class="headerlink" title="框架篇"></a>框架篇</h1><h2 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h2><h4 id="简述EventBus的理解"><a href="#简述EventBus的理解" class="headerlink" title="简述EventBus的理解"></a>简述EventBus的理解</h4><p>EventBus作为通信事件传递的总线，你无需控制值的传递，也无需通过广播等低效实现，通过EventBus在你需要发送的地方post信息，在你需要接收的地方接收信息处理即可，（前提是register过）</p><h4 id="EventBus的五种线程模式"><a href="#EventBus的五种线程模式" class="headerlink" title="EventBus的五种线程模式"></a>EventBus的五种线程模式</h4><ul><li><strong>POSTING</strong>：默认，发布和订阅在同一个线程，同发布者一个线程（主—&gt;主 , 子—&gt;子），最小的开销，因为不用切换线程，避免了线程的完全切换，使用此模式的事件处理程序必须快速返回，以避免阻塞可能是主线程的发布线程。</li><li><strong>MAIN</strong>：事件处理函数的线程在主线程（UI）线程。不能进行<code>耗时</code>操作，订阅者需快速返回以免阻塞主线程</li><li><strong>MAIN_ORDERED</strong>:事件处理函数的线程在主线程（UI）线程。不会阻塞线程</li><li><strong>BACKGROUND</strong>：处理函数在后台线程，不能进行UI操作。发布在主线程，订阅会开启一个新的后台线程。发布在后台线程，事件处理函数也在该后台线程</li><li><strong>ASYNC</strong>：无论事件发布的线程是哪一个，都会重新开辟一个新的子线程运行，不能进行UI操作</li></ul><h4 id="EventBus的事件类型"><a href="#EventBus的事件类型" class="headerlink" title="EventBus的事件类型"></a>EventBus的事件类型</h4><p>接收事件必须是public修饰符修饰，不能用static关键字修饰，不能是抽象的（abstract）</p><ol><li>普通事件：先订阅在发布，发布到订阅者后进行处理</li><li>粘性事件：支持先发布在订阅，当订阅者订阅后会自动发送到订阅者进行处理，发送粘性事件EventBus.postSticky()，接收粘性事件sticky &#x3D; true</li></ol><h4 id="为什么必须是public？"><a href="#为什么必须是public？" class="headerlink" title="为什么必须是public？"></a>为什么必须是public？</h4><p>因为源码定义</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>优先级高的订阅者优先接收到任务</p><h4 id="简述源码分析事件"><a href="#简述源码分析事件" class="headerlink" title="简述源码分析事件"></a>简述源码分析事件</h4><ul><li>register：通过注解初始化订阅方法后，在register后，在缓存中获取所有该订阅者的方法，循环遍历订阅，新建newSubscription方法，根据priority优先级将newSubscription方法放入subscriptions中，判断如果<code>是粘性事件</code>，则执行其对应的订阅方法。</li><li>unregister：从typesBySubscriber获取订阅事件类型，根据订阅事件类型从subscriptionsByEventType获取订阅者信息，将subscription的active置为false，并移除该subscription</li></ul><h4 id="索引如何理解？"><a href="#索引如何理解？" class="headerlink" title="索引如何理解？"></a>索引如何理解？</h4><p>EventBus 3.0以后，采用Subscribe注解配置事件订阅方法，采用反射的方式来查找订阅事件的方法，我们都知道反射对性能是有影响的，所以提出了索引的概念。</p><p>在项目编译时，通过配置，生成一个辅助类用来存储订阅信息，原理是HashMap，存储注册类的class类型和事件订阅方法的信息，提高速度3-4倍</p><h4 id="MAIN和MAIN-ORDERED的区别？"><a href="#MAIN和MAIN-ORDERED的区别？" class="headerlink" title="MAIN和MAIN_ORDERED的区别？"></a>MAIN和MAIN_ORDERED的区别？</h4><ol><li><p>在<code>MAIN</code>模式下，如果事件发布者post事件也是在主线程的话，会阻塞post事件所在的线程，意思是连续post多个事件，如果接收事件方法执行完，才能post下一个事件</p><pre><code>  **post(1) ——&gt; onReceiveMsg(1) ——&gt;post(2)——&gt;onReceiveMsg(2)——&gt;post(3)——&gt;onReceiveMsg(3)**</code></pre></li><li><p>如果事件发布者post事件不在主线程，连续post多个事件，同时在主线程是接收事件是耗时操作的话，执行的流程是非阻塞的</p><pre><code>  **post（1）——&gt;post（2）——&gt;psot(3)——&gt;onReceiveMsg(3)**  或  **post（1）——&gt;post（2）——&gt;psot(3)——&gt;onReceiveMsg(2)——&gt;onReceiveMsg(3)**</code></pre></li><li><p>MAIN_ORDERED模式下，无论什么场景都是非阻塞的</p></li></ol><h4 id="EventBus可否跨进程问题？"><a href="#EventBus可否跨进程问题？" class="headerlink" title="EventBus可否跨进程问题？"></a>EventBus可否跨进程问题？</h4><p>不能，单进程间通信</p><p>HermesEventBus——&gt;饿了吗开发框架，可应用于单进程和多进程。</p><p>使用IPC机制，首先选择一个主进程，其他则为子进程，每一个event会经过4步：</p><ol><li>使用Hermes库将event传递给主进程。</li><li>主进程使用EventBus在主进程内部发送event。</li><li>主进程使用Hermes库将event传递给所有的子进程。</li><li>每个子进程使用EventBus在子进程内部发送event。</li></ol><h4 id="BackgroundThread和Async区别"><a href="#BackgroundThread和Async区别" class="headerlink" title="BackgroundThread和Async区别"></a>BackgroundThread和Async区别</h4><p>BackgroundThread：发布在主线程，新开辟子线程中执行。发布在子线程，则在子线程中执行，这个子线程是阻塞式的,按顺序交付所有事件，所以也不适合做耗时任务，因为多个事件共用这一个后台线程</p><p>Async：无论发布在哪一个线程，都会在重新开辟一个子线程执行</p><h4 id="EventBus的优缺点："><a href="#EventBus的优缺点：" class="headerlink" title="EventBus的优缺点："></a>EventBus的优缺点：</h4><p><code>优点</code>:<br>EventBus是greenrobot公司出的另一款开源框架，这个框架是针对Android优化的发布&#x2F;订阅事件总线，使用EventBus可以极大的减少我们程序的耦合度。<br>调度灵活。不依赖于 Context，使用时无需像广播一样关注 Context 的注入与传递。<br>使用简单。<br>快速且轻量。<br>完全解耦了请求链之间的关系，避免了请求者被长持有，<br>比广播更轻量<br>可以定义在调用线程、主线程、后台线程、异步。</p><p>粘性事件</p><p>优先级概念</p><p>为了避免频繁的向主线程 <code>sendMessage()</code>(Handler机制)，EventBus 的做法是在一个消息里尽可能多的处理更多的消息事件，所以使用了 while 循环，持续从消息队列 queue 中获取消息。</p><p>同时为了避免长期占有主线程，间隔 10ms （maxMillisInsideHandleMessage &#x3D; 10ms）会重新发送 <code>sendMessage()</code>，用于让出主线程的执行权，避免造成 UI 卡顿和 ANR。</p><p><code>缺点</code>:<br>各种Event的定义工作量大。每次传的内容不一样,就需要重新定义一个JavaBean</p><p>单向传播</p><p>需要显性注册</p><h4 id="EventBus如何做到线程切换"><a href="#EventBus如何做到线程切换" class="headerlink" title="EventBus如何做到线程切换"></a>EventBus如何做到线程切换</h4><p><a href="https://blog.csdn.net/u010457514/article/details/101771245">EventBus发送的消息，如何做到线程切换？</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="type">boolean</span> isMainThread)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> POSTING:</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MAIN:</span><br><span class="line">                <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">                <span class="keyword">if</span> (mainThreadPoster != <span class="literal">null</span>) &#123;</span><br><span class="line">                    mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// temporary: technically not correct as poster not decoupled from subscriber</span></span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">                <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                    backgroundPoster.enqueue(subscription, event);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    invokeSubscriber(subscription, event);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ASYNC:</span><br><span class="line">                asyncPoster.enqueue(subscription, event);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unknown thread mode: &quot;</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要分为主线程执行和子线程执行，当为主线程时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerPoster</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> <span class="keyword">implements</span> <span class="title class_">Poster</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxMillisInsideHandleMessage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> handlerActive;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">HandlerPoster</span><span class="params">(EventBus eventBus, Looper looper, <span class="type">int</span> maxMillisInsideHandleMessage)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(looper);</span><br><span class="line">        <span class="built_in">this</span>.eventBus = eventBus;</span><br><span class="line">        <span class="built_in">this</span>.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">PendingPostQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Subscription subscription, Object event)</span> &#123;</span><br><span class="line">        <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            <span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">                handlerActive = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Could not send handler message&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rescheduled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">started</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="comment">//循环处理消息事件，避免重复sendMessage()</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                        <span class="comment">// Check again, this time in synchronized</span></span><br><span class="line">                        pendingPost = queue.poll();</span><br><span class="line">                        <span class="keyword">if</span> (pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">                            handlerActive = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                <span class="type">long</span> <span class="variable">timeInMethod</span> <span class="operator">=</span> SystemClock.uptimeMillis() - started;</span><br><span class="line">                <span class="comment">//避免长期占用主线程，间隔10ms重新sendMassage()</span></span><br><span class="line">                <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EventBusException</span>(<span class="string">&quot;Could not send handler message&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    rescheduled = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            handlerActive = rescheduled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用HandlerPoster将任务通过sendMessage方法发送到主线程执行，通过消息队列存储该handler的任务，通过10ms发送一次任务，防止主线程卡顿，MAIN情况下，如果在主线程，直接执行。MAIN_ORDER的情况下，全部交给handler异步执行，所以区别于MAIN不是同步的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BackgroundPoster</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>, Poster &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> executorRunning;</span><br><span class="line"></span><br><span class="line">    BackgroundPoster(EventBus eventBus) &#123;</span><br><span class="line">        <span class="built_in">this</span>.eventBus = eventBus;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">PendingPostQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Subscription subscription, Object event)</span> &#123;</span><br><span class="line">        <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            <span class="keyword">if</span> (!executorRunning) &#123;</span><br><span class="line">                executorRunning = <span class="literal">true</span>;</span><br><span class="line">                eventBus.getExecutorService().execute(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> queue.poll(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">if</span> (pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                            <span class="comment">// Check again, this time in synchronized</span></span><br><span class="line">                            pendingPost = queue.poll();</span><br><span class="line">                            <span class="keyword">if</span> (pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">                                executorRunning = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + <span class="string">&quot; was interruppted&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorRunning = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncPoster</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>, Poster &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"></span><br><span class="line">    AsyncPoster(EventBus eventBus) &#123;</span><br><span class="line">        <span class="built_in">this</span>.eventBus = eventBus;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">PendingPostQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Subscription subscription, Object event)</span> &#123;</span><br><span class="line">        <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        eventBus.getExecutorService().execute(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PendingPost</span> <span class="variable">pendingPost</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No pending post available&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子线程执行是通过线程池进行管理，内部也存在一个消息队列，按顺序执行任务，对于BACKGROUND情况下，同时只会使用线程池中的一个线程，而Async直接放入线程池，让线程池去规划线程。当线程池中等待任务过多时，会触发oom（线程池是newCachedThreadPool()，则线程为非核心线程MAX）</p><h4 id="粘性事件的原理"><a href="#粘性事件的原理" class="headerlink" title="粘性事件的原理"></a>粘性事件的原理</h4><p>普通事件是先注册后发布，而粘性事件可以先发布后注册，实现方式上是这样的：</p><p>发送时会将粘性事件的事件类型和对应事件保存起来，在执行post方法，在注册后，如果是粘性事件，会多走一步类似于post的方法，触发进行分发</p><h4 id="如何判断当前线程是否为主线程？"><a href="#如何判断当前线程是否为主线程？" class="headerlink" title="如何判断当前线程是否为主线程？"></a>如何判断当前线程是否为主线程？</h4><p>在发布事件的地方判断发送线程和主线程的Looper对象是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Looper.getMainLooper() == Looper.myLooper();</span><br></pre></td></tr></table></figure><h4 id="如何优化EventBus"><a href="#如何优化EventBus" class="headerlink" title="如何优化EventBus"></a>如何优化EventBus</h4><ol><li>尽量使用索引功能，避免不必要的反射，提升性能</li><li>增加EventBus的进程间通信</li></ol><h4 id="为什么使用ConcurrentHashMap保存数据"><a href="#为什么使用ConcurrentHashMap保存数据" class="headerlink" title="为什么使用ConcurrentHashMap保存数据"></a>为什么使用ConcurrentHashMap保存数据</h4><p><a href="#ConcurrentHashMap%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB">ConcurrentHashMap和HashMap的区别</a></p><p>因为EventBus是单进程、多线程间通信，可能涉及到线程安全问题，使用ConcurrentHashMap可以有效解决线程安全和效率。</p><h2 id="Okhttp3"><a href="#Okhttp3" class="headerlink" title="Okhttp3"></a>Okhttp3</h2><p><img src="/imageMd/okhttp-1.png" alt="okhttp3"></p><h4 id="简述OkHttp"><a href="#简述OkHttp" class="headerlink" title="简述OkHttp"></a>简述OkHttp</h4><p>是基于Socket的封装，主要有三个类：Response、Request、Call</p><p>同步使用client.excute();  异步使用client.enqueue();</p><p>OkHttp的高效在于内部有一个Dispatcher，是okhttp维护的一个线程池，对最大连接数（并发），host最大访问量做了定义，维护了3个队列（同步正在执行，准备执行，异步正在执行）和一个线程池（0~max）</p><p>内部还维护了连接池，实现了复用机制，减少重复握手</p><p>提供缓存机制。</p><h4 id="有几个拦截器，分别是干什么的？"><a href="#有几个拦截器，分别是干什么的？" class="headerlink" title="有几个拦截器，分别是干什么的？"></a>有几个拦截器，分别是干什么的？</h4><p><code>client.intercepters()：应用拦截器</code></p><p>RetryAndFollowUpIntercepter：重试和重定向机制，最大重试次数为20，构造StreamAllocation，创建缓存池，复用</p><p>BridgeIntercepter：将用户构造的请求转化为服务器识别的请求，将服务器返回的响应转化为用户识别的响应，添加keep-alive，供连接池复用</p><p>CacheIntercepter：缓存读取和更新</p><p>ConnectIntercepter：dns解析与服务器建立连接(握手结束)，它利用 Okio 对 Socket 的读写操作进行封装，它对 java.io 和 java.nio 进行了封装，让我们更便捷高效的进行 IO 操作</p><p><code>client.networkIntercepter：网络拦截器</code></p><p>CallServerIntercepter：最后一个拦截器，负责向服务器发送请求和接收服务器的响应</p><p>采用责任链模式，将请求和发送分别处理，并且可以动态添加中间的处理方实现对请求的处理、短路等操作。</p><p>addNetworkInterceptor() （网络拦截器）和addInterceptor() （应用拦截器）</p><p>区别就是一个靠前一个靠后，其中经过的拦截器会导致不一样的结果</p><p><a href="https://www.cnblogs.com/liyutian/p/9489016.html">自定义拦截器区别</a></p><h4 id="RetryAndFollowUpIntercepter中怎么进行重定向？"><a href="#RetryAndFollowUpIntercepter中怎么进行重定向？" class="headerlink" title="RetryAndFollowUpIntercepter中怎么进行重定向？"></a>RetryAndFollowUpIntercepter中怎么进行重定向？</h4><p>最大重试次数为20次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> HTTP_PERM_REDIRECT:<span class="comment">//307</span></span><br><span class="line"><span class="keyword">case</span> HTTP_TEMP_REDIRECT:<span class="comment">//308</span></span><br><span class="line">  <span class="comment">// &quot;If the 307 or 308 status code is received in response to a request other than GET</span></span><br><span class="line">  <span class="comment">// or HEAD, the user agent MUST NOT automatically redirect the request&quot;</span></span><br><span class="line">  <span class="keyword">if</span> (!method.equals(<span class="string">&quot;GET&quot;</span>) &amp;&amp; !method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// fall-through</span></span><br><span class="line"><span class="keyword">case</span> HTTP_MULT_CHOICE:<span class="comment">//300</span></span><br><span class="line"><span class="keyword">case</span> HTTP_MOVED_PERM:<span class="comment">//301</span></span><br><span class="line"><span class="keyword">case</span> HTTP_MOVED_TEMP:<span class="comment">//302</span></span><br><span class="line"><span class="keyword">case</span> HTTP_SEE_OTHER:<span class="comment">//303</span></span><br><span class="line">  <span class="comment">// Does the client allow redirects?</span></span><br><span class="line">  <span class="keyword">if</span> (!client.followRedirects()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> userResponse.header(<span class="string">&quot;Location&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (location == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="type">HttpUrl</span> <span class="variable">url</span> <span class="operator">=</span> userResponse.request().url().resolve(location);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don&#x27;t follow redirects to unsupported protocols.</span></span><br><span class="line">  <span class="keyword">if</span> (url == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If configured, don&#x27;t follow redirects between SSL and non-SSL.</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">sameScheme</span> <span class="operator">=</span> url.scheme().equals(userResponse.request().url().scheme());</span><br><span class="line">  <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Most redirects don&#x27;t include a request body.</span></span><br><span class="line">  Request.<span class="type">Builder</span> <span class="variable">requestBuilder</span> <span class="operator">=</span> userResponse.request().newBuilder();</span><br><span class="line">  <span class="keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">maintainBody</span> <span class="operator">=</span> HttpMethod.redirectsWithBody(method);</span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">      requestBuilder.method(<span class="string">&quot;GET&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">RequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> maintainBody ? userResponse.request().body() : <span class="literal">null</span>;</span><br><span class="line">      requestBuilder.method(method, requestBody);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!maintainBody) &#123;</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>);</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>);</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// When redirecting across hosts, drop all authentication headers. This</span></span><br><span class="line">  <span class="comment">// is potentially annoying to the application layer since they have no</span></span><br><span class="line">  <span class="comment">// way to retain them.</span></span><br><span class="line">  <span class="keyword">if</span> (!sameConnection(userResponse, url)) &#123;</span><br><span class="line">    requestBuilder.removeHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> requestBuilder.url(url).build();</span><br></pre></td></tr></table></figure><p>如果返回响应code是307和308，则只对get和head类型的请求进行重定向。<br>如果返回请求为PROPFIND，则重新发送的请求都为保持原状，如果不是propFind，则重新请求的都会被设置为<code>get</code>请求，且请求信息为空</p><blockquote><p>RetryAndFollowUpInterceptor的intercept中先是创建了StreamAllocation对象，然后开启while(true)无限循环。接着在这个循环中先调用下层拦截器去网络请求，若请求期间发生异常，判断能否重试，能就continue进行下一轮循环，否则抛异常退出循环结束方法。如果下层拦截器请求完成返回response，通过response的状态码判断是否需要重定向，若需要重定向，修改request后进行下一轮循环，否则返回response结束方法。</p></blockquote><h4 id="什么是连接池？"><a href="#什么是连接池？" class="headerlink" title="什么是连接池？"></a>什么是连接池？</h4><p>OkHttp的底层是通过Java的Socket发送HTTP请求与接受响应的(这也好理解，HTTP就是基于TCP协议的)，但是OkHttp实现了连接池的概念，</p><p>即对于同一主机的多个请求，其实可以公用一个Socket连接，而不是每次发送完HTTP请求就关闭底层的Socket，这样就实现了连接池的概念。</p><h4 id="简述连接池的复用？"><a href="#简述连接池的复用？" class="headerlink" title="简述连接池的复用？"></a>简述连接池的复用？</h4><p>okhttp中所有的请求都被抽象为RealConnection，而ConnectionPool就是管理这些connection的，共享一个Address的链接可以复用</p><p>ConnectionPool，默认大小是5，每个链接存储5分钟，使用keep-alive，达到久连接，所以默认keep-alive是5分钟，也可以自定义</p><p>excutor：线程池，监测时间并释放连接的后台线程</p><p>connections：缓存池。是一个双端列表，这里用作栈</p><p>routeDatabase：记录连接失败router（路由）</p><p>使用put方法将连接放入缓存池，并清除闲置的线程，对缓存池进行排序（对比最大闲置时间），使用StreamAllocation复用请求</p><p>StreamAllocation的初始化在RetryAndFllowUpIntercepter。</p><p>在StreamAllocation调用newStream进行初始化，其中使用get方法在缓存池中查找相同的请求，如果找到就复用这条请求，没找到就新建连接并put到缓存池</p><blockquote><p>连接池的工作就这么多，并不负责，主要就是管理双端队列Deque<RealConnection>，可以用的连接就直接用，然后定期清理连接，同时通过对StreamAllocation的引用计数实现自动回收。</p></blockquote><h4 id="简述StreamAllocation"><a href="#简述StreamAllocation" class="headerlink" title="简述StreamAllocation"></a>简述StreamAllocation</h4><p>StreamAllocation是用来协调connections，stream和Call(请求)的。</p><p>HTTP通信执行网络请求<code>Call</code>需要在连接<code>Connection</code>上建立一个新的流<code>Stream</code>，我们将<code>StreamAllocation</code>称之流 的桥梁，它负责为一次<code>请求</code>寻找<code>连接</code>并建立<code>流</code>，从而完成远程通信。</p><p>其初始化在RetryAndFllowUpIntercepter，再次使用在CallServerInterceptor，复用机制使用该方法调用，减少一个三次握手的时间（不需要握手）</p><h4 id="OKIO的优势"><a href="#OKIO的优势" class="headerlink" title="OKIO的优势"></a>OKIO的优势</h4><ol><li>更加轻便，速度更快，使用更快</li><li>实现缓存结构，对cpu和内存进行优化，避免频繁gc（Segment链表实现）</li><li>功能强大，支持阻塞和非阻塞IO</li><li>支持多种类型，想比较于java.io和java.nio，不需要庞大的装饰类</li></ol><h4 id="Dispatcher的理解"><a href="#Dispatcher的理解" class="headerlink" title="Dispatcher的理解"></a>Dispatcher的理解</h4><p><img src="/imageMd/okhttp-2.png" alt="img"><br>内部维护了三个队列，分别为：</p><ul><li>runningAsyncCalls：正在请求的异步队列</li><li>readyAsyncCalls：准备请求的异步队列\等待请求的异步队列</li><li>runningSyncCalls：正在请求的同步队列</li></ul><blockquote><p>maxRequest：默认64。这是okhttp允许的最大请求数量。<br>maxRequestsPerHost ：默认5。这是okhttp对同一主机允许的最大请求数量。</p></blockquote><p><strong>同步执行源码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">  <span class="comment">//此处除去一些其他代码</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//通知Dispatcher这个Call正在被执行,同时将此Call交给Dispatcher</span></span><br><span class="line">    <span class="comment">//Dispatcher可以对此Call进行管理</span></span><br><span class="line">    client.dispatcher().executed(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">//请求的过程，注意这行代码是阻塞的，直到返回result！</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">result</span> <span class="operator">=</span> getResponseWithInterceptorChain();</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//此时这个请求已经执行完毕了，通知Dispatcher，不要再维护这个Call了</span></span><br><span class="line">    client.dispatcher().finished(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try 中的return执行完成后，执行finally语句，所以不论请求成功或者失败，都会关闭这个请求</p><p><strong>异步执行源码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Callback responseCallback)</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">  <span class="comment">//判断是否已经执行过了</span></span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">    executed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//捕获调用栈的信息，用来分析连接泄露</span></span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  <span class="comment">//封装一个AsyncCall交给Dispatcher调度</span></span><br><span class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> <span class="title class_">AsyncCall</span>(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(AsyncCall call)</span> &#123;</span><br><span class="line">  <span class="comment">//判断正在执行的异步请求数没有达到阈值，并且每一个Host的请求数也没有达到阈值</span></span><br><span class="line">  <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">    <span class="comment">//加入到正在执行队列，并立即执行</span></span><br><span class="line">    runningAsyncCalls.add(call);</span><br><span class="line">    executorService().execute(call);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//加入到等待队列</span></span><br><span class="line">    readyAsyncCalls.add(call);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简述OKhttp的缓存机制"><a href="#简述OKhttp的缓存机制" class="headerlink" title="简述OKhttp的缓存机制"></a>简述OKhttp的缓存机制</h4><p>okhttp有具备网络缓存机制，短时间内重复请求会复用缓存的数据，这样节省流量，应用也会很流畅。但是okhttp本身默认是不打开缓存机制的，需要配置后才能启动。</p><p>okhttp的缓存机制是以DiskLruCache（最近最少使用算法（Least recently used））为基础的，仅支持文件存储。</p><p>MD5(url)作为key，value是存储的服务端响应数据</p><p>默认不开启缓存机制</p><p>文件存储</p><p>DiskLruCache写入是依赖于okio的，内部实现类似于LinkedHashMap，键值对获取。</p><p>使用DiskLruCache，仅支持get请求的缓存</p><ol><li>如果服务器支持缓存，即response携带Cache-control属性，则当你打开okhttp缓存即开始缓存，通过属性控制类型</li><li>如果服务器不支持缓存或者okhttp不想按照服务器缓存策略来存储，通过自定义拦截器重写response的头部即可</li><li>客户端不支持缓存，则可以不缓存，不理会服务器的cache-control属性</li></ol><p>可以直接使用CacheControl类，包含</p><ul><li><strong>CacheControl.FORCE_NETWORK</strong>，即强制使用网络请求</li><li><strong>CacheControl.FORCE_CACHE</strong>，即强制使用本地缓存，如果无可用缓存则返回一个code为504的响应</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</span><br><span class="line">no-cache：不做缓存。</span><br><span class="line">max-age：这个参数告诉浏览器将页面缓存多长时间，超过这个时间后才再次向服务器发起请求检查页面是否有更新。对于静态的页面，比如图片、CSS、Javascript，一般都不大变更，因此通常我们将存储这些内容的时间设置为较长的时间，这样浏览器是不会向服务器反复发起请求，也不会去检查是否更新了。</span><br></pre></td></tr></table></figure><p>添加自定义网络拦截器，在其中改变Response的响应头，添加Cache-control，后续回到CacheIntercepter中时，就会执行缓存策略。</p><p>CacheControl.Builder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- noCache();<span class="comment">//不使用缓存，用网络请求</span></span><br><span class="line">- noStore();<span class="comment">//不使用缓存，也不存储缓存</span></span><br><span class="line"></span><br><span class="line">- onlyIfCached();<span class="comment">//只使用缓存</span></span><br><span class="line">- noTransform();<span class="comment">//禁止转码</span></span><br><span class="line">- maxAge(<span class="number">10</span>, TimeUnit.MILLISECONDS);<span class="comment">//设置超时时间为10ms。</span></span><br><span class="line">- maxStale(<span class="number">10</span>, TimeUnit.SECONDS);<span class="comment">//超时之外的超时时间为10s</span></span><br><span class="line">- minFresh(<span class="number">10</span>, TimeUnit.SECONDS);<span class="comment">//超时时间为当前时间加上10秒钟。</span></span><br></pre></td></tr></table></figure><p>CacheStrategy：缓存策略类，通过响应头信息与服务器端信息进行对比，最后返回是否使用新的网络请求还是直接使用缓存。其中存储的是Request请求体和Response响应体的具体内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 如果不使用网络，则 networkRequest为 null */</span></span><br><span class="line"><span class="comment">//客户端请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Request networkRequest;</span><br><span class="line"><span class="comment">/** 如果不使用缓存，则 cacheResponse为 null */</span></span><br><span class="line"><span class="comment">//服务端返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Response cacheResponse;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据输出的networkRequest和cacheResponse的值是否为null给出不同的策略，如下：</p><table><thead><tr><th>networkRequest</th><th>cacheResponse</th><th>result 结果</th></tr></thead><tbody><tr><td>null(不使用网络)</td><td>null（不使用缓存）</td><td>only-if-cached (表明不进行网络请求，且缓存不存在或者过期，一定会返回<strong>503</strong>错误)</td></tr><tr><td>null</td><td>non-null</td><td>不进行网络请求，直接返回缓存，不请求网络</td></tr><tr><td>non-null</td><td>null</td><td>需要进行网络请求，而且缓存不存在或者过去，直接访问网络</td></tr><tr><td>non-null</td><td>non-null</td><td>Header中包含ETag&#x2F;Last-Modified标签，需要在满足条件下请求，还是需要访问网络（根据情况使用）</td></tr></tbody></table><p>如果网络不为null，则使用网络请求，如果网络为null，当缓存不为null，则使用缓存，当缓存为null时，返回503错误</p><h4 id="为什么只做get的缓存？"><a href="#为什么只做get的缓存？" class="headerlink" title="为什么只做get的缓存？"></a>为什么只做get的缓存？</h4><p>其他响应成本大，效率低</p><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>okhttp其中有一个dispatcher对最大连接数（并发），host最大访问量做了定义，维护了3个队列（同步正在执行，准备执行，异步正在执行）和一个线程池（0~max）</p><p>该线程池类似于CachedThreadPool，没有核心线程，全是非核心线程，超时时间是60s，即60s后回收该线程，其队列为空，没有容量，是一种特殊的队列，适用于执行短时的大量任务。</p><h4 id="okhttp的优势？"><a href="#okhttp的优势？" class="headerlink" title="okhttp的优势？"></a>okhttp的优势？</h4><p>最大特点是，intercepter拦截器，连接池复用，okio io处理，线程池处理（全是非核心线程），支持http1.0，1.1，2.0</p><p>okio内部封装链表数据存储，比较之前的数组存储，更加节省空间，还可以复用</p><h4 id="长连接（websocket）和久连接（keep-alive）的区别"><a href="#长连接（websocket）和久连接（keep-alive）的区别" class="headerlink" title="长连接（websocket）和久连接（keep-alive）的区别"></a>长连接（websocket）和久连接（keep-alive）的区别</h4><p>调用的是equeue异步方法，将长连接放入线程池中不会被释放掉</p><ol><li>1.1推出keep-alive机制，服务器不会主动发送请求，一个request返回一个response。</li><li>减少了握手的次数而已</li><li>久连接是同步串行处理的，当某一个请求因为网络，服务器等原因阻塞时，那么后面的请求都得不到处理</li><li>http头部太大，传输耗时</li><li>实时性得不到保证</li></ol><blockquote><p>http是单向的，websocket属于应用层协议，使用http1.1的101码进行握手状态判断</p></blockquote><p>websocket建立连接是使用https连接，三次握手，在通信过程中</p><ul><li>以ws开头</li><li>握手成功后，复用连接发送请求和接收</li><li>不需要发送header信息</li><li>服务端客户端平等，可以相互建立连接，http久连接是基于http的，符合http协议。</li></ul><p>最开始使用<strong>get</strong>请求进行握手，携带Upgrade: websocket ，告知服务器上升为websocket协议，成功后，使用web socket数据流（帧）进行通信，设置超时时间为永不超时，客户端设置循环，一直从服务端取消息。</p><p>使用http的get请求进行3次握手协议，使用http1.1版本的101状态码返回成功后，就不需要http交互了，后续采用web socket流进行通信，减少包体</p><blockquote><p>使用标准的HTTP协议无法实现WebSocket，只有支持那些协议的专门浏览器才能正常工作。</p></blockquote><h4 id="websocket的握手和http的握手有什么区别？"><a href="#websocket的握手和http的握手有什么区别？" class="headerlink" title="websocket的握手和http的握手有什么区别？"></a>websocket的握手和http的握手有什么区别？</h4><p>使用http的get请求进行握手，基本一致，额外传输了header的信息标记为websocket。</p><h4 id="MQTT理解"><a href="#MQTT理解" class="headerlink" title="MQTT理解"></a>MQTT理解</h4><p>发布订阅者模式，低带宽，低开销的即时通信协议，基于tcp&#x2F;ip协议，成为IOT通讯标准</p><p>消息体如下：<strong>固定头部+可变头部+消息体</strong>，整个消息体比较轻便，便于交互及时</p><table><thead><tr><th>固定报头（fixed header）</th><th>可变报头（variable header）</th><th>荷载（payload）</th></tr></thead><tbody><tr><td>所有报文都包含，数据包类型及数据包的分组类标识</td><td>部分报文包含，数据包类型决定了可变头是否存在及其具体内容</td><td>部分报文包含，表示客户端收到的具体内容</td></tr></tbody></table><p>基于二进制实现，MQTT运行于http上，所以明文传输，如果位于https中，则可以使用TLS加密传输</p><p>发布者，订阅者模式：客户端是发布者和订阅者，服务端是代理服务器</p><h4 id="MQTT和websocket的区别？"><a href="#MQTT和websocket的区别？" class="headerlink" title="MQTT和websocket的区别？"></a>MQTT和websocket的区别？</h4><p>MQTT面向原生设备，基于二进制实现，提供一对多的通信方式，采用发布&#x2F;订阅模式传输</p><p>websocket面向web设备，是全双工通信</p><h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>基于Okhttp的RESTFUL Api请求工具，Retrofit可以让你简单到调用一个Java方法的方式去请求一个api，这样App中的代码就会很简洁方便阅读</p><p><img src="/imageMd/retrofit-1.png" alt="img"></p><p>Retrofit通过java接口及注解来描述网络请求，并用动态代理的方式生成网络请求的Request，通过调用相应的网络框架（默认Okhttp）去发起网络请求，并将返回的Response通过converterFactory转化成相应的model，最后通过CallAdapter转换成其他的数据方式（Rxjava Observable）</p><p>Retrofit.create()方法是Retrofit的核心，其中，使用Proxy.newProxyInstance()方法创建ServiceMethod，具体实现是在InvocationHandler类中的invoke方法，实现了动态代理的形式，而这个InvocationHandler对象就是代理对象，这个对象是在运行时动态生成的。</p><h4 id="Retrofit中的动态代理"><a href="#Retrofit中的动态代理" class="headerlink" title="Retrofit中的动态代理"></a>Retrofit中的动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            ...</span><br><span class="line">            ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">            OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> <span class="title class_">OkHttpCall</span>&lt;&gt;(serviceMethod, args);</span><br><span class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过动态代理生成InvocationHandler类，在内部，创建一个ServiceMethod，存储接口的请求信息，构建一个OKhttpCall对象，初始化网络请求</p><h4 id="Retrofit的优势"><a href="#Retrofit的优势" class="headerlink" title="Retrofit的优势"></a>Retrofit的优势</h4><p>Retrofit是对okhttp的二次封装，解决okhttp中接口请求、数据结果返回和接口调用的短板。</p><ol><li>规划了interface接口类，整合所有接口调用的详细内容，便于调用，降低耦合性。</li><li>配合RxJava，okhttp，职责明确。RxJava负责异步处理，Retrofit负责请求的数据和结果的展示，okhttp负责接口请求和返回的具体过程</li></ol><ul><li>Retrofit主要负责应用层面的封装，就是说主要面向开发者，方便使用，比如请求参数，响应数据的处理，错误处理等等。</li><li>OkHttp主要负责socket部分的优化，比如多路复用，buffer缓存，数据压缩等等。</li></ul><ol start="3"><li>相对于okhttp来说，使用动态代理生成Request对象，不用每次调用自己实现</li><li>网络结果线程切换库（RxJava，普通），网络结果格式化库（Gson，xml）等可以做到随意替换和支持</li></ol><h4 id="动态代理和静态代理的区别"><a href="#动态代理和静态代理的区别" class="headerlink" title="动态代理和静态代理的区别"></a>动态代理和静态代理的区别</h4><p>静态代理：<br>由程序员创建或工具生成的代理类，在运行前就存在代理类的字节码文件，代理类和委托类的关系已经确定</p><p>动态代理：<br>在程序运行过程中，通过反射实现对代理类的动态创建，可以代理多个方法。（InvocationHandler、CGLib）</p><h2 id="Butterknife———view的注入"><a href="#Butterknife———view的注入" class="headerlink" title="Butterknife———view的注入"></a>Butterknife———view的注入</h2><h4 id="简述Butterknife"><a href="#简述Butterknife" class="headerlink" title="简述Butterknife"></a>简述Butterknife</h4><p>初始化控件会写大量的findViewById()，setOnClickListener()方法，很繁琐，该框架使用注解的方式实现辅助代码的生成，简化这些代码。</p><p>该框架是基于java注解机制实现的，也就是在<code>编译期间</code>就初始化好了一个viewBinding类（view和点击事件的处理），生成findViewById来绑定布局，不用开发者每次去初始化</p><h4 id="Butterknife为什么初始化控件不能用private和static"><a href="#Butterknife为什么初始化控件不能用private和static" class="headerlink" title="Butterknife为什么初始化控件不能用private和static"></a>Butterknife为什么初始化控件不能用private和static</h4><p>因为在编译期间构建view的绑定事件会报错，无法访问private变量，否则，要加入反射，导致性能问题</p><p>static可能会导致内存泄漏，而且外部可以访问。</p><h4 id="ButterKnife为什么执行效率为什么比其他注入框架高？它的原理是什么"><a href="#ButterKnife为什么执行效率为什么比其他注入框架高？它的原理是什么" class="headerlink" title="ButterKnife为什么执行效率为什么比其他注入框架高？它的原理是什么"></a>ButterKnife为什么执行效率为什么比其他注入框架高？它的原理是什么</h4><p>解析注解处理器， 对比Butterknife，Dagger2，DBFlow。</p><p>没有反射机制，使用自定义注解框架</p><h4 id="继承问题"><a href="#继承问题" class="headerlink" title="继承问题"></a>继承问题</h4><p>butterknife继承后，子类可以使用父类控件，但是<strong>必须在setContView之后</strong>进行绑定。如果在子view进行绑定控件，但是父类找不到子类的控件，因为生成的是子view_ViewBinding类，父类获取不到</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>每个Activity会生成一个类，增大包体积</li><li>butterknife可以称之为view的注入，对findviewById包装更加简单，功能单一</li></ul><h2 id="ViewBinding最终最好的解决方案"><a href="#ViewBinding最终最好的解决方案" class="headerlink" title="ViewBinding最终最好的解决方案"></a>ViewBinding最终最好的解决方案</h2><h4 id="简析ViewBinding"><a href="#简析ViewBinding" class="headerlink" title="简析ViewBinding"></a>简析ViewBinding</h4><p>在build.gradle中开启ViewBinding</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    viewBinding.enabled = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android studio会将xml文件中所有文件在编译过程中生成<strong>xxxBinding</strong>类，这个类有三种初始化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binding = LayoutSecondBinding.inflate(getLayoutInflater());</span><br></pre></td></tr></table></figure><p>在Activity或Fragment中调用inflate方法进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inflate(LayoutInflater inflater)</span><br><span class="line">inflate(LayoutInflater inflater,ViewGroup parent,<span class="type">boolean</span> attachToParent)</span><br><span class="line">bind(View rootView)</span><br></pre></td></tr></table></figure><p>最终三个方法都会走到bind方法中，在这个方法中，对View进行findViewById操作</p><h4 id="ViewBinding和Butterknife的区别"><a href="#ViewBinding和Butterknife的区别" class="headerlink" title="ViewBinding和Butterknife的区别"></a>ViewBinding和Butterknife的区别</h4><p>ViewBinding会处理空安全，类型安全，还可以兼容java和kotlin。最新版本Gradle中设置对R文件的修改，R文件中的id不再是final的，(Fragment中R文件不是final的时候，Butterknife使用生成R2文件的做法围魏救赵)这样就会影响注解的使用，butterknife就被迫下台<br>Viewbinding根正苗红，官方支持就是最大优势</p><h4 id="Viewbinding如何处理include布局？"><a href="#Viewbinding如何处理include布局？" class="headerlink" title="Viewbinding如何处理include布局？"></a>Viewbinding如何处理include布局？</h4><p>xml布局中存在include布局的，需要给include布局添加id，生成一个includexxxBinding文件，在xxxBinding类中做映射体现。</p><blockquote><p>内部view由final修饰，保证view不能被重新创建的view替换（引用不可修改），但是其内部的值可以修改</p></blockquote><h2 id="注解原理"><a href="#注解原理" class="headerlink" title="注解原理"></a>注解原理</h2><h4 id="简析"><a href="#简析" class="headerlink" title="简析"></a>简析</h4><p>元注解：修饰注解的注解，</p><ul><li>@Target：注解的作用目标（修饰方法，类还是字段）</li><li>@Retention：注解的生命周期<ul><li>SOURCE：仅存在java源文件中，经过编译器后就丢弃，适用于一些检查行的操作，比如@Override</li><li>CLASS：编译class文件时生效，适用于在编译时做一些预处理操作，比如Butterknife的@BindView，在编译时，通过注解器生成一些辅助代码，完成完整的功能</li><li>RUNTIME：保留在运行时VM中可以通过反射获取注解。适用于一些需要运行时动态获取注解信息，类似反射获取注解等，比如EventBus的@Subscribe</li></ul></li><li>@Documented：注解是否应当被包含在JavaDoc文档中</li><li>@Inherited：是否允许子类继承该注解</li><li>AnnotationInvocationHandler：专门处理注解的Handler</li></ul><p>代码的生命周期包含：编码(SOURCE)—-&gt;编译(CLASS)—-&gt;运行(RUNTIME)</p><blockquote><p>默认时注解在编译阶段，即CLASS阶段</p></blockquote><p>本质：一个继承了Annotation接口的接口</p><ul><li>运行时处理：使用反射获取当前的所需要的东西</li><li>编译时处理：APT技术，即编译期扫描java文件的注解，并传递到注解处理器，注解处理器可根据注解生成新的java文件</li></ul><blockquote><p>APT(Annotation Processing Tool)编译期解析注解</p></blockquote><h4 id="注解的种类"><a href="#注解的种类" class="headerlink" title="注解的种类"></a>注解的种类</h4><ul><li>JDK提供的注解（源码注解）</li><li>自定义注解</li><li>元注解</li></ul><h4 id="注解的用处"><a href="#注解的用处" class="headerlink" title="注解的用处"></a>注解的用处</h4><ol><li>降低项目的耦合</li><li>自动完成一些规律性代码</li><li>自动生成java代码，减少开发工作量</li></ol><h4 id="注解器"><a href="#注解器" class="headerlink" title="注解器"></a>注解器</h4><p>注解器通常是以Java代码（或者编译过的字节码）作为输入，生成.java文件作为输出</p><p>AbstractProcessor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源于javax.annotation.processing;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractProcessor</span> <span class="keyword">implements</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">    <span class="comment">// 集合中指定支持的注解类型的名称（这里必须时完整的包名+类名)</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">getSupportedAnnotationTypes</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">SupportedAnnotationTypes</span> <span class="variable">sat</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getAnnotation(SupportedAnnotationTypes.class);</span><br><span class="line">            <span class="keyword">if</span>  (sat == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isInitialized())</span><br><span class="line">                    processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,</span><br><span class="line">                                                             <span class="string">&quot;No SupportedAnnotationTypes annotation &quot;</span> +</span><br><span class="line">                                                             <span class="string">&quot;found on &quot;</span> + <span class="built_in">this</span>.getClass().getName() +</span><br><span class="line">                                                             <span class="string">&quot;, returning an empty set.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> arrayToSet(sat.value());</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 指定当前正在使用的Java版本</span></span><br><span class="line">    <span class="keyword">public</span> SourceVersion <span class="title function_">getSupportedSourceVersion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SupportedSourceVersion</span> <span class="variable">ssv</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getAnnotation(SupportedSourceVersion.class);</span><br><span class="line">        <span class="type">SourceVersion</span> <span class="variable">sv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ssv == <span class="literal">null</span>) &#123;</span><br><span class="line">            sv = SourceVersion.RELEASE_6;</span><br><span class="line">            <span class="keyword">if</span> (isInitialized())</span><br><span class="line">                processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,</span><br><span class="line">                                                         <span class="string">&quot;No SupportedSourceVersion annotation &quot;</span> +</span><br><span class="line">                                                         <span class="string">&quot;found on &quot;</span> + <span class="built_in">this</span>.getClass().getName() +</span><br><span class="line">                                                         <span class="string">&quot;, returning &quot;</span> + sv + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            sv = ssv.value();</span><br><span class="line">        <span class="keyword">return</span> sv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化处理器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialized)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot call init more than once.&quot;</span>);</span><br><span class="line">        Objects.requireNonNull(processingEnv, <span class="string">&quot;Tool provided null ProcessingEnvironment&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">this</span>.processingEnv = processingEnv;</span><br><span class="line">        initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这些注解是否由此 Processor 处理，该方法返回ture表示该注解已经被处理, 后续不会再有其他处理器处理; 返回false表示仍可被其他处理器处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations,</span></span><br><span class="line"><span class="params">                                    RoundEnvironment roundEnv)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>如果是单一属性，可以使用value字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> MyAnno1 &#123;</span><br><span class="line">    <span class="comment">//格式：类型名 属性名（）</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnno1(&quot;kang&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> MyAnno2 &#123;</span><br><span class="line">    <span class="comment">//格式：类型名 属性名（）</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnno2(name = &quot;kang&quot;)</span></span><br></pre></td></tr></table></figure><p>如果不是value字段的话，需要（指定属性 &#x3D; 值）</p><blockquote><p>注解中只允许八种基本数据类型、字符串、类类型，注解类型，枚举类型及其一维数组</p></blockquote><h2 id="Glide和Picasso"><a href="#Glide和Picasso" class="headerlink" title="Glide和Picasso"></a>Glide和Picasso</h2><h4 id="简述LruCache和DiskLruCache"><a href="#简述LruCache和DiskLruCache" class="headerlink" title="简述LruCache和DiskLruCache"></a>简述LruCache和DiskLruCache</h4><p>内部都实现了LRU算法，即：优先淘汰那些最近最少使用的缓存对象</p><p>LruCache：</p><p>内部采用LinkedHashMap，是线程安全的（get、put、remove方法都是用synchronized），双向链表（保持LinkedList规定顺序+HashMap便于查找）<br>将最近使用的节点放置在链表尾部，当超过大小时，删除第一个头节点。</p><p>存储了前一个元素和后一个元素的引用，get方法后，就查出值删除，然后放置在头部，如果超过Lru算法的大小，直接遍历删除尾节点，直到大小在范围内</p><h4 id="简述Glide的缓存过程"><a href="#简述Glide的缓存过程" class="headerlink" title="简述Glide的缓存过程"></a>简述Glide的缓存过程</h4><p>默认打开缓存，内存缓存使用LruCache+弱引用实现，磁盘缓存使用DiskLruCache实现</p><p>使用内存缓存+磁盘缓存的策略，生成key时，图片只要发生变化，就算长宽发生变化也会导致缓存不同的key。Glide将内存缓存划分为两个区域：</p><ul><li>LruResourceCache：使用LruCache算法，LinkedHashMap（不在使用的）</li><li>activeResources：添加弱引用机制，HashMap（正在使用的图片）</li></ul><p>磁盘缓存之存在DiskLruCache，因为Glide可以压缩图片（尺寸压缩），所以磁盘缓存中可以设置缓存原始图片还是压缩后的图片，压缩图片可以有效避免大图和超大图带来的OOM，Glide没有使用google提供的DiskLruCache，而是使用自己开发的，不过原理都一样</p><p>在首次访问时，将正在使用的图片信息会存储在activeResources的弱引用中，当引用次数为0时（调用release方法），会将其放入LruResourceCache中，执行Lru算法，移除后会存入DiskLruCache中。</p><p>所以，先去activeResources中寻找，找到后，将引用对象索引+1（active.aquire();）（计算引用次数）。然后去LruResourceCache中寻找了，若找到了，在LruResourceCache中移除，并将其放入activeResources中。然后去DiskLruCache中寻找，若找到了，在DiskLruCache中删除，并将其放入activeResources中。</p><blockquote><p>Glide 缓存的是imageView的所需图片的大小，若大小不同，重新缓存</p><p>Picasse 缓存图片原图大小</p></blockquote><h4 id="Glide是如何绑定生命周期的？"><a href="#Glide是如何绑定生命周期的？" class="headerlink" title="Glide是如何绑定生命周期的？"></a>Glide是如何绑定生命周期的？</h4><ul><li>Application参数:如果传入的是Application对象,那么这里就会调用带有Context参数的get()方法重载，调用getApplicationManager()方法来获取一个RequestManager对象。其实这是最简单的一种情况，因为Application对象的生命周期即应用程序的生命周期，因此Glide并不需要做什么特殊的处理，它自动就是和应用程序的生命周期是同步的，如果应用程序关闭的话，Glide的加载也会同时终止。</li><li>非Application参数:不管传入的是Activity、FragmentActivity、v4包下的Fragment、还是app包下的Fragment，最终的流程都是一样的，那就是会向当前的Activity当中添加一个隐藏的Fragment。因为Glide需要知道加载的生命周期。很简单的一个道理，如果你在某个Activity上正在加载着一张图片，结果图片还没加载出来，Activity就被用户关掉了，那么图片还应该继续加载吗？当然不应该。可是Glide并没有办法知道Activity的生命周期，于是Glide就使用了添加隐藏Fragment的这种小技巧，因为Fragment的生命周期和Activity是同步的，如果Activity被销毁了，Fragment是可以监听到的，这样Glide就可以捕获这个事件并停止图片加载了。</li><li>如果我们是在<strong>非主线程</strong>当中使用的Glide，那么不管你是传入的Activity还是Fragment，都会被强制当成Application来处理。</li></ul><ol><li>RequestManagerFragment：实现一个无UI的fragment。</li><li>ActivityFragmentLifecycle：无UI的fragment通过它，去调用RequestManager</li><li>RequestManager：实现关键的几个方法，去调用glide 的操作</li><li>RequestManagerRetriever：作为一个桥梁，将RequestManagerFragment<br>和RequestManager给联系起来</li></ol><blockquote><p>空RequestManagerFragment 的生命周期调用 ActivityFragmentLifecycle，然后ActivityFragmentLifecycle 调用 RequestManager ，RequestManager 再去调用RequestTracker 的glide操作，最终实现gilde的操作，能够根据页面的生命周期做相应的处理。</p></blockquote><h4 id="Glide中Fragment中是怎么绑定生命周期的？"><a href="#Glide中Fragment中是怎么绑定生命周期的？" class="headerlink" title="Glide中Fragment中是怎么绑定生命周期的？"></a>Glide中Fragment中是怎么绑定生命周期的？</h4><h4 id="Glide中into指定view，再次刷新view会发生什么？"><a href="#Glide中into指定view，再次刷新view会发生什么？" class="headerlink" title="Glide中into指定view，再次刷新view会发生什么？"></a>Glide中into指定view，再次刷新view会发生什么？</h4><blockquote><p>Glide内部通过HttpUrlConnection进行通信，也可切换为okhttp&#x2F;volley</p></blockquote><ol><li>根据ScaleType进行相应的设置</li><li>根据传入的类型对Glide加载进行配置，asBitmap，asGif，asDrawable</li><li>根据target（View）创建Request请求，根据生命周期管控Request的暂停和下载</li></ol><p><code>target</code>就是<code>view</code>，先判断<code>target</code>是之前已经绑定了请求，如果旧请求和新请求一样且处于请求完成或者正在请求状态就直接复用旧请求。如果不复用,就<code>RequestManager</code>先移除和旧请求绑定的<code>target</code>对象，<code>Target</code>再重新和<code>Request</code>对象进行一个绑定，调用<code>requestManager.track(target, request)</code>再加入请求队列，开启请求，最后返回经过处理的<code>traget</code>对象。</p><h4 id="Glide和Picasso对比"><a href="#Glide和Picasso对比" class="headerlink" title="Glide和Picasso对比"></a>Glide和Picasso对比</h4><ol><li>Glide较Picasso庞大的多</li><li>Glide绑定生命周期，onPause时暂停加载，onResume时再启动，Picasso只存在context</li><li>Glide会缓存imageView图片大小，尺寸不同，key不同，会缓存两份，Picasso是缓存完整大小，使用时会重新设置大小</li><li>Glide首次加载快于Picasso，而后每次加载慢于Picasso，因为Glide需要改变图片的大小再缓存到内存，时间会慢。picasso拿到缓存后需要对图片重新设置大小，耗时较长。</li><li>Glide支持gif</li><li>Glide加载的图片质量略差，因为bitmap的格式内存开销小，但是很难察觉</li><li>Glide可以配置图片显示的动画，而picasso只有默认的一种动画</li><li>Glide缓存方式更优，减少OOM的发生</li></ol><blockquote><p>Glide：RGB565<br>Picasso：ARGB8888</p></blockquote><h4 id="Picasso"><a href="#Picasso" class="headerlink" title="Picasso"></a>Picasso</h4><p>缓存机制：LruCache，DiskLruCache</p><p>内存缓存占用一个app的15%内存</p><p>网络请求使用的okhttp，内部缓存也使用okhttp，一般大小不超过50M</p><p>网络机制：network</p><h4 id="Fresco比较"><a href="#Fresco比较" class="headerlink" title="Fresco比较"></a>Fresco比较</h4><p>缓存机制：</p><ol><li><p><strong>BitmapMemoryCache</strong>缓存，已解码的内存缓存</p></li><li><p><strong>EncodedMemoryCache</strong>缓存，</p></li><li><h3 id="CountingLruMap，Lru算法清除缓存"><a href="#CountingLruMap，Lru算法清除缓存" class="headerlink" title="CountingLruMap，Lru算法清除缓存"></a>CountingLruMap，Lru算法清除缓存</h3></li></ol><p>分层处理，producer层层处理，每层处理结果通过Consumer向上传递，Producer-consumer链</p><ol><li>从已编码缓存中获取bitmap缓存</li><li>从未编码缓存中获取EncodedImage类型</li><li>从磁盘中获取</li><li>从网络中获取</li></ol><p>DraweeView：</p><p>动图播放，多级图层，渐进显示，画面剪裁</p><img src="/imageMd/fresco-1.png" width="70%"/><ol><li>解码器优化，避免频繁解码导致内存抖动，使用pool内存池复用</li></ol><p>适合各个android版本的解码器</p><p>优点：</p><ol><li>内存管理，LRU算法，缓存和磁盘管理</li><li>加载大图和高清图时可以先加载低清晰度图和缩略图</li><li>加载gif</li><li>图片渐进式处理：，渐进式图片格式先呈现大致的图片轮廓，然后随着图片下载的继续，呈现逐渐清晰的图片</li></ol><h4 id="包体积"><a href="#包体积" class="headerlink" title="包体积"></a>包体积</h4><p>Fresco&gt;Glide&gt;Picasso</p><h2 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h2><p>检测内存泄漏</p><h4 id="ActivityLifecycleCallbacks-与-FragmentLifeCycleCallbacks"><a href="#ActivityLifecycleCallbacks-与-FragmentLifeCycleCallbacks" class="headerlink" title="ActivityLifecycleCallbacks 与 FragmentLifeCycleCallbacks"></a>ActivityLifecycleCallbacks 与 FragmentLifeCycleCallbacks</h4><p>通过application.registerActivityLifecyleCallbacks获取Activity的生命周期</p><p>通过fragmentManager.registerFragmentLifecyleCallbacks获取Fragment的生命周期</p><p>注册接口，拿到Activity和Fragment的各种生命周期回调信息</p><h4 id="如何做到内存泄漏检测"><a href="#如何做到内存泄漏检测" class="headerlink" title="如何做到内存泄漏检测"></a>如何做到内存泄漏检测</h4><p>Activity在onDestory后会将Activity生成一个唯一的key后存储在弱引用队列中，在主线程空闲时（IdleHandler）触发gc机制，垃圾回收，整理弱引用队列，查看弱引用队列中没有被回收的对象，即是内存泄漏的对象，打印出栈堆信息以供分析dump</p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>只能监听Activity和Fragment的内存泄漏检测，无法检测Service</p><h4 id="其他内存泄漏检测工具"><a href="#其他内存泄漏检测工具" class="headerlink" title="其他内存泄漏检测工具"></a>其他内存泄漏检测工具</h4><p>Profiler：android studio自带，可以查看内存的整体过程，分析是否发生内存泄漏</p><h2 id="ASM函数插桩"><a href="#ASM函数插桩" class="headerlink" title="ASM函数插桩"></a>ASM函数插桩</h2><h4 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h4><p>简析为字节码插桩，可以直接修改已经存在的class文件或者生成class文件，相比较于AspectJ，ASM更加偏向于底层，他是直接操作字节码的，在设计中更小，更快</p><blockquote><p>class文件本质是16进制数据</p></blockquote><p>ClassVisitor</p><p>MethodVistor</p><h1 id="Android基础篇"><a href="#Android基础篇" class="headerlink" title="Android基础篇"></a>Android基础篇</h1><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><h4 id="简述Application"><a href="#简述Application" class="headerlink" title="简述Application"></a>简述Application</h4><p>作用：做初始化工作，提供上下文。继承自ContextWarpper，获取的是ContextWrapper中的context对象</p><ul><li>一个应用中有且只有一个</li><li>其生命周期和应用程序一样长</li><li>Application的onCreate方法才是整个应用程序的入口</li><li>只会实例化一次，所以天生就是一个单例</li></ul><p>生命周期：</p><ul><li>onCreate：创建时执行</li><li>onTerminate：终止时执行</li><li>onLowMemory：低内存时执行</li></ul><h4 id="Application的初始化流程"><a href="#Application的初始化流程" class="headerlink" title="Application的初始化流程"></a>Application的初始化流程</h4><p>通过AMS协调，ActivityThread优先建立后，会新建一个ApplicationThread，用作和AMS通过Binder通信，之后AMS通知ActivityThread去bindApplication，将消息返送到messageQueue，进行初始化Application的任务，然后调用<code>attachBaseContext</code>将Context绑定到Application，最后调用Application.onCreate()方法进行后续Activity的初始化</p><blockquote><p>AMS 来通知 zygote 进程来 fork 一个新进程，来开启我们的目标 App 的</p></blockquote><h4 id="ActivityLifecycleCallbacks理解"><a href="#ActivityLifecycleCallbacks理解" class="headerlink" title="ActivityLifecycleCallbacks理解"></a>ActivityLifecycleCallbacks理解</h4><p>ActivityLifecycleCallback是Application中的一个接口，可以监听应用中所有Activity的生命周期，可以通过该方法完成一些特殊的需求，比如监测当前App显示的Activity是那个？App是否存在前台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">ActivityLifecycleCallbacks</span> <span class="variable">activityLifecycleCallbacks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityLifecycleCallbacks</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityCreated</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityStarted</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityResumed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPaused</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityStopped</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivitySaveInstanceState</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@NonNull</span> Bundle outState)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityDestroyed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注册Callback</span></span><br><span class="line">        registerActivityLifecycleCallbacks(callbacks);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h4 id="简述生命周期"><a href="#简述生命周期" class="headerlink" title="简述生命周期"></a>简述生命周期</h4><p><img src="https://developer.android.google.cn/guide/components/images/activity_lifecycle.png?hl=zh-cn" alt="img"></p><h5 id="Activity："><a href="#Activity：" class="headerlink" title="Activity："></a>Activity：</h5><ul><li>onCreate()   正在被创建</li><li>onRestart()    不可见到可见</li><li>onStart()    Activity正在启动，已经可见了</li><li>onResume()   Acitivty已经可见，并在前台显示</li><li>onPause()    Acitivty正在停止，之后会不可见</li><li>onStop()    Activity即将停止</li><li>onDestory()    Activity被销毁</li></ul><blockquote><p>onStart和onResume都为可见，onStart不在前台显示，onResume在前台显示</p><p>onPause后已经不可见，会进入onResume或者另一个onResume，所以不能做耗时操作，会影响界面显示</p><p>onPause和onStop中不能太耗时</p><p>如果新的Activity采用了透明主题，那么当前Activity不会回调onStop</p><p>onStart和onStop对应Activity是否可见</p><p>onResume和onPause对应Activity是否在前台显示</p></blockquote><p>异常情况下会执行onSaveInstance方法进行数据保存</p><h4 id="简述启动模式"><a href="#简述启动模式" class="headerlink" title="简述启动模式"></a>简述启动模式</h4><ul><li>standard：标准模式，来一个添加一个</li><li>singleTop：栈顶复用，如果在栈顶，就复用这个Activity，<code>onNewIntent</code>会被执行，替代onCreate()</li><li>singleTask：栈内复用，如果在栈内，就复用这个Activity，该Activity之上的全部出栈，onNewIntent会被执行</li><li>singleInstance：单实例模式。加强版singleTask，会为自己新建一个栈，在该栈中栈内复用</li></ul><h4 id="LauncherMode和startActivityForResult"><a href="#LauncherMode和startActivityForResult" class="headerlink" title="LauncherMode和startActivityForResult"></a>LauncherMode和startActivityForResult</h4><img src="http://5b0988e595225.cdn.sohucs.com/images/20180103/a3b5ebe0294548348fe4d18bf3fcb0e0.jpeg" width="70%"/><img src="http://5b0988e595225.cdn.sohucs.com/images/20180103/f5357e8487474ae2b5e17f08725778c2.jpeg" width="70%"/><p>在5.0之前，当启动一个Activity时，系统将首先检查Activity的launchMode，如果为A页面设置为SingleInstance或者B页面设置为singleTask或者singleInstance,则会在LaunchFlags中加入FLAG_ACTIVITY_NEW_TASK标志，而如果含有FLAG_ACTIVITY_NEW_TASK标志的话，onActivityResult将会立即接收到一个cancle的信息，而5.0之后这个方法做了修改，修改之后即便启动的页面设置launchMode为singleTask或singleInstance，onActivityResult依旧可以正常工作，也就是说无论设置哪种启动方式，StartActivityForResult和onActivityResult()这一组合都是有效的</p><h4 id="什么时候会启动一个新的Activity栈？"><a href="#什么时候会启动一个新的Activity栈？" class="headerlink" title="什么时候会启动一个新的Activity栈？"></a>什么时候会启动一个新的Activity栈？</h4><ul><li>allowTaskReparenting：</li></ul><ol><li>singleInstance单独使用，会新建一个栈</li><li>singleTask配合taskAffinity使用</li><li>taskAffinity配合Intent.FLAG_ACTIVITY_NEW_TASK修饰Activity（AMS先处理LauncherMode，在处理FLAG_ACTIVITY_NEW_TASK）</li><li>taskAffinity配合allowTaskReparenting属性，使Activity从启动栈移动到正在使用的栈中并显示出来</li></ol><h4 id="如何控制Activity的动画切换"><a href="#如何控制Activity的动画切换" class="headerlink" title="如何控制Activity的动画切换"></a>如何控制Activity的动画切换</h4><ol><li>通过overridePendingTransition(R.anim.slide_in_right, R.anim.slide_out_left)方法控制<br>再startActivity方法后或者finish方法之后调用即可生效</li><li>使用style定义切换动画</li></ol><h4 id="如何控制Fragment的动画切换"><a href="#如何控制Fragment的动画切换" class="headerlink" title="如何控制Fragment的动画切换"></a>如何控制Fragment的动画切换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FragmentTransaction</span> <span class="variable">fragmentTransaction</span> <span class="operator">=</span> mFragmentManager</span><br><span class="line">                .beginTransaction();</span><br><span class="line"></span><br><span class="line">fragmentTransaction.setCustomAnimations(</span><br><span class="line">                R.anim.in_from_right,</span><br><span class="line">                R.anim.out_to_left);</span><br></pre></td></tr></table></figure><p>使用FragmentTransaction开启Fragment动画，设置自定义动画切换，进入动画和推出动画</p><h4 id="ActivityA跳转到ActivityB，再按back键返回ActivityA，生命周期情况？"><a href="#ActivityA跳转到ActivityB，再按back键返回ActivityA，生命周期情况？" class="headerlink" title="ActivityA跳转到ActivityB，再按back键返回ActivityA，生命周期情况？"></a>ActivityA跳转到ActivityB，再按back键返回ActivityA，生命周期情况？</h4><p>ActivityA跳转到ActivityB：onPauseA()—–&gt;onCreateB()—–&gt;onStartB()—–&gt;onResumeB()—–&gt;onStopA()</p><p>ActivityB按back键返回ActivityA：</p><p>onPauseB()—–&gt;onRestartA()—–&gt;onStartA()—–&gt;onResumeA()—–&gt;onStopB()—–&gt;onDestoryB()</p><h4 id="如果ActivityB是窗口Activity呢？"><a href="#如果ActivityB是窗口Activity呢？" class="headerlink" title="如果ActivityB是窗口Activity呢？"></a>如果ActivityB是窗口Activity呢？</h4><p>ActivityA跳转到ActivityB：onPauseA()—–&gt;onCreateB()—–&gt;onStartB()—–&gt;onResumeB()</p><p>ActivityB按back键返回ActivityA：onPauseB()—–&gt;onResumeA()—–&gt;onStopB()—–&gt;onDestoryB()</p><h4 id="Activity的生命周期会受Dialog影响吗？"><a href="#Activity的生命周期会受Dialog影响吗？" class="headerlink" title="Activity的生命周期会受Dialog影响吗？"></a>Activity的生命周期会受Dialog影响吗？</h4><p>不会，Activity生命周期不会随Dialog的显示而变化</p><p>Activity的生命周期受AMS调用，而dialog不是Activity，所以不受AMS控制，所以不会触发Activity的生命周期</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h4 id="Service有几种创建方式？有什么区别？"><a href="#Service有几种创建方式？有什么区别？" class="headerlink" title="Service有几种创建方式？有什么区别？"></a>Service有几种创建方式？有什么区别？</h4><ol><li>startService()，在不需要的时候stopService()</li><li>bindService()，与生命周期相绑定，在销毁的时候进行回收unbind()</li></ol><p><img src="/imageMd/service-1.png" alt="生命周期"></p><h4 id="如何理解IntentService？生命周期是什么？HandlerThread-是什么？"><a href="#如何理解IntentService？生命周期是什么？HandlerThread-是什么？" class="headerlink" title="如何理解IntentService？生命周期是什么？HandlerThread 是什么？"></a>如何理解IntentService？生命周期是什么？HandlerThread 是什么？</h4><p>intentService继承自Service，持有Service的功能，同时，他是一个处理异步操作的类，当异步执行结束后会自动关闭intentService，多次执行startService()，只是执行onStartCommand方法，将消息加入到消息队列中。</p><p>其本质就是启动了一个类似于主线程Handler的机制去维护异步操作。</p><p>生命周期：onStartCommand()中执行onStart()方法，在onstart()方法中添加handler.sendMessage()方法</p><p>HandlerThread：就是将Handler+looper进行封装，允许直接在子线程中使用handler的一套逻辑。</p><blockquote><p>IntentService更像是一个后台线程，但是他又是一个服务，不容易被回收，这是他的优点</p></blockquote><h4 id="JobIntentService"><a href="#JobIntentService" class="headerlink" title="JobIntentService"></a>JobIntentService</h4><p>是IntentService的子类，在android 8.0（26）以上，IntentService的所有后台执行任务都会受到限制约束，所以要使用JobIntentService。</p><blockquote><p>service不能使用后台服务，需要使用ContextCompat.startForegroundService启动前台服务，这样就会启动一个notification，对用户来说体验不是很好，所以就要使用<br>JobIntentService启动一个后台服务</p></blockquote><p>在使用JobIntentService的时候不需要startService，stopService，在需要的时候调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DownLoadJobIntentService.enqueueWork(MainActivity.<span class="built_in">this</span>,DownLoadJobIntentService.class,jobId(<span class="number">8</span>),intent);</span><br></pre></td></tr></table></figure><p>而后会执行onHandleWork方法中的逻辑，执行完毕后自动销毁</p><h4 id="onStartCommand中三个回调分别是什么？"><a href="#onStartCommand中三个回调分别是什么？" class="headerlink" title="onStartCommand中三个回调分别是什么？"></a>onStartCommand中三个回调分别是什么？</h4><ul><li>START_NOT_STICKY：Service被回收后不做处理</li><li>START_STICKY：Service在被回收后，重新创建Service，但是<code>不保存</code>intent</li><li>START_REDELIVER_INTENT：Service在被回收后，重新创建Service，<code>保存</code>intent</li><li>START_STICKY_COMPATIBILITY：START_STICKY的兼容版本，但不保证服务被kill后一定能重启。</li></ul><h4 id="Service保活"><a href="#Service保活" class="headerlink" title="Service保活"></a>Service保活</h4><ol><li>设置成前台服务，绑定Notification， startForeground(1, getNotification());</li><li>单独设置为服务进程</li><li>onStartCommand返回START_STICKY，START_REDELIVER_INTENT，保证服务被干掉后重启</li><li>在onDestory发送一个广播，广播接收器接收广播后拉起服务</li><li>添加系统广播拉起</li><li>提升服务的优先级</li></ol><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><img src="http://img-blog.csdnimg.cn/20190717110219153.png" width="400" height="700"/><h4 id="FragmentPagerAdapter和FragmentStatePagerAdapter的区别？"><a href="#FragmentPagerAdapter和FragmentStatePagerAdapter的区别？" class="headerlink" title="FragmentPagerAdapter和FragmentStatePagerAdapter的区别？"></a>FragmentPagerAdapter和FragmentStatePagerAdapter的区别？</h4><p>FragmentPagerAdapter：切换页面只是将Fragment分离，适合Fragment较少的情况不影响内存</p><p>FragmentStatePagerAdapter：切换页面将Fragment回收，适合Fragment较多的情况，这样不会消耗太多内存资源</p><h4 id="Fragment的3种切换方式"><a href="#Fragment的3种切换方式" class="headerlink" title="Fragment的3种切换方式"></a>Fragment的3种切换方式</h4><ol><li>add方法：只是重新回到fragment</li><li>replace方法：每次都会重新构建fragment</li></ol><h4 id="为什么不能用Fragment的构造函数进行传参？有什么劣势，应该怎么办？为什么？"><a href="#为什么不能用Fragment的构造函数进行传参？有什么劣势，应该怎么办？为什么？" class="headerlink" title="为什么不能用Fragment的构造函数进行传参？有什么劣势，应该怎么办？为什么？"></a>为什么不能用Fragment的构造函数进行传参？有什么劣势，应该怎么办？为什么？</h4><p>Fragment在异常崩溃后重建时，默认会调用Fragment无参构造，这样会导致Fragment中的有参构造的值不会被执行，这样数据就会异常</p><p>Fragment中调用setArguments来传递参数，在Activity构造Fragment时会通过反射午餐构造实例化一个新的Fragment，并且给mArguments初始化为原先的值</p><h4 id="Fragment的重建在那个生命周期中？"><a href="#Fragment的重建在那个生命周期中？" class="headerlink" title="Fragment的重建在那个生命周期中？"></a>Fragment的重建在那个生命周期中？</h4><p>在FragmentActivity的onSaveInstanceState中做存储，将Framgent通过序列化Parcelable进行存储，在Activity的onCreate中进行恢复</p><p>当配置发生变化时，Activity进入销毁过程，FragmentManager先销毁队列中Fragment的视图，然后检查每个Fragment的retainInstance属性。如果retainInstance为false，FragmentManager会销毁该Fragment实例；如果retainInstance为true，则不会销毁该Fragment实例，Activity重建后，新的FragmentManager会找到保留的Fragment并为其创建视图。</p><h2 id="BroadCastReceiver"><a href="#BroadCastReceiver" class="headerlink" title="BroadCastReceiver"></a>BroadCastReceiver</h2><h4 id="简述广播的启动方式和区别"><a href="#简述广播的启动方式和区别" class="headerlink" title="简述广播的启动方式和区别"></a>简述广播的启动方式和区别</h4><ul><li>静态注册：在AndroidManifest中注册，常驻型广播</li><li>动态注册：使用intentFilter过滤广播，registerReceiver注册广播，跟随生命周期</li></ul><blockquote><p>Android8.0以上部分广播不允许静态注册</p></blockquote><h4 id="无序广播和有序广播的区别"><a href="#无序广播和有序广播的区别" class="headerlink" title="无序广播和有序广播的区别"></a>无序广播和有序广播的区别</h4><ul><li>无序广播：所有广播接收器都可以获得，不可以拦截，不可以修改</li><li>有序广播：按照优先级向下传递，可拦截广播，修改广播</li></ul><h4 id="本地广播和全局广播"><a href="#本地广播和全局广播" class="headerlink" title="本地广播和全局广播"></a>本地广播和全局广播</h4><p>本地广播接收器只接收本地广播，减少应用外广播干扰，高效<br>androidx中1.1.0-alpha01中弃用本地广播，官方推荐该用LiveData或响应式流</p><h2 id="IPC机制"><a href="#IPC机制" class="headerlink" title="IPC机制"></a>IPC机制</h2><h4 id="简述android中的IPC机制"><a href="#简述android中的IPC机制" class="headerlink" title="简述android中的IPC机制"></a>简述android中的IPC机制</h4><p>进程间通信</p><p>架构：Client&#x2F;Server架构，Binder机制，之间通过代理接口通信</p><p>client，server，serverManager</p><p>AndroidManifest中指定Android:process属性</p><ul><li>包名:remote为应用私有进程，其他应用不可访问</li><li>包名.remote为全局进程，其他应好通过ShareUID可以和他跑在同一个进程</li></ul><p>多进程带来的问题：四大组件共享数据失败，每个进程会单独开辟内存空间存储信息</p><ol><li>静态成员和单例模式完全失效</li><li>线程同步机制完全失效</li><li>SharedPreferences可靠性下降，不支持多进程</li><li>Application会多次创建</li></ol><h4 id="Serializable和parcelable区别"><a href="#Serializable和parcelable区别" class="headerlink" title="Serializable和parcelable区别"></a>Serializable和parcelable区别</h4><p>serializable:java自带，反射后产生大量临时变量，容易引起gc，主要用于持久化存储和网络传输的序列化</p><p>parcelable:android专用，性能强，将完整对象分解为部分对象，每一部分进行intent传输，可用于ipc，内部实现Bundle，主要用于内存的序列化</p><h4 id="Android为什么引入Parcelable？"><a href="#Android为什么引入Parcelable？" class="headerlink" title="Android为什么引入Parcelable？"></a>Android为什么引入Parcelable？</h4><ol><li>serializable通过反射，性能不好，</li><li>serializable反射产生大量临时变量，容易gc，导致内存抖动</li><li>serializable使用了大量的IO操作，也影响了耗时</li></ol><p>parcelable使用复杂，但高效，适用于内存序列化</p><h4 id="Parcelable一定比Serializable快吗？"><a href="#Parcelable一定比Serializable快吗？" class="headerlink" title="Parcelable一定比Serializable快吗？"></a>Parcelable一定比Serializable快吗？</h4><p>单论内存中的传输速度，Parcelable一定快于Serializable，但是Parcelable没有缓存的概念<br>Serializable存在缓存，会将解析过的内容放置在HandleTable，下次解析到同一类型的对象时就可以直接复用</p><h4 id="为什么java使用Serializable序列化对象，而不是json或者xml？"><a href="#为什么java使用Serializable序列化对象，而不是json或者xml？" class="headerlink" title="为什么java使用Serializable序列化对象，而不是json或者xml？"></a>为什么java使用Serializable序列化对象，而不是json或者xml？</h4><p>因为历史遗留问题，在json和xml出来之前，java已经设计了Serializable，对于Java的庞大体系，并不容易修改这个问题。java官方文档也推荐使用json库，因为他简单、易读、高效</p><h4 id="简析Binder机制"><a href="#简析Binder机制" class="headerlink" title="简析Binder机制"></a>简析Binder机制</h4><blockquote><p>在Android通信中并不是所有的进程通信都使用Binder，当fork()进程时，使用的是Socket()通信，因为fork不允许多线程，Binder是多线程模式，所以不被允许</p></blockquote><h4 id="进程空间划分"><a href="#进程空间划分" class="headerlink" title="进程空间划分"></a>进程空间划分</h4><p>一个进程空间分为<strong>用户空间</strong>和<strong>内核空间</strong></p><p>用户空间：数据独享，其他进程无法访问</p><p>内核空间：数据共享，其他进程可以访问</p><blockquote><p>所有的进程共用1个内核空间</p></blockquote><h4 id="如何看待ServiceManager？"><a href="#如何看待ServiceManager？" class="headerlink" title="如何看待ServiceManager？"></a>如何看待ServiceManager？</h4><p>ServiceManager管理系统中所有的服务，服务需要使用时都要在ServiceManager中进行注册，他的存在类似于DNS，提供client访问某一个服务的查询。</p><h4 id="Binder原理"><a href="#Binder原理" class="headerlink" title="Binder原理"></a>Binder原理</h4><p>binder驱动属于进程中的内核空间，即共享空间，在client发起请求时，需要将数据从用户空间拷贝到内核空间，binder通过传输内核空间中数据存储的引用映射给服务端，供服务端调用，服务端处理后，将返回值放在内核空间，通过binder传递引用映射给客户端进行处理</p><p><img src="/imageMd/binder-1.webp" alt="img"></p><h5 id="简述通信流程"><a href="#简述通信流程" class="headerlink" title="简述通信流程"></a>简述通信流程</h5><p>总体通信流程就是：</p><ul><li>客户端通过代理对象向服务器发送请求。</li><li>代理对象通过Binder驱动发送到服务器进程</li><li>服务器进程处理请求，并通过Binder驱动返回处理结果给代理对象</li><li>代理对象将结果返回给客户端。</li></ul><h5 id="详细的通信过程"><a href="#详细的通信过程" class="headerlink" title="详细的通信过程"></a>详细的通信过程</h5><ul><li>服务端跨进程的类都要继承Binder类，所以也就是服务端对应的Binder实体。这个类并不是实际真实的远程Binder对象，而是一个Binder引用(即服务端的类引用)，会在Binder驱动里还要做一次映射。</li><li>客户端要调用远程对象函数时，只需把数据写入到Parcel，在调用所持有的Binder引用的transact()函数</li><li>transact函数执行过程中会把参数、标识符（标记远程对象及其函数）等数据放入到Client的共享内存，Binder驱动从Client的共享内存中读取数据，根据这些数据找到对应的远程进程的共享内存。</li><li>然后把数据拷贝到远程进程的共享内存中，并通知远程进程执行onTransact()函数，这个函数也是属于Binder类。</li><li>远程进程Binder对象执行完成后，将得到的写入自己的共享内存中，Binder驱动再将远程进程的共享内存数据拷贝到客户端的共享内存，并唤醒客户端线程。</li></ul><p>通过Binder将客户端，服务端的共享内存中的数据进行读写，放入对方的共享内存中，并通知。</p><h5 id="Binder在Android中的应用？"><a href="#Binder在Android中的应用？" class="headerlink" title="Binder在Android中的应用？"></a>Binder在Android中的应用？</h5><ul><li><strong>系统服务及四大组件的启动调用工作</strong>：系统服务是通过getSystemService获取的服务，内部也就是通过ServiceManager。例如四大组件的启动调度等工作，就是通过Binder机制传递给ActivityManagerService，再反馈给Zygote。而我们自己平时应用中获取服务也是通过getSystemService(getApplication().WINDOW_SERVICE)代码获取。</li><li>AIDL（Android Interface definition language）。例如我们定义一个IServer.aidl文件，aidl工具会自动生成一个IServer.java的java接口类（包含Stub，Proxy等内部类）。</li><li>前台进程通过bindService绑定后台服务进程时，onServiceConnected(ComponentName name, IBinder service)传回IBinder对象，并且可以通过IServer.Stub.asInterface(service)获取IServer的内部类Proxy的对象，其实现了IServer接口。</li></ul><h4 id="为什么选择Binder机制？他的优势是什么？"><a href="#为什么选择Binder机制？他的优势是什么？" class="headerlink" title="为什么选择Binder机制？他的优势是什么？"></a>为什么选择Binder机制？他的优势是什么？</h4><ol><li>性能高，效率高：<br>传统的IPC（socket，管道，消息队列）需要拷贝两次内存，Binder只需要拷贝一次内存、共享内存不需要拷贝数据，只需要传递引用</li><li>安全性好：<br>C&#x2F;S通信添加UID&#x2F;PID，方便验证，安全机制完善。</li><li>利用C&#x2F;S架构，通过多线程控制一个服务端多个客户端的情况</li></ol><h4 id="Android中IPC的几种方式详细分析与优缺点分析"><a href="#Android中IPC的几种方式详细分析与优缺点分析" class="headerlink" title="Android中IPC的几种方式详细分析与优缺点分析"></a>Android中IPC的几种方式详细分析与优缺点分析</h4><ol><li>Bundle</li><li>文件共享</li><li>Messenger：内部实现AIDL机制，c&#x2F;s架构，通过handler接收message对象</li><li>AIDL</li><li>ContentProvider</li><li>Binder连接池</li></ol><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p><a href="https://www.jianshu.com/p/43bb31d8a742">Android Handler机制之总目录</a></p><p><a href="https://blog.csdn.net/songzi1228/article/details/82835982">Android面试题：Handler</a></p><blockquote><p>其实并不是每一次添加消息时，都会唤醒线程。当该消息插入到队列头时，会唤醒该线程；如果有延迟消息，插入到头部，也会唤醒线程后在休眠</p></blockquote><h4 id="一句话概括Handler，并简述其原理"><a href="#一句话概括Handler，并简述其原理" class="headerlink" title="一句话概括Handler，并简述其原理"></a>一句话概括Handler，并简述其原理</h4><p>android中用于主线程和子线程之间通信的工具</p><p>主要包含Handler,Looper,MessageQueue,ThreadLocal.</p><p><strong>Handler</strong>：封装了消息的发送和接收looper分发过来的Message</p><p><strong>Looper</strong>：协调Handler和MessageQueue之间的桥梁，Looper的作用是循环从MessageQueue中取出message，并分发</p><p>给相应的Handler，Handler则存储在Message中的target中</p><p><strong>message</strong>：单节点，存储handler传输的数据</p><p><strong>MessageQueue</strong>：内部结构为单链表，由Looper创建，具体代码为Looper.prepare()；先进先出原则(队列)，根据                                Message.when进行插入队列（队列中是按时间执行顺序排序）</p><p><strong>ThreadLocal</strong>：负责存储和获取本线程的Looper</p><p>handler.sendMessage(message)将message发送到MessageQueue，MessageQueue执行enqueueMessage()方法入队，Looper执行looper.loop()方法从MessageQueue中取出message，执行message.target.dispatchMessage(message)方法将消息发送到Handler中，在handleMessage()方法中拿到回调</p><h4 id="Looper-loop-是在主线程的死循环，为什么没有造成线程阻塞？"><a href="#Looper-loop-是在主线程的死循环，为什么没有造成线程阻塞？" class="headerlink" title="Looper.loop()是在主线程的死循环，为什么没有造成线程阻塞？"></a>Looper.loop()是在主线程的死循环，为什么没有造成线程阻塞？</h4><p>真正的ANR是在生命周期的回调中等待的时间过长导致的，深层次的讲，就是Looper.loop()没有及时取出消息进行分发导致的。一旦没有消息，Linux的epoll机制则会通过管道写<strong>文件描述符</strong>的方式来对主线程进行唤醒与沉睡，Android里调用了linux层的代码实现在适当时会睡眠主线程。</p><p>MessageQueue包含jni调用，无消息时，通知epoll休眠，来消息时，线程启动</p><h4 id="looper-loop-中循环，判空退出怎么理解？"><a href="#looper-loop-中循环，判空退出怎么理解？" class="headerlink" title="looper.loop()中循环，判空退出怎么理解？"></a>looper.loop()中循环，判空退出怎么理解？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">      ....</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block（可能会阻塞）</span></span><br><span class="line">           <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>在queue.next中，会通过jni调用，通过Linux的epoll机制则会通过管道写文件描述符的方式来对主线程进行唤醒与沉睡，只有当应用程序退出时，才会执行if语句退出循环。</p><h4 id="为什么不能在子线程更新UI？"><a href="#为什么不能在子线程更新UI？" class="headerlink" title="为什么不能在子线程更新UI？"></a>为什么不能在子线程更新UI？</h4><p>因为如果要在子线程中更新UI，势必要考虑线程安全，加锁机制，这样很耗时，不加锁又很容易发生错误，这些错误是致命的，所以在设计时只允许UI线程更新UI，避免这些错误。</p><h4 id="真的不能在子线程更新UI吗？"><a href="#真的不能在子线程更新UI吗？" class="headerlink" title="真的不能在子线程更新UI吗？"></a>真的不能在子线程更新UI吗？</h4><p>ViewRootImpl中会进行通过checkThread()进行线程检测</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ViewRootImpl</span><span class="params">(Context context, Display display)</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">checkThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CalledFromWrongThreadException</span>(</span><br><span class="line">                    <span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由此得出：viewRootImpl在那个线程被初始化，就会在那个线程更新UI，大部分情况下，ViewRootImpl都是在UI线程中初始化的，所以只能在UI线程更新UI，部分情况下可以在子线程更新UI（比如Dialog是在addView中初始化ViewRootImpl）</p><p>SurfaceView可以在子线程中更新</p><h4 id="ViewRootImpl是什么时候被创建的？"><a href="#ViewRootImpl是什么时候被创建的？" class="headerlink" title="ViewRootImpl是什么时候被创建的？"></a>ViewRootImpl是什么时候被创建的？</h4><p>在Acitivty中，ViewRootImpl是在<strong>onResume</strong>中创建的，所以在onCreate中进行子线程更新是可以绕过checkThread()检测的。</p><h4 id="一个Thread中可以有几个Looper-几个Handler"><a href="#一个Thread中可以有几个Looper-几个Handler" class="headerlink" title="一个Thread中可以有几个Looper?几个Handler"></a>一个Thread中可以有几个Looper?几个Handler</h4><p>一个Thread中只有一个Looper，可以存在无数个Handler，但是使用MessageQueue都是同一个，也就是一个Looper</p><h4 id="可以在子线程直接new一个Handler吗？那该怎么做？"><a href="#可以在子线程直接new一个Handler吗？那该怎么做？" class="headerlink" title="可以在子线程直接new一个Handler吗？那该怎么做？"></a>可以在子线程直接new一个Handler吗？那该怎么做？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">thread= new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line">                //创建Looper，Looper再创建MessageQueue</span><br><span class="line">                Looper.prepare();</span><br><span class="line">                //新建Handler</span><br><span class="line">                handler=new Handler();</span><br><span class="line">                //循环取出消息并执行</span><br><span class="line">                Looper.loop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br></pre></td></tr></table></figure><p>需要创建Looper，Looper会创建MessageQueue，循环从MessageQueue中取消息。</p><h4 id="Message可以如何创建？哪种效果更好，为什么？"><a href="#Message可以如何创建？哪种效果更好，为什么？" class="headerlink" title="Message可以如何创建？哪种效果更好，为什么？"></a>Message可以如何创建？哪种效果更好，为什么？</h4><p><strong>享元模式</strong></p><p>数据重复利用</p><ol><li>Message msg &#x3D; new Message();</li><li>Message msg2 &#x3D; Message.obtain();</li><li>Message msg1 &#x3D; handler1.obtainMessage();</li></ol><p>2，3从整个Messge池中返回一个新的Message实例，通过obtainMessage能避免重复Message创建对象。</p><p>所以2，3都可以避免重复创建Message对象，所以建议用第二种或者第三种任何一个创建Message对象。</p><p>messge就是一个节点，存在就是一条链表，链表中存储的都是可以复用的message，在handleMessage和callback</p><p>方法执行完成后执行message.recycle()方法，进行信息重置后加入闲置链表头部中，每次调用obtain方法会从闲置链表中取出头节点，如果闲置链表为空，则新建message。</p><blockquote><p>Message缓存池大小为50</p></blockquote><h4 id="使用Hanlder的postDelay-后消息队列会发生什么变化？"><a href="#使用Hanlder的postDelay-后消息队列会发生什么变化？" class="headerlink" title="使用Hanlder的postDelay()后消息队列会发生什么变化？"></a>使用Hanlder的postDelay()后消息队列会发生什么变化？</h4><p>postDelay()内部调用sendMessageDelayed()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="params">(Message msg, <span class="type">long</span> delayMillis)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>时间：<strong>SystemClock.uptimeMillis() + delayMillis</strong></p><p>SystemClock.uptimeMills()是<strong>从开机到现在</strong>的时间，不使用currentMills，因为其是可变的，uptimeMills()期间不包括休眠的时间，是一个相对时间</p><ol><li>Handler.postDelayed(Runnable r, long delayMillis)</li><li>Handler.sendMessageDelayed(getPostMessage(r), delayMillis)</li><li>Handler.sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis)</li><li>Handler.enqueueMessage(queue, msg, uptimeMillis)</li><li>MessageQueue.enqueueMessage(msg, uptimeMillis)</li></ol><blockquote><p>消息入队的时候会根据when判断时间，最终按照时间大小排序，时间短的在链表头，时间长的在链表尾部。</p></blockquote><p>案例如下：</p><ol><li><code>postDelay()</code>一个10秒钟的Runnable A、消息进队，MessageQueue调用<code>nativePollOnce()</code>阻塞，Looper阻塞；</li><li>紧接着<code>post()</code>一个Runnable B、消息进队，判断现在A时间还没到、正在阻塞，把B插入消息队列的头部（A的前面），然后调用<code>nativeWake()</code>方法唤醒线程；</li><li><code>MessageQueue.next()</code>方法被唤醒后，重新开始读取消息链表，第一个消息B无延时，直接返回给Looper；</li><li>Looper处理完这个消息再次调用<code>next()</code>方法，MessageQueue继续读取消息链表，第二个消息A还没到时间，计算一下剩余时间（假如还剩9秒）继续调用<code>nativePollOnce()</code>阻塞；</li><li>直到阻塞时间到或者下一次有Message进队；</li></ol><h4 id="同步消息、异步消息和同步屏障消息是什么？具体应用场景是什么？"><a href="#同步消息、异步消息和同步屏障消息是什么？具体应用场景是什么？" class="headerlink" title="同步消息、异步消息和同步屏障消息是什么？具体应用场景是什么？"></a>同步消息、异步消息和同步屏障消息是什么？具体应用场景是什么？</h4><p>同步消息：handler默认无参构造的形式是同步消息</p><p>异步消息：async传入true，则为异步消息</p><p>屏障消息：<code>msg.target == null</code>，使用postSyncBarrier()方法打开同步屏障，导致同步消息不执行，优先执行异步消息，规则同同步消息一样，当执行完毕后关闭同步屏障。</p><p>应用场景：在view的更新过程中，draw，requestLayout、invalidate中都用到这个方法，系统会优先处理这些异步消息，等处理结束后再处理同步消息。这样可以优先处理我们指定的系统消息。</p><blockquote><p>postSyncBarrier()该方法为私有方法，所以api不允许我们在开发中调用，我们只要知道原理就好了</p><p>调用该方法，会直接发送一个屏障消息进入messageQueue，则队列头部为屏障消息</p></blockquote><h4 id="ThreadLocal，谈谈你的理解"><a href="#ThreadLocal，谈谈你的理解" class="headerlink" title="ThreadLocal，谈谈你的理解"></a>ThreadLocal，谈谈你的理解</h4><p>跟HashMap功能类似，为什么不直接用HashMap呢？<br>原因：</p><ol><li>HashMap太大了，太臃肿了。ThreadLocal的key值只有Thread，value为looper，而HashMap的key值则可以<br>是string、int等数据类型，我们可以不用考虑这些数据类型;</li><li>线程隔离：我们的线程是系统中唯一的，用ThreadLocal来管理这些唯一的线程和其对应的value值会非常方便，</li><li>ThreadLocal参照了HashMap,简化了HashMap,便于我们使用。</li><li>HashMap线程不安全</li></ol><p><a href="#ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3">ThreadLocal的理解</a></p><h4 id="为什么子线程中不能使用Handler，而UI线程可以？"><a href="#为什么子线程中不能使用Handler，而UI线程可以？" class="headerlink" title="为什么子线程中不能使用Handler，而UI线程可以？"></a>为什么子线程中不能使用Handler，而UI线程可以？</h4><p>UI线程就是ActivityThread，他在初始化的时候创建了Looper,MessageQueue，所以可以直接使用Handler，而新创建的子线程没有创建Looper，所以创建了就可以使用了</p><p>Handler的构造方法中使用Looper.myLooper()获取了looper，但是在子线程中并没有looper</p><h4 id="Handler如何引起内存泄露？怎么解决？"><a href="#Handler如何引起内存泄露？怎么解决？" class="headerlink" title="Handler如何引起内存泄露？怎么解决？"></a>Handler如何引起内存泄露？怎么解决？</h4><p>非静态内部类或匿名内部类默认持有外部类的引用，当外部类被回收时，因为内部类持有外部类的引用，导致外部类不能被回收，造成内存泄露。</p><ol><li>Activity销毁时及时清理消息队列；</li><li>自定义静态Handler类+弱引用。</li></ol><h4 id="MessageQueue-next-会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？"><a href="#MessageQueue-next-会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？" class="headerlink" title="MessageQueue.next()会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？"></a>MessageQueue.next()会因为发现了延迟消息，而进行阻塞。那么为什么后面加入的非延迟消息没有被阻塞呢？</h4><p>首先非延时消息会入队，并且插入链表头，这时唤醒线程，进行循环取出message，非延时消息出队，到延迟消息后，如果事件未到，触发next的阻塞机制，如果时间到了，取出message，执行消息</p><h4 id="Handler延时机制保时吗？"><a href="#Handler延时机制保时吗？" class="headerlink" title="Handler延时机制保时吗？"></a>Handler延时机制保时吗？</h4><p><code>不保时</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">chatIflyHandler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       chatIflyHandler.postDelayed(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               Log.e(<span class="string">&quot;handler&quot;</span>,<span class="string">&quot;执行延时1s操作&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>首先一个非延时消息入队，紧接着一个延时消息入队，执行第一个非延时消息，用时3s后执行延时消息，对比when，然后直接执行，测试总共耗时3420ms</p><h4 id="Handler的入队机制是线程安全的（synchronized）"><a href="#Handler的入队机制是线程安全的（synchronized）" class="headerlink" title="Handler的入队机制是线程安全的（synchronized）"></a>Handler的入队机制是线程安全的（synchronized）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">messageQueue.equeue()&#123;</span><br><span class="line">    synchronized(this)&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何精确计时？"><a href="#如何精确计时？" class="headerlink" title="如何精确计时？"></a>如何精确计时？</h4><ul><li><p>使用timer（子线程处理TimerThread）</p></li><li><p>误差补偿算法(TextClock控件方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">mTicker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            onTimeChanged();</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> now + (<span class="number">1000</span> - now % <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            getHandler().postAtTime(mTicker, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>整秒数执行，当上次执行累积到1200，在下次执行时，通过next的计算后保证下次执行的时间不被累加到2200，而是同样在2000</p></li></ul><h4 id="IdleHandler是什么？用处是什么？"><a href="#IdleHandler是什么？用处是什么？" class="headerlink" title="IdleHandler是什么？用处是什么？"></a>IdleHandler是什么？用处是什么？</h4><p>messageQueue中有一个addIdleHandler()方法，添加IdleHandler接口</p><ul><li>添加时messageQueue不为空，则在线程休眠（没有消息，延时消息）时回掉方法</li><li>添加时messageQueue为空，则当时不会触发回掉，当线程被唤醒时才会执行</li></ul><blockquote><p>就是在启用IdleHandler的时候，如果线程处于休眠状态，要等到下次休眠状态才会生效。如果不是休眠状态，则下一次休眠立即生效。</p></blockquote><blockquote><p>启用IdleHandler后，主线程下次休眠时会通知</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> <span class="title class_">MessageQueue</span>.IdleHandler() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">queueIdle</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="comment">//do something</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果return <strong>true</strong>，则表示这个IdleHandler可多次使用<br>如果return <strong>false</strong>，则表示这个IdleHandler只能使用一次</p><h4 id="主线程的Looper何时退出？能否手动退出？"><a href="#主线程的Looper何时退出？能否手动退出？" class="headerlink" title="主线程的Looper何时退出？能否手动退出？"></a>主线程的Looper何时退出？能否手动退出？</h4><p>在app退出或者异常终止时，会退出Looper。在正常退出时，ActivityThread主线程中的mH（Handler）会接收到回调信息，调用quit()方法，强制退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityThread.java</span></span><br><span class="line"><span class="keyword">case</span> EXIT_APPLICATION:</span><br><span class="line">    <span class="keyword">if</span> (mInitialApplication != <span class="literal">null</span>) &#123;</span><br><span class="line">        mInitialApplication.onTerminate();</span><br><span class="line">    &#125;</span><br><span class="line">    Looper.myLooper().quit();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><ul><li><p>Looper.quit():调用后直接终止Looper，不在处理任何Message，所有尝试把Message放进消息队列的操作都会失败，比如Handler.sendMessage()会返回 false，但是存在不安全性，因为有可能有Message还在消息队列中没来的及处理就终止Looper了。</p></li><li><p>Looper.quitSafely():调用后会在所有消息都处理后再终止Looper，所有尝试把Message放进消息队列的操作也都会失败。</p></li></ul><p>当尝试在主线程手动退出looper时，会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: Main thread not allowed to quit.</span><br><span class="line">    at android.os.MessageQueue.quit(MessageQueue.java:<span class="number">428</span>)</span><br><span class="line">    at android.os.Looper.quit(Looper.java:<span class="number">354</span>)</span><br><span class="line">    at com.jackie.testdialog.Test2Activity.onCreate(Test2Activity.java:<span class="number">29</span>)</span><br><span class="line">    at android.app.Activity.performCreate(Activity.java:<span class="number">7802</span>)</span><br><span class="line">    at android.app.Activity.performCreate(Activity.java:<span class="number">7791</span>)</span><br><span class="line">    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:<span class="number">1299</span>)</span><br><span class="line">    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:<span class="number">3245</span>)</span><br><span class="line">    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:<span class="number">3409</span>) </span><br><span class="line">    at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:<span class="number">83</span>) </span><br><span class="line">    at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:<span class="number">135</span>) </span><br><span class="line">    at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:<span class="number">95</span>) </span><br><span class="line">    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:<span class="number">2016</span>) </span><br><span class="line">    at android.os.Handler.dispatchMessage(Handler.java:<span class="number">107</span>) </span><br><span class="line">    at android.os.Looper.loop(Looper.java:<span class="number">214</span>) </span><br><span class="line">    at android.app.ActivityThread.main(ActivityThread.java:<span class="number">7356</span>) </span><br><span class="line">    at java.lang.reflect.Method.invoke(Native Method) </span><br><span class="line">    at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:<span class="number">492</span>) </span><br><span class="line">    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">930</span>) </span><br></pre></td></tr></table></figure><p>因为主线程退出意味着app的关闭，这种操作不和规范，需要使用正式的退出操作</p><h4 id="如何退出app"><a href="#如何退出app" class="headerlink" title="如何退出app"></a>如何退出app</h4><ol><li><p>记录Activity任务栈，全部finish</p></li><li><p>System.exit(0);&#x2F;&#x2F;正常退出<br>System.exit(1);&#x2F;&#x2F;非正常退出</p></li><li><p>android.os.Process.killProcess(android.os.Process.myPid()); 关闭进程，如果系统发现进程未正常关闭，会重新启动进程</p></li><li><p>在Intent中直接加入标识Intent.FLAG_ACTIVITY_CLEAR_TOP，这样开启B时，会清除该进程空间的所有Activity。</p></li><li><p>2.2版本之前使用ActivityManager关闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActivityManager</span> <span class="variable">am</span> <span class="operator">=</span> (ActivityManager)getSystemService (Context.ACTIVITY_SERVICE);</span><br><span class="line">am.restartPackage(getPackageName());</span><br></pre></td></tr></table></figure><p>2.2版本以后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActivityManager</span> <span class="variable">am</span> <span class="operator">=</span> (ActivityManager)getSystemService (Context.ACTIVITY_SERVICE);</span><br><span class="line">am.killBackgroundProcesses(getPackageName());</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>该方法只是结束后台进程的方法，不能结束当前应用移除所有的 Activity。如果需要退出应用，需要添加System.exit(0)方法一起使用，并且只限栈内只有一个Activity，如果有多个Activity时，正如上面 方法 2 所说，就不起作用了。</p></li><li><p>将MainActivity设置为singleTask，返回MainActivity后会清空所有的Activity，这样直接在MainActivity执行finish()方法即可</p></li></ol><h4 id="如何看待sendMessageAtFrontOfQueue"><a href="#如何看待sendMessageAtFrontOfQueue" class="headerlink" title="如何看待sendMessageAtFrontOfQueue()"></a>如何看待sendMessageAtFrontOfQueue()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtFrontOfQueue</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">    <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">            <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的延迟时间为0，头插入消息队列，即消息队列下一次立即执行的消息，</p><h5 id="如何看待Handler构造中的CallBack方法？"><a href="#如何看待Handler构造中的CallBack方法？" class="headerlink" title="如何看待Handler构造中的CallBack方法？"></a>如何看待Handler构造中的CallBack方法？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mQueue = looper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">  <span class="comment">//这里的 callback 是 Runnable</span></span><br><span class="line">  <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果 callback 处理了该 msg 并且返回 true， 就不会再回调 handleMessage</span></span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可以看出构造函数中传入Callback参数，调用dispatch方法时，会优先调用callback方法，在调用handleMessage方法，即</p><blockquote><p>Callback接口可以在handleMessage前收到消息，如果返回true，则不会调用handleMessage方法</p></blockquote><p><strong>我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息！</strong></p><h4 id="Looper-prepareMain-和Looper-perpare的区别？"><a href="#Looper-prepareMain-和Looper-perpare的区别？" class="headerlink" title="Looper.prepareMain()和Looper.perpare的区别？"></a>Looper.prepareMain()和Looper.perpare的区别？</h4><p>区别是一个boolean值，主线程的looper永不退出，除非调用</p><h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><h4 id="如何理解AsyncTask？"><a href="#如何理解AsyncTask？" class="headerlink" title="如何理解AsyncTask？"></a>如何理解AsyncTask？</h4><ul><li>必须创建在主线程</li></ul><p>AscncTask内部封装了Handler+线程池</p><p>包含两个线程池，一个是用来排队的 ，一个才是真正的执行，通过Handler将状态回掉到主线程</p><ul><li>核心线程数，最少两个，最多四个</li><li>最大线程数&#x3D; cpu核心数*2+1</li><li>核心线程无超时限制，非核心线程在闲置时的超时时间为1s</li><li>任务队列容量为128</li></ul><p>execute方法执行，加入排队线程池排队，等待任务执行后通过handler通知主线程，调用状态回调方法，内部实现因为排队线程池阻塞，导致任务是串行的，即同时只有一个任务会进入线程池执行</p><p>executeOnExecutor执行调用异步操作</p><h4 id="谷歌为何弃用AsyncTask"><a href="#谷歌为何弃用AsyncTask" class="headerlink" title="谷歌为何弃用AsyncTask"></a>谷歌为何弃用AsyncTask</h4><ol><li>使用多线程更加复杂，使bug难以定位</li><li>太过复杂</li><li>滥用继承，effic java推荐“使用组合而不是继承”，使类多，且低效</li><li>默认的THREAD_POOL_EXECUTOR线程池配置不太合适</li></ol><h2 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h2><p><a href="#%E7%BA%BF%E7%A8%8B">线程</a></p><h4 id="简述线程池"><a href="#简述线程池" class="headerlink" title="简述线程池"></a>简述线程池</h4><p>android中线程池主要实现是ThreadPoolExecutor</p><p>参数：</p><ul><li><strong>核心线程数</strong>：如果指定ThreadPoolExecutor的allowCoreThreadTimeOut这个属性为true，那么核心线程如果不干活(闲置状态)的话，超过一定时间，就会被销毁掉</li><li><strong>最大线程数</strong>： &#x3D; 核心线程数 + 非核心线程数</li><li><strong>超时时间</strong>：非核心线程的闲置超时时间</li><li><strong>超时时间单位</strong>：非核心线程的闲置超时时间<strong>单位</strong></li><li><strong>线程等待队列</strong>：当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务</li><li><strong>线程创建工厂</strong>：线程池的拒绝策略，可以出错，也可以顾虑</li></ul><blockquote><p>allowCoreThreadTimeOut设置为true，非核心线程超时时间同样用于核心线程，如果为false，核心线程永远不会终止</p></blockquote><ol><li><p><strong>SynchronousQueue</strong>（空集合）：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现&lt;线程数达到了maximumPoolSize而不能新建线程&gt;的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大</p></li><li><p><strong>LinkedBlockingQueue</strong>（大小无限）：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize</p></li><li><p><strong>ArrayBlockingQueue</strong>（大小可以设置）：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误</p></li><li><p><strong>DelayQueue</strong>（延迟出队，大小可以设置）：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务</p></li></ol><p>规则：</p><ol><li>未达到核心线程数，新建核心线程</li><li>达到或者大于核心线程数，任务被插入任务队列等待执行</li><li>步骤2中无法插入队列（队列满了），线程数量小于线程池最大值，启动一个非核心线程执行任务</li><li>步骤3 中线程数量达到最大值，则拒绝执行此任务</li></ol><h4 id="android主要分为几种线程池？"><a href="#android主要分为几种线程池？" class="headerlink" title="android主要分为几种线程池？"></a>android主要分为几种线程池？</h4><p>四种</p><p>FixedThreadPool：全是核心线程，没有超时机制，任务队列没有大小限制</p><p>CachedThreadPool：全是非核心线程，最大为Integer.MAX_VALUE，空闲线程60s超时（60s内可以复用，60s后回收），适用于执行短时的大量任务，空闲时也不占用cpu资源</p><p>ScheduledThreadPool：核心线程固定，非核心线程为Interger.MAX_VALUE，非核心线程无超时机制（执行完就被回收），适用执行定时任务和固定周期任务</p><p>SingleThreadExecutor：只有一个核心线程，无超时机制，保证只在一个线程中执行任务</p><h4 id="线程池中一个线程崩溃会导致线程池崩溃吗？"><a href="#线程池中一个线程崩溃会导致线程池崩溃吗？" class="headerlink" title="线程池中一个线程崩溃会导致线程池崩溃吗？"></a>线程池中一个线程崩溃会导致线程池崩溃吗？</h4><p>不会，线程池存在两种方式去执行线程任务，submit和execute方式。  当发生线程崩溃时，execute下会将线程关闭，开辟新的线程，submit会返回异常，但不会关闭线程。</p><p>submit：</p><ul><li>继承自ExecutorService</li><li>不会抛出栈堆异常，通过Future.get方法获取异常信息</li><li>submit通过构造一个RunnableFuture后，执行execute方法，RunnableFuture内部使用状态管理，通过死循环判断任务执行状态，在执行完或者cancle后返回，</li></ul><blockquote><p><code>get()</code>方法是一个阻塞方法，在调用时需要注意</p></blockquote><p>execute：</p><ul><li>继承自Executor</li><li>会抛出堆栈异常信息，关闭该线程并创建新的线程</li></ul><h4 id="如何检测线程池中的崩溃问题呢？"><a href="#如何检测线程池中的崩溃问题呢？" class="headerlink" title="如何检测线程池中的崩溃问题呢？"></a>如何检测线程池中的崩溃问题呢？</h4><p>submit的get()方法可以获取崩溃，但是该方法是阻塞的，可用性不高，于是我们使用另一种方法</p><ol><li>execute+ThreadFactory.UncaughtExceptionHandler<br>在submit下UncaughtExceptionHandler失效，因为FutureTask会捕获异常并保存不会放入UncaughtExceptionHandler中</li><li>在run方法中自行捕获</li><li>重写ThreadLocalExecutor.afterExecute方法</li><li>submit+get方法</li></ol><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><h4 id="触摸事件传递"><a href="#触摸事件传递" class="headerlink" title="触摸事件传递"></a>触摸事件传递</h4><img src="https://pic1.zhimg.com/80/v2-5fdce519c134bdb81a38e9feb31ffb2c_1440w.jpg" width="300" height="400"/><p>DecorView为最顶层的view，DecorView、TitleView和ContentView都为FrameLayout</p><blockquote><p>如果一个view处理了down事件，那么后续的move，up都会交给他处理</p></blockquote><h5 id="点击事件的传递流程"><a href="#点击事件的传递流程" class="headerlink" title="点击事件的传递流程"></a>点击事件的传递流程</h5><p>onTouchListener(onTouch)&gt;onTouchEvent()&gt;onClickListener(onClick)</p><p>onTouchListener的onTouch返回为false，则onTouchEvent被调用</p><h5 id="简述view的事件传递"><a href="#简述view的事件传递" class="headerlink" title="简述view的事件传递"></a>简述view的事件传递</h5><p>事件传递从父类向子类传递，其中包含3个方法，在一个类中顺序执行，</p><ul><li>dispatchEvent：事件的分发，true—-&gt;分发给自己</li><li>onIntercepterEvent：事件拦截，true—-&gt;拦截后交给自己的onTouchEvent处理，false —-&gt;传递给子View</li><li>onTouchEvent：事件的执行。</li></ul><img src="https://img-blog.csdnimg.cn/2018110610205215.jpg" width="50%"/><p>如果View没有对ACTION_DOWN进行消费，之后的事件也不会传递过来。</p><p>事件的传递是从Activity开始的，Activity –&gt;PhoneWindow–&gt;DectorView–&gt;ViewGroup–&gt;View；主要操作在ViewGroup和View中；</p><p>ViewGroup类主要调用：dispatchTouchEvent()–&gt;onInterceptTouchEnent()–&gt;dispatchTransformedTouchEvent()；<strong>ViewGroup不直接调用onTouchEvent()方法；</strong></p><table><thead><tr><th>类</th><th>相关子类</th><th>方法</th></tr></thead><tbody><tr><td>Activity类</td><td>Activity……</td><td>dispatchTouchEvent(); onTouchEvent();</td></tr><tr><td>View容器（ViewGroup的子类）</td><td>FrameLayout、LinearLayout、ListView、ScrollVIew……</td><td>dispatchTouchEvent(); onInterceptTouchEvent(); onTouchEvent();</td></tr><tr><td>View控件（非ViewGroup子类）</td><td>Button、TextView、EditText……</td><td>dispatchTouchEvent(); onTouchEvent();</td></tr></tbody></table><blockquote><p>onIntercepterTouchEvent()方法之只存在ViewGroup中，Activity为最顶层，不需要拦截，直接分发，view为最底层，不需要拦截，直接分发</p></blockquote><ul><li>以ACTION_DOWN为开始，UP或者CANCEL为结束</li><li>如果dispatch不处理ACTION_DOWN事件，那么就不会继续接收到后续的ACTION_xxxx事件</li></ul><h5 id="如何让只执行onTouch事件，不执行onClick事件？"><a href="#如何让只执行onTouch事件，不执行onClick事件？" class="headerlink" title="如何让只执行onTouch事件，不执行onClick事件？"></a>如何让只执行onTouch事件，不执行onClick事件？</h5><p>将onTouch方法的返回值改为true，就会只执行onTouch事件，不执行onClick事件。</p><h5 id="如果截取了事件，还会往下传吗？那会走到哪里？"><a href="#如果截取了事件，还会往下传吗？那会走到哪里？" class="headerlink" title="如果截取了事件，还会往下传吗？那会走到哪里？"></a>如果截取了事件，还会往下传吗？那会走到哪里？</h5><p>如果截取了事件就不会往下传递了，只会执行本Viewgroup的onTouchEvent。</p><h5 id="如果截取了事件并处理了事件还会返回父级吗？"><a href="#如果截取了事件并处理了事件还会返回父级吗？" class="headerlink" title="如果截取了事件并处理了事件还会返回父级吗？"></a>如果截取了事件并处理了事件还会返回父级吗？</h5><p>会返回父类，因为父类需要确认子级是否已经处理了事件</p><h5 id="requestDisallowInterceptTouchEvent"><a href="#requestDisallowInterceptTouchEvent" class="headerlink" title="requestDisallowInterceptTouchEvent"></a>requestDisallowInterceptTouchEvent</h5><p>子view让其父view不做事件拦截，<br>在子view的onTouchEvent方法中调用parent.requestDisallowInterceptTouchEvent(true)方法，</p><p>如果父view拦截事件，是怎么通知到子view的onInterceptTouchEvent中调用disallowIntercepter？</p><p>在ScrollView中进行源码分析：<br>在onIntercepterTouchEvent中返回true，则进行拦截，在按下滑动一小部分距离后设置为false（ACTION_MOVE），可以进行事件传递，当然就可以调用disallowIntercepter方法进行处理，后续的值触发父view的机制，直接过滤掉了onIntercepterTouchEvent</p><p>所以在ScrollView中默认的onClickListener是不生效的</p><p>onIntercepterTouchEvent不执行，直接返回false，然后向下dispatch到子类</p><blockquote><p>该方法生效的前提是父view不拦截ACTION_DOWN事件，第一次的ACTION_DOWN事件可以传递到子view中，则后续的ACTION事件父view无法拦截</p></blockquote><h5 id="如何解决滑动冲突"><a href="#如何解决滑动冲突" class="headerlink" title="如何解决滑动冲突"></a>如何解决滑动冲突</h5><ol><li><p>外部拦截法：</p><p>重写父view的onIntercepterTouchEvent，在其中对触摸的坐标进行控制，在父view要拦截的时候拦截，在子view想要调用的时候不进行拦截</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">intercepted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) event.getX();</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">                intercepted = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">                <span class="keyword">if</span> (满足父容器的拦截要求) &#123;</span><br><span class="line">                    intercepted = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">                intercepted = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mLastXIntercept = x;</span><br><span class="line">        mLastYIntercept = y;</span><br><span class="line">        <span class="keyword">return</span> intercepted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>内部拦截法：</p><p>在子view的dispatchTouchEvent中在ACTION_DOWN事件下调用parent.requestDisallowInterceptTouchEvent(true);，设置不允许父view的拦截</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) event.getX();</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">deltaX</span> <span class="operator">=</span> x - mLastX;</span><br><span class="line">                <span class="type">int</span> <span class="variable">deltaY</span> <span class="operator">=</span> y - mLastY;</span><br><span class="line">                <span class="keyword">if</span> (父容器需要此类点击事件) &#123;</span><br><span class="line">                    parent.requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLastX = x;</span><br><span class="line">        mLastY = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该条件需要在父view的ACTION_DOWN事件可以传递到子view中才可以实现，所以需要在父view的onInterceptTouchEvent中不拦截父View的ACTION_DOWN事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="ACTION-CANCEL怎么理解？"><a href="#ACTION-CANCEL怎么理解？" class="headerlink" title="ACTION_CANCEL怎么理解？"></a>ACTION_CANCEL怎么理解？</h5><ul><li>在划出子view的布局后，onIntercepterTouchEvent进行拦截ACTION_MOVE事件，并将其转化为ACTION_CANCEL交给子view的处理，表示手指划出view所在区域</li><li>在父view进行拦截的时候，子view有可能接收到ACTION_CANCEL事件</li></ul><p>触摸事件的结束有两种状态，一种时ACTION_UP事件，另一种就是ACTION_CANCEL事件，正常在view的事件传递中，抬起手指的ACTION_UP事件会被监听，当父view认为不需要将后续的ACTION_MOVE事件传递给子View的时候，就会将ACTION_MOVE事件转化为ACTION_CANCEL事件，子View就会认为事件结束</p><blockquote><p>主要是父view在拦截中做了处理影响子view的触摸，不需要触摸就直接传ACTION_CANCEL。</p></blockquote><p><strong>使用TouchTarget（具体实现时mFirstTouchTarget）单链表存储触摸事件的，当置为CANCLE时，将触摸view在mFirstTouchEvent删除</strong></p><h5 id="事件到底是先到DecorView还是先到Window的？"><a href="#事件到底是先到DecorView还是先到Window的？" class="headerlink" title="事件到底是先到DecorView还是先到Window的？"></a>事件到底是先到DecorView还是先到Window的？</h5><p>ViewRootImpl——&gt;DecorView——&gt;Activity——&gt;PhoneWindow——&gt;DecorView——&gt;ViewGroup</p><p>为什么绕来绕去的呢，光DecorView就走了两遍。</p><ul><li>ViewRootImpl并不知道有Activity这种东西存在，它只是持有了DecorView。所以先传给了DecorView，而DecorView知道有Activity，所以传给了Activity。</li><li>Activity也不知道有DecorView，它只是持有PhoneWindow，所以这么一段调用链就形成了。</li></ul><h4 id="多点触控-非重点"><a href="#多点触控-非重点" class="headerlink" title="多点触控(非重点)"></a>多点触控(非重点)</h4><p>使用TouchTarge（mFirstTouchTarget）管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TouchTarget</span> &#123;</span><br><span class="line">        <span class="comment">// The touched child view.</span></span><br><span class="line">        <span class="keyword">public</span> View child;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The combined bit mask of pointer ids for all pointers captured by the target.</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> pointerIdBits;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The next target in the target list.</span></span><br><span class="line">        <span class="keyword">public</span> TouchTarget next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>view：触摸目标view</li><li>pointerIdBits：位运算（与、或）</li><li>next：链表指针</li></ul><p>第一个触摸目标，在ACTION_DOWN、ACTION_POINTER_DOWN时会触发寻找触摸目标过程（事件分发），所以DOWN事件会重置mFirstTouchTarget。</p><ul><li>单点触控，mFirstTouchEvent为单个对象</li><li>多点触控，在一个view上，也是单个对象</li><li>多点触控，在多个view上，会成为一个链表</li></ul><p>传入的view消耗了事件，则构建一个TouchTarget，并发至在mFirstTouchTarget的头部。多个view目标会头插在链表中。</p><blockquote><p>即便是多指触控，也都是使用ACTION_MOVE，不做区分，可以使用index获取</p></blockquote><h4 id="如果ViewGroup是横向滑动的，RecyclerView是纵向滑动的，当调用RecyclerView进行纵向滑动时，在横向滑动会怎么样？"><a href="#如果ViewGroup是横向滑动的，RecyclerView是纵向滑动的，当调用RecyclerView进行纵向滑动时，在横向滑动会怎么样？" class="headerlink" title="如果ViewGroup是横向滑动的，RecyclerView是纵向滑动的，当调用RecyclerView进行纵向滑动时，在横向滑动会怎么样？"></a>如果ViewGroup是横向滑动的，RecyclerView是纵向滑动的，当调用RecyclerView进行纵向滑动时，在横向滑动会怎么样？</h4><p>当使用纵向滑动，默认事件传递是viewPager到RecyclerView，即后续的所有事件都由RecyclerView进行处理，那么RecycleView没有横向事件，所以不会做处理，所以不会出现横向的滑动。</p><h4 id="View的加载流程"><a href="#View的加载流程" class="headerlink" title="View的加载流程"></a>View的加载流程</h4><h5 id="简述View的加载流程"><a href="#简述View的加载流程" class="headerlink" title="简述View的加载流程"></a>简述View的加载流程</h5><ol><li>通过Activity的setContentView方法间接调用Phonewindow的setContentView（），在PhoneWindow中通过getLayoutInflate（）得到LayoutInflate对象</li><li>通过LayoutInflate对象去加载View，主要步骤是</li></ol><p>（1）通过xml的Pull方式去解析xml布局文件，获取xml信息，并保存缓存信息，因为这些数据是静态不变的</p><p>（2）根据xml的tag标签通过反射创建View逐层构建View</p><p>（3）递归构建其中的子View，并将子View添加到父ViewGroup中</p><p>加载结束后就开始绘制view了</p><h4 id="View的绘制机制"><a href="#View的绘制机制" class="headerlink" title="View的绘制机制"></a>View的绘制机制</h4><img src="https://pic1.zhimg.com/80/v2-5fdce519c134bdb81a38e9feb31ffb2c_1440w.jpg" width="300"/><p>DecorView为最顶层的view，DecorView、TitleView和ContentView都为FrameLayout，</p><blockquote><p>当Activity对象被创建完毕后，会将DecorView添加到PhoneWindow中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联，view的绘制过程是由ViewRootImpl完成的。</p></blockquote><p><strong>所有的view都是依附在window上的，比如PopupWindow、菜单。</strong></p><blockquote><p>Window是个概念性的东西，你看不到他，如果你能感知它的存在，那么就是通过View，所以View是Window的存在形式，有了View，你才感知到View外层有一个皇帝的新衣——window</p></blockquote><p><strong>有视图的地方就有window</strong></p><h5 id="简述View的绘制流程"><a href="#简述View的绘制流程" class="headerlink" title="简述View的绘制流程"></a>简述View的绘制流程</h5><p><strong>深度便利</strong><br>主要分为3个方法，顺序执行：</p><ul><li>measure()：测量视图的大小，根据MeasureSpec进行计算大小</li><li>layout()：确定view的位置</li><li>draw()：绘制view。创建Canvas对象。六个步骤：①、绘制视图的背景；②、保存画布的图层（Layer）；③、绘制View的内容；④、绘制View子视图，如果没有就不用；⑤、还原图层（Layer）；⑥、绘制滚动条。</li></ul><h4 id="draw-中的具体流程是什么？"><a href="#draw-中的具体流程是什么？" class="headerlink" title="draw()中的具体流程是什么？"></a>draw()中的具体流程是什么？</h4><ol><li>绘制背景：drawBackground(canvas)</li><li>绘制自己的内容：onDraw(canvas)</li><li>绘制Children：dispatchDraw(canvas)</li><li>绘制装饰：onDrawForeground(canvas)</li></ol><h5 id="MeasureSpec分析"><a href="#MeasureSpec分析" class="headerlink" title="MeasureSpec分析"></a>MeasureSpec分析</h5><p>MeasureSpec是由父View的MeasureSpec和子View的LayoutParams通过简单的计算得出一个针对子View的测量要求，子view依据该值进行大小的绘制</p><p>MeasureSpec是个大小和模式的组合值。是一个32位的整型，将size（大小）和mode（模式）打包成一个int，其中高两位是mode，其余30位存储size（大小）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取测量模式</span></span><br><span class="line"><span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(measureSpec)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取测量大小</span></span><br><span class="line"><span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(measureSpec)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Mode 和 Size 生成新的SpecMode</span></span><br><span class="line"><span class="type">int</span> measureSpec=MeasureSpec.makeMeasureSpec(size, mode);</span><br></pre></td></tr></table></figure><p>测量模式有三种：</p><ul><li>EXACTLY: 相等于MATCH_CONTENT</li><li>AT_MOST: 相等于WRAP_CONTENT</li><li>UNSPECIFIED: 相等于具体的值</li></ul><h4 id="RelativeLayout、LinearLayout和ConstraintLayout"><a href="#RelativeLayout、LinearLayout和ConstraintLayout" class="headerlink" title="RelativeLayout、LinearLayout和ConstraintLayout"></a>RelativeLayout、LinearLayout和ConstraintLayout</h4><p>LinearLayout：</p><ul><li>weight设置导致二次测量，首先测量一遍大小onMeasure（非weight），然后根据weight在次测量，调整大小</li></ul><p>RelativeLayout：</p><ul><li>onMeasure执行两遍，对横向和纵向分别测量，所以是2遍</li></ul><p>ConstraintLayout：</p><ul><li>可以不使用嵌套，提供相对布局，并且支持权重布局，尽可能减少层级，提高性能，类似于flex布局</li></ul><p>对比</p><ol><li>同层级的布局，LinearLayout&lt;RelatvieLayout&#x3D;ConstraintLayout，因为LinearLayout执行onMeasure一遍，RelativeLayout执行两遍</li><li>LinearLayout会增加层级深度，RelativeLayout减少层级，所以通常下使用RelativeLayout，如果层级简单则使用LinearLayout</li></ol><blockquote><p>RelativeLayout的子View如果高度和RelativeLayout不同，会引发效率问题</p></blockquote><h4 id="setContentView的执行过程"><a href="#setContentView的执行过程" class="headerlink" title="setContentView的执行过程"></a>setContentView的执行过程</h4><ol><li>初始化windows</li><li>绑定ui布局</li></ol><h4 id="什么时候可以获得view的宽高"><a href="#什么时候可以获得view的宽高" class="headerlink" title="什么时候可以获得view的宽高"></a>什么时候可以获得view的宽高</h4><p>因为onMeasure和生命周期不同步，所以不能在onCreate，onStart，onResume中进行获取操作，</p><ol><li>在view.post方法中进行获取，内部实现是handler机制，回调的时候已经执行完了</li><li>在onWindowFocusChanged获取焦点后，view的绘制完成，可以在这里拿到view的宽高</li><li>使用ViewTreeObserver的回调也可以解决这个问题。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ViewTreeObserver</span> <span class="variable">observer</span> <span class="operator">=</span> tv1.getViewTreeObserver();</span><br><span class="line">        observer.addOnGlobalLayoutListener(<span class="keyword">new</span> <span class="title class_">ViewTreeObserver</span>.OnGlobalLayoutListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onGlobalLayout</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;</span><br><span class="line">                    tv1.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> tv1.getMeasuredWidth();</span><br><span class="line">                <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> tv1.getMeasuredHeight();</span><br><span class="line">                Log.d(<span class="string">&quot;tv1Width&quot;</span>, String.valueOf(width));</span><br><span class="line">                Log.d(<span class="string">&quot;tv1Height&quot;</span>, String.valueOf(height));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li><li>手动调用measure方法后，获取宽高</li></ol><h4 id="什么时候开始绘制Activity的view的？"><a href="#什么时候开始绘制Activity的view的？" class="headerlink" title="什么时候开始绘制Activity的view的？"></a>什么时候开始绘制Activity的view的？</h4><p>在DecorView添加(addView)到phoneWindows中时，触发measure，layout，draw方法</p><h4 id="PhoneWindow是在什么时候创建的？"><a href="#PhoneWindow是在什么时候创建的？" class="headerlink" title="PhoneWindow是在什么时候创建的？"></a>PhoneWindow是在什么时候创建的？</h4><p>在Activity的attch方法时，创建了PhoneWindow</p><h4 id="View的刷新机制"><a href="#View的刷新机制" class="headerlink" title="View的刷新机制"></a>View的刷新机制</h4><h5 id="requestLayout和invalidate区别是什么"><a href="#requestLayout和invalidate区别是什么" class="headerlink" title="requestLayout和invalidate区别是什么"></a>requestLayout和invalidate区别是什么</h5><p><strong>requestLayout</strong>：触发onMeasure,onLayout方法，大小和位置变化，不一定触发onDraw</p><p><strong>invalidate</strong>：触发performTraversals机制，导致view重绘，调用onDraw方法，主要是内容发生变化</p><p><strong>postInvalidate</strong>：异步调用invalidate方法</p><blockquote><p>invalidate如果是个view，那就只有自己本身会draw，如果是ViewGroup就是对子view进行重绘</p></blockquote><h4 id="简析Activity、Window、DecorView以及ViewRoot之间的错综关系"><a href="#简析Activity、Window、DecorView以及ViewRoot之间的错综关系" class="headerlink" title="简析Activity、Window、DecorView以及ViewRoot之间的错综关系"></a>简析Activity、Window、DecorView以及ViewRoot之间的错综关系</h4><ul><li><p>Activity是控制器</p></li><li><p>windows装载DecorView，并将DecorView交给ViewRoot进行绘制和交互，其唯一实现子类就是PhoneWindow，在attach中创建，是Activity和View交互的中间层，帮助Activity管理View。</p></li><li><p>DecorView是FrameLayout的子类，是视图的顶级view</p></li><li><p>viewRoot负责view的绘制和交互，实际的viewRoot就是ViewRootImpl类，是连接WMS和DecorView的纽带</p></li></ul><h4 id="setContentView执行的具体过程"><a href="#setContentView执行的具体过程" class="headerlink" title="setContentView执行的具体过程"></a>setContentView执行的具体过程</h4><ol><li>Activity实例化，执行<strong>attach</strong>方法，在attach中创建<strong>PhoneWindow</strong></li><li>执行onCreate方法，执行<strong>setContentView</strong>，先调用phoneWindow.setContentView(),然后开始根据不同的主题创建<strong>DecorView</strong>的结构，传入我们的<strong>xml</strong>文件，生成一个多结构的View</li><li>Activity调用<strong>onResume</strong>方法，调用<strong>WindowManager.addView</strong>()方法，随后在addView()方法中创建<strong>ViewRootImpl</strong></li><li>接着调用ViewRootImpl的setView方法，最终触发meaure，layout，draw方法进行渲染绘制，其中和WMS通过Binder交互，最终显示在界面上</li></ol><h4 id="四者的创建时机？"><a href="#四者的创建时机？" class="headerlink" title="四者的创建时机？"></a>四者的创建时机？</h4><ul><li>Activity：startActivity后，performLaunchActivity方法中创建</li><li>PhoneWindow：Activity的attach方法</li><li>DecorView：setConentView中创建</li><li>ViewRootImpl：onResume中调用WM.addView方法创建</li></ul><h4 id="dialog为什么不能用application创建？"><a href="#dialog为什么不能用application创建？" class="headerlink" title="dialog为什么不能用application创建？"></a>dialog为什么不能用application创建？</h4><p><a href="https://juejin.cn/post/6873669458742525960">Android-Window机制原理之Token验证(为什么Application的Context不能show dialog)</a></p><blockquote><p>token是WMS唯一用来标识系统中的一个窗口</p></blockquote><p>Dialog有一个PhoneWindow实例，属于应用窗口。Dialog最终也是通过系统的WindowManager把自己的Window添加到WMS上。Dialog是一个子Window，需要依附一个父window。</p><p>Dialog创建PhoneWindow时，token是null。只有传入Activity中的Context对象，Activity才会将自己的token给Dialog，这样，才会被WMS所识别，如果使用的不是Activit的token，就会报错BadTokenException</p><p>在application的情况下，将Dialog的window升级为系统window即可显示</p><h2 id="RecyclerView和ListView"><a href="#RecyclerView和ListView" class="headerlink" title="RecyclerView和ListView"></a>RecyclerView和ListView</h2><p><a href="https://blog.csdn.net/ListerCi/article/details/105480322">Android—RecyclerView进阶(4)—复用机制及性能优化</a></p><p><a href="https://blog.csdn.net/m0_37700275/article/details/89839599">RecyclerView问题汇总</a></p><p><a href="https://my.oschina.net/u/2458461/blog/4870218">老大爷都能看懂的RecyclerView动画原理</a></p><p><a href="https://blog.csdn.net/smileiam/article/details/88396546">RecyclerView性能优化及高级使用</a></p><h4 id="简述RecyclerView的刷新和缓存机制"><a href="#简述RecyclerView的刷新和缓存机制" class="headerlink" title="简述RecyclerView的刷新和缓存机制"></a>简述RecyclerView的刷新和缓存机制</h4><p><img src="https://user-gold-cdn.xitu.io/2019/7/19/16c09a12ec1bd3ba?imageslim" alt="img"></p><p>recyclerView中有三个重要方：</p><ul><li>Adapter：负责与数据集交互</li><li>LayoutManager：负责ItemView的布局，接管Measure，Layout，Draw过程</li><li>Recycler：负责管理ViewHolder</li><li>ViewHolder：视图的创建和显示在Recycler中有多个缓存池，</li></ul><p>mAttachedScrap被称为一级缓存，在重新layout时使用，主要是数据集发生变化的场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//屏幕内缓存scrap</span><br><span class="line">// mAttachedScrap在重新layout时使用，表示未与RecyclerView分离的ViewHolder</span><br><span class="line">final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;();</span><br><span class="line">// mChangedScrap用于数据变化等</span><br><span class="line">ArrayList&lt;ViewHolder&gt; mChangedScrap = null;</span><br><span class="line">//屏幕外缓存cache</span><br><span class="line">// mCachedViews和RecycledViewPool用于滑动时的缓存</span><br><span class="line">final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;();</span><br><span class="line">// 用户自定义缓存，一般不用</span><br><span class="line">private ViewCacheExtension mViewCacheExtension;</span><br><span class="line">//屏幕外缓存pool，数据会被重置，虚之行onBindViewHolder</span><br><span class="line">RecycledViewPool mRecyclerPool;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>mAttachedScrap：mAttachedScrap用于屏幕中可见表项的回收和复用，没有大小限制<br>mAttachedScrap生命周期起始于RecyclerView布局开始，终止于RecyclerView布局结束，无论mAttachedScrap中是否存在数据，都会清空，存储到mCacheView或者mRecyclerPool</li></ul><blockquote><p>插入或是删除itemView时，先把屏幕内的ViewHolder保存至AttachedScrap中</p></blockquote><blockquote><p>mAttachView和mCacheView都是通过比对position或者id（setStableIds（true）+getItemId复写）来确定是否复用的</p></blockquote><h4 id="缓存存储结构区别"><a href="#缓存存储结构区别" class="headerlink" title="缓存存储结构区别"></a>缓存存储结构区别</h4><ul><li>mAttachedScrap：ArrayList<ViewHolder></li><li>mCachedView：ArrayList<ViewHolder></li><li>mRecyclerPool：SparseArray<ScrapData>，ScrapData中包含ArrayList<ViewHolder>和其他标记位。</li></ul><h5 id="数据集发生变化"><a href="#数据集发生变化" class="headerlink" title="数据集发生变化"></a>数据集发生变化</h5><p>当数据集发生变化后，我们会调用notifyDataSetChanged()方法进行刷新布局操作，这时LayouManager通过调用detachAndScrapAttachedViews方法，将布局中正在显示的ItemView缓存到mAttachScrap中，重新构建ItemView时，LayoutManager会首先到mAttachScrap中进行查找<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDMzMTg0LTljYmYwNTQ3YTNjN2JkZDYucG5n?x-oss-process=image/format,png" alt="img"><br>如图所示，如果只是删除Data1数据，执行NotifyDataSetChanged()方法时，layoutManager将Data0到Data4缓存到mAttachScrap中，重新渲染布局时，会直接复用mAttachScrap中的四个布局，而得不到复用的布局会被放置在mRecyclerPool中。</p><blockquote><p>通过比较Position确定mAttachScrap中ItemView的复用，因为2的位置从2变为1，位置发生变化，但是还是通过比对position进行复用，那是因为在recyclerView重新渲染时，执行dispatchLayoutStep1()对position进行了校正。</p></blockquote><h5 id="滑动类型"><a href="#滑动类型" class="headerlink" title="滑动类型"></a>滑动类型</h5><p>在滑出可视区域后，会将ViewHolder存储在mCachedView中，当超出大小（默认大小为2+预加载item）后会将最先放进来的放在RecyclerViewPool中，根据viewType进行缓存，每个viewType缓存最多5个，从RecyclerViewPool中取出的数据，最终会调用onBindViewHolder()方法重新绑定</p><p>当发现有新的构建时，会去缓存找，找不到就去mRecyclerPool中寻找，如果有viewType相同的就取出来绑定并复用。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDMzMTg0LWRmYTljNDZmZmI1NDJkZTAucG5n?x-oss-process=image/format,png" alt="img"></p><p>RecyclerView滑动时，刚开始的时候回收了Position0和Position1，它们被添加到了mCachedViews中。随后回收Position2时，达到数量上限，最先进入mCachedViews的Position0被放进了mRecyclerPool中。<br>再看下方进入可视区域的3个Item，最初的Position6和Position7找不到对应的缓存，只能新建ViewHolder并绑定。当Position8滑入可视区域时，发现mRecyclerPool中有一个ViewType相等的缓存，则将其取出并绑定数据进行复用。</p><p>当有数据进行变动时，数据的position会发生变化。</p><p>stableId</p><blockquote><p>mChangedScrap—–&gt;mAttachedScrap—–&gt;mCachedViews—–&gt;ViewCacheExtension—–&gt;RecycledViewPool——–&gt;onCreatViewHolder</p><p>如果是单个viewType的RecyclerView，在滑动过程中，RecyclerPool最多可能存在一个数据</p></blockquote><p>假设一屏幕显示7个，向上滑动10个，总共bindView10个，又下滑10个（滑回去），总共8个（cacheView复用两个），一共18个</p><blockquote><p>在RecyclerView的v25版本中，引入<strong>预取机制</strong>，在初始化时，初始化8个，提前缓存一个数据</p></blockquote><h4 id="RecyclerView的优化"><a href="#RecyclerView的优化" class="headerlink" title="RecyclerView的优化"></a>RecyclerView的优化</h4><h5 id="放大缓存大小和缓存池大小"><a href="#放大缓存大小和缓存池大小" class="headerlink" title="放大缓存大小和缓存池大小"></a>放大缓存大小和缓存池大小</h5><ol><li>再滑动过程中，不论上滑还是下滑都会从<strong>mCachedViews</strong>中查找缓存，如果滑动频繁，可以通过<code>RecyclerView.setItemViewCacheSize(...)</code>方法增大<strong>mCachedViews</strong>的大小，减少onBindViewHolder()和onCreateViewHolder()调用</li><li>放大RecyclerViewPool的默认大小，现在是每个viewType中默认大小为5，如果显示数据过多，可放大默认大小<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置viewType类型的默认存储大小为10</span></span><br><span class="line">recyclerview.getRecycledViewPool().setMaxRecycledViews(viewType,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>如果多个RecyclerView中存在相同ViewType的ItemView，那么这些RecyclerView可以公用一个mRecyclerPool。</li></ol><h5 id="优化onBindViewHolder-耗时"><a href="#优化onBindViewHolder-耗时" class="headerlink" title="优化onBindViewHolder()耗时"></a>优化onBindViewHolder()耗时</h5><p>尽量少的在onBindViewHolder中执行操作，减少新建对象对内消耗</p><h5 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h5><p>多使用include,merage，viewStub,LinearLayout,FrameLayout</p><h5 id="measure-优化和减少requestLayout-调用"><a href="#measure-优化和减少requestLayout-调用" class="headerlink" title="measure()优化和减少requestLayout()调用"></a>measure()优化和减少requestLayout()调用</h5><p>当RecyclerView宽高的测量模式都是EXACTLY（精确数据）时，onMeasure()方法不需要执行dispatchLayoutStep1()等方法来进行测量。而当RecyclerView的宽高不确定并且至少一个child的宽高不确定时，要measure两遍。<br>因此将RecyclerView的宽高模式都设置为EXACTLY有助于优化性能。</p><p>如果RecyclerView的宽高都不会变，大小不变,方法<code>RecyclerView.setHasFixedSize(true)</code>可以避免数据改变时重新计算RecyclerView的大小，优化性能</p><h4 id="notifyDataSetChanged-与-notifyItemRangeChanged-的区别？"><a href="#notifyDataSetChanged-与-notifyItemRangeChanged-的区别？" class="headerlink" title="notifyDataSetChanged 与 notifyItemRangeChanged 的区别？"></a>notifyDataSetChanged 与 notifyItemRangeChanged 的区别？</h4><p>当notifyItemRangeChanged的区间在mRecyclerpool的大小的间隔内，则会通过mRecyclerpool复用viewholder，响应快速。</p><p>notifyItemInsert()和notifyItemRemove()方法，会通过RecyclerView的预加载流程，会将ViewHolder缓存到mAttachView中，避免重新create和bind。</p><p>notifyItemChanged(int)方法更新固定item</p><p>notifyDataSetChanged 会将所有viewholder放置在pool中，但是只能放置5个，其他就回收了，再构建时，需要重新绘制测量，界面会导致闪烁等</p><p>如果使用SetHasStableIds（true）,会将数据缓存到scrap中，复用时直接使用</p><h4 id="调用-notifyDataSetChanged-时闪烁的原因？"><a href="#调用-notifyDataSetChanged-时闪烁的原因？" class="headerlink" title="调用 notifyDataSetChanged 时闪烁的原因？"></a>调用 notifyDataSetChanged 时闪烁的原因？</h4><p>itemView重新测量和布局导致的(bindViewHolder)，并非createViewHolder。数据存储在RecyclerViewPool中，拿出需要重新BindView，itemView重新进行测量和布局，导致出现UI线程耗时，出现闪烁</p><p>如果使用SetHasStableIds（true）,会将数据缓存到scrap中，复用时直接使用</p><blockquote><p><strong>如果你的列表能够容纳很多行，而且使用 notifyDataSetChanged 方法比较频繁，那么你应该考虑设置一下容量大小。</strong></p></blockquote><h4 id="RecyclerView相对于ListView的优势是什么？"><a href="#RecyclerView相对于ListView的优势是什么？" class="headerlink" title="RecyclerView相对于ListView的优势是什么？"></a>RecyclerView相对于ListView的优势是什么？</h4><ol><li>屏幕外缓存可以直接在mCacheView()中复用，不需要重新BindView</li><li>recyclerPool可以提供给多个RecyclerView使用，在特定场景下，如viewpaper+多个列表页下有优势.</li><li>ListView缓存<strong>View</strong>，RecyclerView缓存<strong>ViewHolder</strong></li></ol><h4 id="adapter，viewHolder的作用-adapter中常用方法的作用是什么？"><a href="#adapter，viewHolder的作用-adapter中常用方法的作用是什么？" class="headerlink" title="adapter，viewHolder的作用?adapter中常用方法的作用是什么？"></a>adapter，viewHolder的作用?adapter中常用方法的作用是什么？</h4><ul><li>Adapter：负责与数据集交互</li><li>ViewHolder：视图的创建和显示，持有所有的用于绑定数据或者需要操作的View</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Item视图，并返回相应的ViewHolder</span></span><br><span class="line"><span class="keyword">public</span> VH <span class="title function_">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="type">int</span> viewType)</span></span><br><span class="line"><span class="comment">//绑定数据到正确的Item视图上。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(VH holder, <span class="type">int</span> position)</span></span><br><span class="line"><span class="comment">//返回该Adapter所持有的Item数量</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemCount</span><span class="params">()</span></span><br><span class="line"><span class="comment">//用来获取当前项Item(position参数)是哪种类型的布局</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemViewType</span><span class="params">(<span class="type">int</span> position)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="RecyclerPool为何使用SparseArray？"><a href="#RecyclerPool为何使用SparseArray？" class="headerlink" title="RecyclerPool为何使用SparseArray？"></a>RecyclerPool为何使用SparseArray？</h4><p>在RecyclerView中，第四级缓存，mRecyclerPool中存储是通过SparseArray存储ViewHolder，根据不同的ViewType的int值为键，ScrapData为值，ScrapData也是ArrayList<ViewHolder>及其标志位组成的，在进行put和get方法时，都是通过ViewType值获取。<br>不使用HashMap的原因是：</p><ul><li>我们定义了viewType为int值，则不用HashMap中较为繁重的类型，减少装箱问题耗时</li><li>量级较小，不需要HashMap的大量级处理</li><li>节省内存</li></ul><p>使用SparseArray存储空间id和空间对象关系。</p><p>HashMap更加复杂，SparseArray减少开销</p><h4 id="LayoutManager样式有哪些？setLayoutManager源码里做了什么？"><a href="#LayoutManager样式有哪些？setLayoutManager源码里做了什么？" class="headerlink" title="LayoutManager样式有哪些？setLayoutManager源码里做了什么？"></a>LayoutManager样式有哪些？setLayoutManager源码里做了什么？</h4><ul><li>LinearLayoutManager 水平或者垂直的Item视图。</li><li>GridLayoutManager 网格Item视图。</li><li>StaggeredGridLayoutManager 交错的网格Item视图。</li></ul><p>当之前设置过 LayoutManager 时，移除之前的视图，并缓存视图在 Recycler 中，将新的 mLayout 对象与 RecyclerView 绑定，更新缓存 View 的数量。最后去调用 requestLayout ，重新请求 measure、layout、draw。</p><h4 id="ItemDecoration的用途是什么？自定义ItemDecoration有哪些重写方法？分析一下addItemDecoration-源码？"><a href="#ItemDecoration的用途是什么？自定义ItemDecoration有哪些重写方法？分析一下addItemDecoration-源码？" class="headerlink" title="ItemDecoration的用途是什么？自定义ItemDecoration有哪些重写方法？分析一下addItemDecoration()源码？"></a>ItemDecoration的用途是什么？自定义ItemDecoration有哪些重写方法？分析一下addItemDecoration()源码？</h4><p>用途：来改变Item之间的偏移量或者对Item进行装饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装饰的绘制在Item条目绘制之前调用，所以这有可能被Item的内容所遮挡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas c, RecyclerView parent)</span></span><br><span class="line"><span class="comment">//装饰的绘制在Item条目绘制之后调用，因此装饰将浮于Item之上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDrawOver</span><span class="params">(Canvas c, RecyclerView parent)</span></span><br><span class="line"><span class="comment">//与padding或margin类似，LayoutManager在测量阶段会调用该方法，计算出每一个Item的正确尺寸并设置偏移量。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getItemOffsets</span><span class="params">(Rect outRect, <span class="type">int</span> itemPosition, RecyclerView parent)</span></span><br></pre></td></tr></table></figure><p>当通过这个方法添加分割线后，会指定添加分割线在集合中的索引，然后再重新请求 View 的测量、布局、(绘制)</p><h4 id="mChangedScrap和mAttachedScrap的区别是什么？"><a href="#mChangedScrap和mAttachedScrap的区别是什么？" class="headerlink" title="mChangedScrap和mAttachedScrap的区别是什么？"></a>mChangedScrap和mAttachedScrap的区别是什么？</h4><p>因为mChangedScrap表示item变化了，有可能是数据变化，有可能是类型变化，所以它的viewHolder无法重用，只能去RecycledViewPool中重新取对应的，然后再重新绑定。</p><p>mChangedScrap与mAttachedScrap，作用差不多。</p><p>mChangedScrap更多的用于pre-layout的动画处理。</p><p>然后一点需要注意：mChangedScrap只能在pre-layout中使用，mAttachedScrap可以在pre-layout与post-layout中使用。</p><p>mChangedScrap：ViewHolder.isUpdated() &#x3D;&#x3D; true</p><p>mAttachedScrap：1.被同时标记为<code>remove</code>和<code>invalid</code>；2.完全没有改变的<code>ViewHolder</code></p><p>在notifyItemRangeChanged，将数据变化的放置在mChangedScrap，没有变化的存储在mAttachScrap中，然后再取出来，mChangedScrap的数据会被移动到RecyclerPool中，进行重新绑定后再放回mChangedScrap中</p><p>mAttachScrap中得不到复用的会放置在recyclerpool中</p><h4 id="onMeasure过程"><a href="#onMeasure过程" class="headerlink" title="onMeasure过程"></a>onMeasure过程</h4><p>过程中包含mAttachedScrap的使用</p><p>dispatchLayoutStep1：预布局</p><p>dispatchLayoutStep2：实际布局</p><p>dispatchLayoutStep3：执行动画信息</p><h4 id="如何解决Glide错乱问题"><a href="#如何解决Glide错乱问题" class="headerlink" title="如何解决Glide错乱问题"></a>如何解决Glide错乱问题</h4><p>因为存在复用机制，8可能会复用1，在网络不好或者图片过大的情况下，8的图片加载缓慢，会先显示1的图片，加载后才会刷新掉。</p><p>方案：imageView设置tag，判断是否复用，如果是复用，就清除该控件上Glide的缓存</p><h4 id="RecyclerView卡顿优化"><a href="#RecyclerView卡顿优化" class="headerlink" title="RecyclerView卡顿优化"></a>RecyclerView卡顿优化</h4><p>通过BlockCanary进行主线程卡顿检测，打印出任务耗时，在卡顿时，打印出栈堆信息</p><p>原理是在looper.loop()死循环中，执行任务都是dispatchMessage方法，如果该方法超过一个任务的常规耗时，就会导致主线程卡顿</p><p>解决方法：</p><ol><li><p>放大mCacheView和RecyclerPool的大小，提高复用率，减少渲染</p></li><li><p>图片在滑动结束后再进行加载，避免在滑动的时候向主线程做更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView.addOnScrollListener(<span class="keyword">new</span> <span class="title class_">RecyclerView</span>.OnScrollListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onScrollStateChanged</span><span class="params">(RecyclerView recyclerView, <span class="type">int</span> newState)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newState == RecyclerView.SCROLL_STATE_IDLE) &#123;</span><br><span class="line">            Glide.with(mContext).resumeRequests();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Glide.with(mContext).pauseRequests();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在滑动过程中停止加载，在滑动结束后恢复加载</p></li><li><p>使用DiffUtil进行局部刷新优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DiffUtil会自动计算新老数据的差异，自动调用notifyxxx方法，将无脑的notifyDataSetChanged()进行优化</span></span><br><span class="line"><span class="comment">//并且伴随动画</span></span><br><span class="line">adapter.notifyItemRangeInserted(position, count);</span><br><span class="line">adapter.notifyItemRangeRemoved(position, count);</span><br><span class="line">adapter.notifyItemMoved(fromPosition, toPosition);</span><br><span class="line">adapter.notifyItemRangeChanged(position, count, payload);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文艺青年新宠</span></span><br><span class="line"><span class="comment">//利用DiffUtil.calculateDiff()方法，传入一个规则DiffUtil.Callback对象，和是否检测移动item的 boolean变量，得到DiffUtil.DiffResult 的对象</span></span><br><span class="line">DiffUtil.<span class="type">DiffResult</span> <span class="variable">diffResult</span> <span class="operator">=</span> DiffUtil.calculateDiff(<span class="keyword">new</span> <span class="title class_">DiffCallBack</span>(mDatas, newDatas), <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//利用DiffUtil.DiffResult对象的dispatchUpdatesTo（）方法，传入RecyclerView的Adapter，轻松成为文艺青年</span></span><br><span class="line">diffResult.dispatchUpdatesTo(mAdapter);</span><br><span class="line"><span class="comment">//别忘了将新数据给Adapter</span></span><br><span class="line">mDatas = newDatas;</span><br><span class="line">mAdapter.setDatas(mDatas);</span><br></pre></td></tr></table></figure></li><li><p>减少布局的嵌套和层级，减少过度绘制，尽量自定义view</p></li><li><p>如果Item高度固定，调用<code>RecyclerView.setHasFixedSize(true);</code>来避免<code>requestLayout</code>浪费资源</p></li><li><p>可以关闭动画，减少RecyclerView的渲染次数</p></li></ol><h4 id="RecyclerView的自适应高度"><a href="#RecyclerView的自适应高度" class="headerlink" title="RecyclerView的自适应高度"></a>RecyclerView的自适应高度</h4><ol><li>使用瀑布流布局StaggeredGridLayoutManager</li><li>重写LinearLayoutManager，onMeasure中重新测量子布局的大小</li></ol><h4 id="RecyclerView嵌套RecyclerView滑动冲突，NestedScrollView嵌套RecyclerView"><a href="#RecyclerView嵌套RecyclerView滑动冲突，NestedScrollView嵌套RecyclerView" class="headerlink" title="RecyclerView嵌套RecyclerView滑动冲突，NestedScrollView嵌套RecyclerView"></a>RecyclerView嵌套RecyclerView滑动冲突，NestedScrollView嵌套RecyclerView</h4><ol><li>同方向的情况下会造成滑动冲突，默认外层的RecyclerView可滑动<br>一般有两种处理方案：<strong>内部拦截法</strong>和<strong>外部拦截法</strong><br>这里推荐内部拦截法，通过设置requestDisallowInterceptTouchEvent(true)时，不让父RecyclerView拦截子类的事件</li><li>ScrollView嵌套RecyclerView同样可以使用这个方法解决。也可以使用NestedScrollView，该类就是为了解决滑动冲突问题，可以保证两View类都可以滑动，但是需要设置RecyclerView.setNestedScrollingEnabled(false)，取消RecyclerView本身的滑动效果。解决滑动的卡顿感</li></ol><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h4 id="简述-2"><a href="#简述-2" class="headerlink" title="简述"></a>简述</h4><p>帧动画：一连串的图片进行连贯的播放，形成动画。</p><p>补间动画：通过xml文件实现，实现 <strong>alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）</strong>，通过不断的绘制view，看起来移动了效果，实际上view没有变化，还在原地</p><p>属性动画：对于对象属性的动画，也可以使用xml配置，但是推荐代码配置，比xml更加方便。通过不断改变自己view的属性值，真正的改变view</p><blockquote><p>所有的补间动画都可以用属性动画实现</p></blockquote><h4 id="属性动画和补间动画的区别"><a href="#属性动画和补间动画的区别" class="headerlink" title="属性动画和补间动画的区别"></a>属性动画和补间动画的区别</h4><ol><li>补间动画虽然移动了，但是点击的还是原来的位置，点击事件允许触发。而属性动画不是，所以我们可以确认，属性动画才是真正实现了View的移动，补间动画的view其实只是在其他地方绘制了一个影子</li><li>Activity退出时，没有关闭动画，属性动画会导致Activity无法释放的内存泄漏，而补间动画不会发生这样的情况</li><li>xml的补间动画复用率极高，在页面切换过程中都有很好的效果</li></ol><blockquote><p>帧动画避免大图，否则会带来oom</p></blockquote><h4 id="属性动画中的差值器和估值器是什么？"><a href="#属性动画中的差值器和估值器是什么？" class="headerlink" title="属性动画中的差值器和估值器是什么？"></a>属性动画中的差值器和估值器是什么？</h4><p>差值器：定义动画随时间流逝的变化规律。通俗点就是动画的执行速度的变化，可以是由缓即快，由快即缓，也可以是匀速，也可以是弹性动画效果 ，LinearInterpolator（匀速差值器）</p><p>估值器：定义从初始值过渡到结束值的规则定义，TypeEvaluator，可以通俗的理解为位置的移动</p><h2 id="android系统启动流程"><a href="#android系统启动流程" class="headerlink" title="android系统启动流程"></a>android系统启动流程</h2><h4 id="android系统架构"><a href="#android系统架构" class="headerlink" title="android系统架构"></a>android系统架构</h4><h4 id="简述系统启动流程"><a href="#简述系统启动流程" class="headerlink" title="简述系统启动流程"></a>简述系统启动流程</h4><p>从系统层看：</p><ol><li>linux 系统层</li><li>Android系统服务层</li><li>Zygote</li></ol><p>从开机启动到Home Launcher：</p><ol><li>启动bootloader （小程序；初始化硬件）</li><li>加载系统内核 （先进入实模式代码在进入保护模式代码）</li><li>启动init进程（用户级进程 ，进程号为1）</li><li>启动Zygote进程（初始化Dalvik VM等）</li><li>启动Runtime进程</li><li>启动本地服务（system service）</li><li>启动 HomeLauncher</li></ol><h4 id="第一个启动的进程是什么？"><a href="#第一个启动的进程是什么？" class="headerlink" title="第一个启动的进程是什么？"></a>第一个启动的进程是什么？</h4><p>init进程，其他进程都是fork这个进程的</p><h4 id="init进程孵化出了什么进程？"><a href="#init进程孵化出了什么进程？" class="headerlink" title="init进程孵化出了什么进程？"></a>init进程孵化出了什么进程？</h4><ul><li>守护进程</li><li>Zygote进程，负责孵化应用进程</li><li>MediaServer进程</li></ul><h4 id="Zygote进程做了什么？"><a href="#Zygote进程做了什么？" class="headerlink" title="Zygote进程做了什么？"></a>Zygote进程做了什么？</h4><ul><li>创建Socket服务端</li><li>加载虚拟机</li><li>SystemServer进程</li><li>fork第一个应用进程—Launcher</li></ul><h4 id="为什么要创建Socket服务端？"><a href="#为什么要创建Socket服务端？" class="headerlink" title="为什么要创建Socket服务端？"></a>为什么要创建Socket服务端？</h4><ul><li>ServiceManager不能保证在孵化Zygote进程时就初始化好了，所以无法使用Binder</li><li>Binder属于多线程操作，fork不允许多线程操作，容易发生死锁，所以使用Socket</li></ul><h2 id="app启动流程"><a href="#app启动流程" class="headerlink" title="app启动流程"></a>app启动流程</h2><ol><li>用户点击 icon</li><li>系统开始加载和启动应用</li><li>应用启动：开启空白(黑色)窗口</li><li>创建应用进程</li><li>初始化Application</li><li>启动 UI 线程</li><li>创建第一个 Activity</li><li>解析(Inflater)和加载内容视图</li><li>布局(Layout)</li><li>绘制(Draw)</li></ol><p>源码分析</p><ol><li>LauncherActivity.startActivitySafely(intent)：使用intent启动</li><li>Activity.startActivity(intent)：</li><li>Activity.startActivityForResult(intent)：获取ApplicationThread成员变量，是一个Binder对象</li><li>Instrumentation.execStartActivity：ActivityManagerService的远程接口</li><li>ActivityManagerProxy.startActivity：通过Binder进入AMS</li><li>ActivityManagerService.startActivity</li><li>ActivityStack.startActivityMayWait：解析MainActivity的信息</li><li>ActivityStack.startActivityLocked：创建即将要启动的Activity的相关信息</li><li>ActivityStack.startActivityUncheckedLocked：获取intent标志位，新建Task栈，添加到AMS中</li><li>Activity.resumeTopActivityLocked：查看LauncherActivity状态，新建Activity的状态</li><li>ActivityStack.startPausingLocked：停止LauncherActivity，onPause</li><li>ApplicationThreadProxy.schedulePauseActivity</li><li>ApplicationThread.schedulePauseActivity</li><li>ActivityThread.queueOrSendMessage：在主线程通过Handler发送消息</li><li>H.handleMessage：Handler的回调</li><li>ActivityThread.handlePauseActivity：pause LauncherActivity</li><li>ActivityManagerProxy.activityPaused：进入AMS中的onPause事件</li><li>ActivityManagerService.activityPaused</li><li>ActivityStack.activityPaused</li><li>ActivityStack.completePauseLocked</li><li>ActivityStack.resumeTopActivityLokced：LauncherActivity已经onPause了</li><li>ActivityStack.startSpecificActivityLocked</li><li>ActivityManagerService.startProcessLocked：创建新进程</li><li>ActivityThread.main：app入口，添加looper循环</li><li>ActivityManagerProxy.attachApplication：通过Binder进入AMS中</li><li>ActivityManagerService.attachApplication</li><li>ActivityManagerService.attachApplicationLocked</li><li>ActivityStack.realStartActivityLocked</li><li>ApplicationThreadProxy.scheduleLaunchActivity：进入ApplicationThread</li><li>ApplicationThread.scheduleLaunchActivity</li><li>ActivityThread.queueOrSendMessage</li><li>H.handleMessage</li><li>ActivityThread.handleLaunchActivity</li><li>ActivityThread.performLaunchActivity：进入onCreat方法</li><li>MainActivity.onCreate</li></ol><p>总结：</p><p>1～11：Launcher通过Binder进程通知ActivityManagerService，他要启动一个Activity</p><p>12～16：ActivityManagerService通过Binder进程通知Launcher进入Pause阶段</p><p>17～24：Launcher告知我已进入pause阶段，ActivityManagerService创建新进程，用来启动ActivityThread。</p><p>25～27：ActivityThread通过Binder进程将ApplicationThread的Binder传递给ActivityManagerService，以便AMS可以直接用这个Binder通信</p><p>28～35：AMS通过Binder通知ActivityThread，你可以启动</p><p>这里以启动微信为例子说明</p><ol><li>Launcher通知AMS 要启动微信了，并且告诉AMS要启动的是哪个页面也就是首页是哪个页面</li><li>AMS收到消息告诉Launcher知道了，并且把要启动的页面记下来</li><li>Launcher进入Paused状态，告诉AMS，你去找微信吧</li></ol><p>上述就是Launcher和AMS的交互过程</p><ol><li>AMS检查微信是否已经启动了也就是是否在后台运行，如果是在后台运行就直接启动，如果不是，AMS会在新的进程中创建一个ActivityThread对象，并启动其中的main函数。</li><li>微信启动后告诉AMS，启动好了</li><li>AMS通过之前的记录找出微信的首页，告诉微信应该启动哪个页面</li><li>微信按照AMS通知的页面去启动就启动成功了。</li></ol><h2 id="Activity启动流程"><a href="#Activity启动流程" class="headerlink" title="Activity启动流程"></a>Activity启动流程</h2><p>参照app的启动流程</p><ul><li>ApplicationThread：ActivityThread的内部类，负责和AMS进行Binder通信</li><li>ActivityManagerService：服务端对象，负责管理系统中所有的Activity</li></ul><p>Activity 启动过程是由 ActivityMangerService（AMS) 来启动的，底层 原理是 Binder实现的 最终交给 ActivityThread 的 performActivity 方法来启动她</p><p>ActivityThread大概可以分为以下五个步骤</p><ol><li>通过ActivityClientRecord对象获取Activity的组件信息</li><li>通过Instrument的newActivity使用类加载器创建Activity对象</li><li>检验Application是否存在，不存在的话，创建一个，保证 只有一个Application</li><li>通过ContextImpl和Activity的attach方法来完成一些初始化操作</li><li>调用oncreat方法</li></ol><p>Android开启新进程的方式是通过复制第一个zygote（受精卵）进程实现，所以像受精卵一样快速分裂</p><h4 id="SystemServer是什么？有什么作用？他和zygote的关系是什么？"><a href="#SystemServer是什么？有什么作用？他和zygote的关系是什么？" class="headerlink" title="SystemServer是什么？有什么作用？他和zygote的关系是什么？"></a>SystemServer是什么？有什么作用？他和zygote的关系是什么？</h4><p>SystemServer也是一个进程，并且复制于zygote，系统中重要的服务都是在这个进程中开启的，如：AMS，PMS，WMS等</p><h4 id="ActivityManagerService是什么？什么时候初始化的？有什么作用？"><a href="#ActivityManagerService是什么？什么时候初始化的？有什么作用？" class="headerlink" title="ActivityManagerService是什么？什么时候初始化的？有什么作用？"></a>ActivityManagerService是什么？什么时候初始化的？有什么作用？</h4><p>简称AMS，负责系统中所有Activity的生命周期，控制其开启、关闭、暂停等<br>是在SystemServer进程开启时进行初始化的</p><h4 id="App-和-AMS-SystemServer-进程-还有-zygote-进程是如何通信的？"><a href="#App-和-AMS-SystemServer-进程-还有-zygote-进程是如何通信的？" class="headerlink" title="App 和 AMS(SystemServer 进程)还有 zygote 进程是如何通信的？"></a>App 和 AMS(SystemServer 进程)还有 zygote 进程是如何通信的？</h4><p>App 与 AMS 通过 <strong>Binder</strong> 进行 IPC 通信，AMS(SystemServer 进程)与 zygote 通过 <strong>Socket</strong> 进行 IPC 通信。</p><h4 id="AMS-PMS-WMS运行在一个线程中还是进程中？"><a href="#AMS-PMS-WMS运行在一个线程中还是进程中？" class="headerlink" title="AMS&#x2F;PMS&#x2F;WMS运行在一个线程中还是进程中？"></a>AMS&#x2F;PMS&#x2F;WMS运行在一个线程中还是进程中？</h4><p>运行在System_server进程中的线程中</p><h2 id="apk打包流程"><a href="#apk打包流程" class="headerlink" title="apk打包流程"></a>apk打包流程</h2><img src="/imageMd/package-1.png" width="50%" /><ol><li>aapt阶段，打包res目录，生成R.java</li><li>AIDL阶段，生成java文件</li><li>java编译器。将java文件通过javac编译生成<code>.class</code>文件</li><li>dex阶段，生成<code>.dex</code>文件</li><li>apk打包阶段，将文件打包成为apk文件</li><li>签名阶段，对apk进行签名</li><li>整理apk文件</li></ol><h4 id="aapt和aapt2的区别？"><a href="#aapt和aapt2的区别？" class="headerlink" title="aapt和aapt2的区别？"></a>aapt和aapt2的区别？</h4><p>aapt是全量编译，打包res目录，生成R文件</p><p>aapt2是差量编译，将变化的res目录进行重新打包，修改R文件</p><blockquote><p>aapt2中存在两部分，编译和链接</p><p>编译：将资源文件编译为二进制文件</p><p>链接：将编译后二进制文件进行合并，生成独立的文件</p></blockquote><p>在需要差量的时候，只需要重新编译二进制文件，再将这些二进制文件生成新的文件即可</p><h2 id="apk的组成"><a href="#apk的组成" class="headerlink" title="apk的组成"></a>apk的组成</h2><ol><li>AndroidManifest.xml</li><li>assets（项目中assets目录）</li><li>classes.dex</li><li>lib库</li><li>META-INF（校验文件）</li><li>res（资源文件）</li><li>resources.arsc（资源文件映射，索引文件）</li></ol><h2 id="apk安装流程"><a href="#apk安装流程" class="headerlink" title="apk安装流程"></a>apk安装流程</h2><h4 id="存在多少种安装方式，分别是什么？"><a href="#存在多少种安装方式，分别是什么？" class="headerlink" title="存在多少种安装方式，分别是什么？"></a>存在多少种安装方式，分别是什么？</h4><p>四种</p><ul><li>系统应用安装——————开机时完成安装，没有安装界面</li><li>网络下载安装——————通过市场应用完成，没有安装界面</li><li>adb命令安装——————没有安装界面</li><li>第三方应用安装——————sdk卡导入apk，点击安装，存在安装界面</li></ul><h4 id="安装过程中的重要路径"><a href="#安装过程中的重要路径" class="headerlink" title="安装过程中的重要路径"></a>安装过程中的重要路径</h4><p>应用安装涉及到如下几个目录：</p><p>system&#x2F;app —————系统自带的应用程序，获得adb root权限才能删除</p><p>data&#x2F;app  —————用户程序安装的目录。安装时把      apk文件复制到此目录</p><p>data&#x2F;data —————存放应用程序的数据</p><p>data&#x2F;dalvik-cache——–将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一)</p><h4 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h4><ol><li>将apk文件复制到&#x2F;data&#x2F;app目录</li><li>解析apk信息</li><li>dexopt操作（将dex文件优化为odex文件）</li><li>更新权限信息</li><li>发送安装完成广播</li></ol><h4 id="Android虚拟机发展史"><a href="#Android虚拟机发展史" class="headerlink" title="Android虚拟机发展史"></a>Android虚拟机发展史</h4><ol><li>android初期，Dalvik负责加载dex&#x2F;odex文件</li><li>2.2版本，JIT（即时编译）初次加入，每次启动的时候编译，耗时，耗电</li><li>4.4版本引入ART（Android RunTime）和AOT（Ahead-of-time）（运行前编译成机器码），与Dalvik共存</li><li>5.0版本全部采用ART编译器，不耗时，不耗电，在安装期间比较慢而已，而且会占用额外的控件存储机器码</li><li>7.0版本JIT回归，再用JIT&#x2F;AOT并用，即初次启动使用JIT，在手机空闲时，使用AOT生成机器码（只编译热点函数信息，用户操作次数越多，性能越高），这样保证了安装迅速，启动迅速，耗电少</li></ol><h4 id="Dalvik和ART是什么，有啥区别？"><a href="#Dalvik和ART是什么，有啥区别？" class="headerlink" title="Dalvik和ART是什么，有啥区别？"></a>Dalvik和ART是什么，有啥区别？</h4><h5 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h5><p>Dalvik是Google公司自己设计用于Android平台的虚拟机。支持已转换为<code>.dex格式</code>的Java应用程序的运行，.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。<br>Dalvik 经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。<br>很长时间以来，Dalvik虚拟机一直被用户指责为拖慢安卓系统运行速度不如IOS的根源。<br>2014年6月25日，Android L 正式亮相于召开的谷歌I&#x2F;O大会，Android L 改动幅度较大，谷歌将直接删除Dalvik，代替它的是传闻已久的ART。</p><h5 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h5><p>即Android Runtime<br>ART 的机制与 Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time）。这样的话，应用的启动(首次)和执行都会变得更加快速。</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>Dalvik是基于寄存器的，而JVM是基于栈的。<br>Dalvik运行dex文件，而JVM运行java字节码<br>自Android 2.2开始，Dalvik支持JIT（just-in-time，即时编译技术）。<br>优化后的Dalvik较其他标准虚拟机存在一些不同特性:<br>1.占用更少空间<br>2.为简化翻译，常量池只使用32位索引<br>3.标准Java字节码实行8位堆栈指令,Dalvik使用16位指令集直接作用于局部变量。局部变量通常来自4位的“虚拟寄存器”区。这样减少了Dalvik的指令计数，提高了翻译速度。<br>当Android启动时，Dalvik VM 监视所有的程序（APK），并且创建依存关系树，为每个程序优化代码并存储在Dalvik缓存中。Dalvik第一次加载后会生成Cache文件，以提供下次快速加载，所以第一次会很慢。<br>Dalvik解释器采用预先算好的Goto地址，每个指令对内存的访问都在64字节边界上对齐。这样可以节省一个指令后进行查表的时间。为了强化功能, Dalvik还提供了快速翻译器（Fast Interpreter）。</p><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><p>ART有什么优缺点呢？</p><p>优点：<br>1、系统性能的显著提升。<br>2、应用启动更快、运行更快、体验更流畅、触感反馈更及时。<br>3、更长的电池续航能力。<br>4、支持更低的硬件。<br>缺点：<br>1.机器码占用的存储空间更大，字节码变为机器码之后，可能会增加10%-20%<br>2.应用的安装时间会变长</p><h4 id="dex-class-odex的区别"><a href="#dex-class-odex的区别" class="headerlink" title=".dex .class .odex的区别"></a>.dex .class .odex的区别</h4><p>.dex是谷歌对.class文件进行了优化后得到的文件格式</p><ol><li>.dex去除了.class中冗余的信息，更加轻量</li><li>.class内存占用大，不适合移动端，堆栈的加栈模式，加载速度慢，文件IO操作多，类查找慢</li></ol><p>.dex文件在虚拟机进行加载时，会预加载成.odex文件，.odex文件对.dex文件进行了优化，避免了重复验证和优化处理，启动时，可直接接在odex文件，提升app启动的速度</p><h4 id="简述安装流程"><a href="#简述安装流程" class="headerlink" title="简述安装流程"></a>简述安装流程</h4><ol><li><p>使用installPackageAsUser判断安装来源</p></li><li><p>校验后（权限，存储空间，安全）将apk文件copy至data&#x2F;app目录</p></li><li><p>解析apk信息，覆盖安装或者安装新应用</p></li><li><p>Dalvik中将dex优化为odex文件</p><pre><code>  ART将dex翻译为oat文件（机器码）预编译过程</code></pre></li><li><p>创建&#x2F;data&#x2F;data&#x2F;包名    存放应用数据，发送广播结束安装</p></li></ol><h2 id="接口加密"><a href="#接口加密" class="headerlink" title="接口加密"></a>接口加密</h2><h4 id="项目中的接口加密技巧"><a href="#项目中的接口加密技巧" class="headerlink" title="项目中的接口加密技巧"></a>项目中的接口加密技巧</h4><p>在版本中写死一个密钥，首个接口请求后返回该app的密钥。</p><p>对上传的get，post请求的参数以ASCII码进行排序+密钥后生成md5值，添加到header中，传递给服务器</p><p>服务器端根据获取到的参数依据同样的规则生成md5后进行比较，如果相同，比较时间戳是否在5秒内，通过则成功</p><p>不使用token机制的原因是本产品不存在账号密码等机制，应用可能一直保持在线状态，不会下线，需要协调token的时效性，所以不使用该方案。</p><p>缺点：token机制一台机子只允许一个token进行访问，而上述方案没有该限制</p><h4 id="常规token校验机制"><a href="#常规token校验机制" class="headerlink" title="常规token校验机制"></a>常规token校验机制</h4><img src="/imageMd/token-1.png" width="60%"/><p>适用于存在账户名密码的应用</p><h2 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h2><h4 id="ANR条件？"><a href="#ANR条件？" class="headerlink" title="ANR条件？"></a>ANR条件？</h4><p>Service执行的操作最多是20s，BroadcastReceiver是10s，Activity是5s，超过时间发生ANR</p><h4 id="ANR原理解析"><a href="#ANR原理解析" class="headerlink" title="ANR原理解析"></a>ANR原理解析</h4><p>Application Not Responding</p><ol><li>主线程频繁进行IO操作，比如读写文件或者数据库；</li><li>硬件操作如进行调用照相机或者录音等操作；</li><li>多线程操作的死锁，导致主线程等待超时；</li><li>主线程操作调用join()方法、sleep()方法或者wait()方法；</li><li>耗时动画&#x2F;耗资源行为导致CPU负载过重</li><li>system server中发生WatchDog ANR；</li><li>service binder的数量达到上限</li></ol><p>在应用程序运行过程中，通过send一个延迟的handler，延迟时间为设置的anr时间，如果到时间，没有执行完任务&#x2F;没有移除handler任务，就会调用appNotResponding方法，触发anr</p><blockquote><p>主要在AMS和WMS中进行控制，通过获取&#x2F;data&#x2F;anr&#x2F;trace.txt进行分析</p></blockquote><h4 id="什么情况下会导致oom？"><a href="#什么情况下会导致oom？" class="headerlink" title="什么情况下会导致oom？"></a>什么情况下会导致oom？</h4><ol><li>大图片存储导致oom，内存溢出<ul><li>使用软弱引用，当内存不足时，删除Bitmap缓存</li><li>调用Bitmap.recycle()快速回收，但是慎用，容易报错</li></ul></li><li>除了程序计数器之外的内存模型都会发生oom<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.StackOverflowError:死循环/递归调用产生的</span><br></pre></td></tr></table></figure></li><li>关闭流文件、数据库cursor等对象关闭</li><li>创建很多线程会导致oom，因为开辟线程需要对虚拟机栈，本地方法栈，程序计数器，开辟内存，线程数量过多，会导致OOM</li></ol><h4 id="如何将应用设置为Launcher？"><a href="#如何将应用设置为Launcher？" class="headerlink" title="如何将应用设置为Launcher？"></a>如何将应用设置为Launcher？</h4><p>设置HOME，DEFAULT。</p><h4 id="MVC-MVP-MVVM"><a href="#MVC-MVP-MVVM" class="headerlink" title="MVC,MVP,MVVM"></a>MVC,MVP,MVVM</h4><p><a href="https://blog.csdn.net/lmj623565791/article/details/46596109">浅谈MVP in Android</a></p><h5 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h5><ul><li>View：对应于布局文件</li><li>Model：业务逻辑和实体模型</li><li>Controller：对应于Activity</li></ul><p><strong>缺点</strong>：</p><ol><li>Controller（Activity）中处理的逻辑过于繁重，原因是在Activity有太多操作View的代码，View和Controller绑定太过紧密</li></ol><blockquote><p>android中算不上mvc模式，Activity可以叫View层，也可以叫Controller层，所有代码基本都在Activity中</p></blockquote><h5 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h5><ul><li>View 对应于Activity，负责View的绘制以及与用户交互</li><li>Model 依然是业务逻辑和实体模型</li><li>Presenter 负责完成View于Model间的交互</li></ul><p><img src="http://img-blog.csdn.net/20150622212916054" alt="img"></p><p>因为Activity任务过于繁重，所以在Activity中提炼出一个Presenter层，该层主要通过接口和View层交互，同时获得View层的反馈</p><p><strong>优点</strong></p><ol><li>大大减轻了Activity的逻辑，将View和Presenter做分离，让项目更加简单明确</li></ol><p><strong>缺点</strong></p><ol><li>每个功能需要添加一个Presenter类，添加各种借口，增加开发量</li><li>Presenter层持有Activity层的引用，需要注意内存泄漏或空指针的问题</li></ol><h5 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h5><ol><li>View：View层</li><li>ViewModel层：JetPack中的ViewModel组件，配合LiveData+DataBinding，保证View和ViewModel之间的交互，双向绑定，数据的更新可以实时绑定到界面中。</li><li>Model层：数据层</li></ol><p>ViewModel层中代替了Presenter的作用，里边做具体的逻辑，ViewModel与Activity的绑定通过反射构建，通过LiveData达到响应式，在Activity中调用ViewModel的逻辑，并实时更新到界面。</p><p><strong>优点</strong></p><ol><li>ViewModel+LiveData同Activity的生命周期绑定，当Avtivity不存在后，会销毁ViewModel，减少内存泄漏</li><li>提供Activity中多个Fragment的数据共享和逻辑调用</li><li>提供响应式编程，提供解决问题新方向</li><li>优秀的架构思想+官方支持&#x3D;强大</li><li>代码量少，双向绑定减少UI的更新代码</li></ol><p><strong>缺点</strong></p><ol><li>降低了View的复用性，因为添加了很多DataBinding的代码，绑定到Activity中</li><li>难以定位bug，流程许多地方都是自动化更新，执行，无法确定当中哪一个环节出现问题（数据逻辑问题还是界面显示问题）</li></ol><h4 id="SharedPreferences-commit-apply使⽤区别"><a href="#SharedPreferences-commit-apply使⽤区别" class="headerlink" title="SharedPreferences commit apply使⽤区别"></a>SharedPreferences commit apply使⽤区别</h4><ol><li><p>commit具有回调</p></li><li><p>apply将信息推送到主存，异步提交到文件，commit同步提交到文件</p></li></ol><h4 id="Bitmap解析"><a href="#Bitmap解析" class="headerlink" title="Bitmap解析"></a>Bitmap解析</h4><h5 id="Bitmap是怎么存储图片的？"><a href="#Bitmap是怎么存储图片的？" class="headerlink" title="Bitmap是怎么存储图片的？"></a>Bitmap是怎么存储图片的？</h5><p>Bitmap是图片在内存中的表达形式，存储的是有限个像素点，每个像素点存储着ARGB值，代表每个像素所代表的颜色（RGB）和透明度（A）</p><h5 id="Bitmap图片的内存是怎么计算的？"><a href="#Bitmap图片的内存是怎么计算的？" class="headerlink" title="Bitmap图片的内存是怎么计算的？"></a>Bitmap图片的内存是怎么计算的？</h5><p>图片内存 &#x3D; 宽 * 高 * 每个像素所占字节<br>每个像素所占字节和Bitmap.Config有关：</p><ul><li>ARGB_8888：常用类型，总共32位，<strong>4</strong>个字节，分别表示透明度和RGB通道。</li><li>ARGB_4444：<strong>2</strong>个字节</li><li>RGB_565：16位，<strong>2</strong>个字节，只能描述RGB通道。</li><li>ALPHA_8：<strong>1</strong>个字节</li></ul><h5 id="Bitmap加载优化？不改变图片质量的情况下怎么优化？"><a href="#Bitmap加载优化？不改变图片质量的情况下怎么优化？" class="headerlink" title="Bitmap加载优化？不改变图片质量的情况下怎么优化？"></a>Bitmap加载优化？不改变图片质量的情况下怎么优化？</h5><ol><li>修改Bitmap.Config，降低bitmap每个像素所占用的字节大小，替换格式为RGB_565，这样，内存直接缩小1倍</li><li>修改inSampleSize采样率，降低图片的大小，不影响图片的质量，控制每隔inSampleSize个像素进行一次采集</li></ol><blockquote><p>inSampleSize为1时，为原图大小。大于1时，比如2时，宽高就会缩小为原来的1&#x2F;2</p><p>inSampleSize进行2的幂取整操作，1，2，4，8等</p></blockquote><h5 id="Bitmap内存复用怎么实现？"><a href="#Bitmap内存复用怎么实现？" class="headerlink" title="Bitmap内存复用怎么实现？"></a>Bitmap内存复用怎么实现？</h5><p>如果在一个imageView中加载多种不同的Bitmap图片，如果频繁的去创建bitmap，获取内存，释放内存，从而导致大量GC，内存抖动。<br>在使用Bitmap时，使用inBitmap配合inMutable参数，复用Bitmap内存。在4.4之前，只能复用内存大小相同的Bitmap，4.4之后，新Bitmap内存大小小于或等于复用Bitmap空间的，可以复用</p><h5 id="高清大图如何加载？"><a href="#高清大图如何加载？" class="headerlink" title="高清大图如何加载？"></a>高清大图如何加载？</h5><p>使用BitmapRegionDecoder属性进行部分加载，根据界面滑动，不断更新部分图片的位置</p><h5 id="intent可以传递bitmap吗？"><a href="#intent可以传递bitmap吗？" class="headerlink" title="intent可以传递bitmap吗？"></a>intent可以传递bitmap吗？</h5><p>可以，bitmap是parcelable序列化过的，也可以转化成byte[]进行传递</p><p>大小受限1M，因为binder的大小是1M，binder的线程数不大于16</p><h5 id="Bitmap内存在各个android版本的存储？"><a href="#Bitmap内存在各个android版本的存储？" class="headerlink" title="Bitmap内存在各个android版本的存储？"></a>Bitmap内存在各个android版本的存储？</h5><p><a href="https://www.jianshu.com/p/d5714e8987f3">Android Bitmap变迁与原理解析（4.x-8.x）</a></p><ol><li>2.3版本之前：存储在本地内存中，不及时回收（recycler()方法），会触发OOM</li><li>2.3版本到7.0版本：像素数据和对象数据都存储在堆中</li><li>8.0以后：将对象存储在本地内存中（非java内存），通过NativeAllocationRegistry对bitmap进行回收<blockquote><p>Fresco 对这个有详细的描述</p></blockquote></li></ol><h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p>深拷贝：拷贝堆区中值<br>浅拷贝：拷贝堆区中的引用地址</p><h4 id="创建一个对象的方式？"><a href="#创建一个对象的方式？" class="headerlink" title="创建一个对象的方式？"></a>创建一个对象的方式？</h4><ol><li>使用new关键字创建</li><li>Class.newInstance反射创建</li><li>Constructor.newInstance反射创建</li><li>利用clone方法实现（浅拷贝）</li><li>通过反序列化实现（深拷贝）</li></ol><h4 id="界面卡顿的原因"><a href="#界面卡顿的原因" class="headerlink" title="界面卡顿的原因"></a>界面卡顿的原因</h4><ol><li>UI线程存在耗时操作</li><li>视图渲染时间过长，导致卡顿</li><li>频繁gc，内存抖动</li></ol><h4 id="冷启动、温启动、热启动"><a href="#冷启动、温启动、热启动" class="headerlink" title="冷启动、温启动、热启动"></a>冷启动、温启动、热启动</h4><p>冷启动：app首次启动，或者上次正常关闭后的启动，需要创建app的进程</p><ol><li>启动系统进程。加载启动app进程，创建app进程</li><li>启动app进程任务。渲染屏幕，加载布局等</li></ol><p>温启动：系统进程存在，app非正常关闭，只需要执行第二步，需要创建Activity或者重新布局等</p><p>热启动：热启动就是App进程存在，并且Activity对象仍然存在内存中没有被回收。所以热启动的开销最少，这个过程只会把Activity从后台展示到前台，无需初始化，布局绘制等工作</p><blockquote><p>冷启动可以认为是android标准启动流程</p></blockquote><h4 id="Android类加载器"><a href="#Android类加载器" class="headerlink" title="Android类加载器"></a>Android类加载器</h4><p>Android从ClassLoader中派生出两个类加载器：PathClassLoader和DexClassLoader</p><p>DexClassLoader：是一个可以从包含classes.dex实体的.jar或.apk文件中加载classes的类加载器。可以用于实现dex的动态加载、代码热更新等等。</p><p>PathClassLoader：可以操作在本地文件系统的文件列表或目录中的classes</p><blockquote><p>DexClassLoader：能够加载未安装的jar&#x2F;apk&#x2F;dex<br>PathClassLoader：只能加载系统中已经安装过的apk</p></blockquote><h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><p>当一个类需要被初始化加载时，总会先把加载请求传递给父加载器，最终会传递到最高层加载器进行加载。父类加载器会检查是否加载过该类，如果没有加载过，则加载，若无法加载，会传递给子类加载器加载。</p><h5 id="为何要使用双亲委派"><a href="#为何要使用双亲委派" class="headerlink" title="为何要使用双亲委派"></a>为何要使用双亲委派</h5><ol><li>首先明确，jvm认为不同加载器加载的类为两个不同的对象，所以为了系统安全性，需要保证相同的类要被同一个类加载器加载</li><li>避免了重复加载，如果父类加载过，直接使用父类加载过的类。</li></ol><h5 id="能不能自己写个类叫java-lang-System？"><a href="#能不能自己写个类叫java-lang-System？" class="headerlink" title="能不能自己写个类叫java.lang.System？"></a>能不能自己写个类叫java.lang.System？</h5><p>不可以，通过双亲委派该类名被加载为系统类，不会加载自己写的类。<br>如果非要实现这个效果，需要绕过双亲委派机制，实现自己的类加载器进行加载</p><h4 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h4><img src="https://upload-images.jianshu.io/upload_images/1115031-70a55fecac4da43b.png" width="60%"/><p><strong>PathClassLoader</strong>:只能加载已经安装到Android系统中的apk文件（&#x2F;data&#x2F;app目录），是Android默认使用的类加载器。</p><p><strong>DexClassLoader</strong>:可以加载任意目录下的dex&#x2F;jar&#x2F;apk&#x2F;zip文件，比PathClassLoader更灵活，是实现热修复的重点。</p><p>阿里系：DeXposed、andfix：从底层二进制入手（c语言）。阿里andFix hook 方法在native的具体字段。<br>art虚拟机上是一个叫ArtMethod的结构体。通过修改该结构体上有bug的字段来达到修复bug方法的目的，<br>但这个artMethod是根据安卓原生的结构写死的，国内很多第三方厂家会改写ArtMethod结构，导致替换失效。<br>腾讯系：tinker：从java加载机制入手。qq的dex插装就类似上面分析的那种。通过将修复的dex文件插入到app的dexFileList的前面，达到更新bug的效果，但是不能及时生效，需要重启。<br>但虚拟机在安装期间会为类打上CLASS_ISPREVERIFIED标志，是为了提高性能的，我们强制防止类被打上标志是否会有些影响性能<br>美团robust：是在编译器为每个方法插入了一段逻辑代码，并为每个类创建了一个ChangeQuickRedirect静态成员变量，当它不为空会转入新的代码逻辑达到修复bug的目的。<br>优点是兼容性高,但是会增加应用体积</p><ol><li>startActivity 的时候最终会走到 AMS 的 startActivity 方法</li><li>系统会检查一堆的信息验证这个 Activity 是否合法。</li><li>然后会回调 ActivityThread 的 Handler 里的 handleLaunchActivity</li><li>在这里走到了 performLaunchActivity 方法去创建 Activity 并回调一系列生命周期的方法</li><li>创建 Activity 的时候会创建一个 LoaderApk对象，然后使用这个对象的 getClassLoader 来创建 Activity</li><li>我们查看 getClassLoader() 方法发现返回的是 PathClassLoader，然后他继承自 BaseDexClassLoader</li><li>然后我们查看 BaseDexClassLoader 发现他创建时创建了一个 DexPathList 类型的 pathList对象，然后在 findClass 时调用了 pathList.findClass 的方法</li><li>然后我们查看 DexPathList类 中的 findClass 发现他内部维护了一个 Element[] dexElements的dex 数组，findClass 时是从数组中遍历查找的</li></ol><h4 id="sqlite怎么保证数据可见性和线程安全性？"><a href="#sqlite怎么保证数据可见性和线程安全性？" class="headerlink" title="sqlite怎么保证数据可见性和线程安全性？"></a>sqlite怎么保证数据可见性和线程安全性？</h4><p>sqlite不支持多个数据库连接进行写操作，但是使用同一个SQLiteHelper连接，可以进行多线程读和写，同一个连接下，sqlite内部有锁机制，不会出现异常，由于有锁的机制，所以是阻塞的，并不是真正的并发</p><p>延伸：SharedPreference是线程安全的，内部使用sychronized的</p><h4 id="bundle的数据结构，为什么intent要使用bundle？"><a href="#bundle的数据结构，为什么intent要使用bundle？" class="headerlink" title="bundle的数据结构，为什么intent要使用bundle？"></a>bundle的数据结构，为什么intent要使用bundle？</h4><p>内部存储ArrayMap，key是int数组，value是object数组，使用Bundle传递对象和对象数组的时候会默认使用序列化，不用我们做处理。</p><p>key是hash值，value[]是存储的数据key值，和value值，采用二分法排序，使用二分法查找</p><p>优势：省内存，小数据上占优势。</p><h4 id="大图传输"><a href="#大图传输" class="headerlink" title="大图传输"></a>大图传输</h4><blockquote><p>文件描述符是一个简单的整数，用以标明每一个被进程所打开的文件和socket。第一个打开的文件是0，第二个是1，依此类推。<br>socket：如果是网络中，会使用ip号+port号方式为<strong>套接字地址</strong>，但是如果同一台主机上两个进程间通信用套接字,还需要指定ip地址,有点过于繁琐. 这个时候就需要用到UNIX Domain Socket, 简称UDS,UDS不需要IP和Port, 而是通过一个文件名来表示<br>（int,  (AF_UNIX,文件路径)）</p></blockquote><ol><li>直接传输Bitmap，Bitmap实现Parcelable序列化，所以可以直接在内存中传输，所以可以直接通过Bundle传输过去，但是限制大小为1M。</li><li>可以存储在文件中，传输一个文件路径过去</li><li>使用Bundle的putBinder方法，通过Binder发送，其实putBinder传输过去的只是一个文件描述符fd，获取到fd后，从共享内存中获取到Bitmap</li></ol><blockquote><p>而用Intent&#x2F;bundle直接传输的时候，会禁用文件描述符fd，只能在parcel的缓存区中分配空间来保存数据，所以无法突破1M的大小限制</p></blockquote><h4 id="webview"><a href="#webview" class="headerlink" title="webview"></a>webview</h4><h5 id="android调用js代码"><a href="#android调用js代码" class="headerlink" title="android调用js代码"></a>android调用js代码</h5><ol><li>通过loadUrl的方法直接调用js方法，会刷新页面，没有返回值</li><li>evaluateJavascript()方法，android4.4以后使用，不会刷新页面，有返回值</li></ol><img src="https://upload-images.jianshu.io/upload_images/944365-30f095d4c9e638fd.png" width="100%" /><h5 id="js调用android代码"><a href="#js调用android代码" class="headerlink" title="js调用android代码"></a>js调用android代码</h5><ol><li><p>addJavascriptInterface()方法进行对象映射，<code>存在漏洞</code> 4.2以下</p><p>创建一个类，使用@JavascriptInterface注解标识方法，使用addJavascriptInterface()为js创建对象</p><p>漏洞：</p><ul><li>通过反射获取到这个类的所有方法和系统类，进行获取信息泄漏</li><li>4.2后添加注解避免漏洞攻击</li></ul></li><li><p>webViewClient.shouldOverrideUrlLoading()拦截url    <code>不存在漏洞</code></p><p>在js中传入url，携带参数，拼接到url中，在shouldOverrideUrlLoading获取</p></li><li><p>触发js弹窗向android发消息。之后再回调中通过2方式的url传输消息</p></li></ol><img src="https://upload-images.jianshu.io/upload_images/944365-8c91481325a5253e.png" width="100%"/><p>内存泄漏：加弱引用即可</p><h4 id="要实现可以拖动的View该怎么做？"><a href="#要实现可以拖动的View该怎么做？" class="headerlink" title="要实现可以拖动的View该怎么做？"></a>要实现可以拖动的View该怎么做？</h4><p>使用windowManager的updateViewLayout方法吗，实时传入手指的坐标就可以移动window</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">btn.setOnTouchListener &#123; v, event -&gt;</span><br><span class="line">    <span class="keyword">val</span> index = event.findPointerIndex(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">when</span> (event.action) &#123;</span><br><span class="line">        ACTION_MOVE -&gt; &#123;</span><br><span class="line">            windowParams.x = event.getRawX(index).toInt()</span><br><span class="line">            windowParams.y = event.getRawY(index).toInt()</span><br><span class="line">            windowManager.updateViewLayout(btn, windowParams)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Android新知识"><a href="#Android新知识" class="headerlink" title="Android新知识"></a>Android新知识</h2><h4 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h4><p>响应式编程：根据响应去触发动作</p><p>使用观察者模式调用，使用于逻辑复杂的操作可以使用Rxjava做异步处理</p><ol><li>按钮短300ms内不允许重复点击</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RxView.clicks(button).debounce(<span class="number">300</span>, TimeUnit.MILLISECONDS).subscribe(<span class="keyword">new</span> <span class="title class_">Action1</span>&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(Void aVoid)</span> &#123;</span><br><span class="line">                Log.i(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;clicked&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>轮询，定时执行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每隔两秒执行一次</span></span><br><span class="line">   Observable.interval(<span class="number">2</span>, <span class="number">2</span>, TimeUnit.SECONDS).subscribe(<span class="keyword">new</span> <span class="title class_">Action1</span>&lt;Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(Long aLong)</span> &#123;</span><br><span class="line">                <span class="comment">//TODO WHAT YOU WANT</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>消息传递，可取代EventBus</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//发布消息</span><br><span class="line">RxBus.getInstance().post(&quot;SomeChange&quot;);</span><br><span class="line"></span><br><span class="line">//接收消息并处理</span><br><span class="line">Subscription mSubscription = RxBus.getInstance().toObserverable(String.class).subscribe(new Action1&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void call(String s) &#123;</span><br><span class="line">                handleRxMsg(s);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//取消订阅</span><br><span class="line">mSubscription.unsubscribe();</span><br></pre></td></tr></table></figure><h4 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h4><p>一系列辅助android开发者的使用工具，统称Jetpack</p><p>提供新组件，比如导航组件，分页组件，切片组件等，例如mvvm中的LiveData，viewmodel都属于Jetpack组件</p><p>paging,room,livedata,viewmodel,lifecycler,compose,databinding,viewbinding</p><p>Jetpack在androidx中进行发布，androidx也属于Jetpack</p><h4 id="AndroidX"><a href="#AndroidX" class="headerlink" title="AndroidX"></a>AndroidX</h4><p>androidx空间中包含Jetpack库，</p><p>之前使用android-support-v4(最低支持1.6) 和 android-support-v7（最低支持2.1）库做支持，androidx提出后，对support-v4 和 support-v7库不再做维护</p><h4 id="MVVM-1"><a href="#MVVM-1" class="headerlink" title="MVVM"></a>MVVM</h4><img src="https://upload-images.jianshu.io/upload_images/1813550-356c0729e43b8148.jpg" width="70%"/><p>LiveData使用观察者模式观察生命周期，在onStart和onResume时回调onChanged，确保liveData对象内存泄漏。</p><p>DataBind   双向绑定，将view和model进行绑定，一方变化会导致另一方变化。</p><p>缺点：</p><ol><li>难以排查bug，不知道是view的bug还是model的bug，bug会转移</li><li>不能复用view，因为绑定不同的model</li></ol><h4 id="LiveData-ViewModel替换EventBus"><a href="#LiveData-ViewModel替换EventBus" class="headerlink" title="LiveData+ViewModel替换EventBus"></a>LiveData+ViewModel替换EventBus</h4><h4 id="ViewBinding替换Butterknife"><a href="#ViewBinding替换Butterknife" class="headerlink" title="ViewBinding替换Butterknife"></a>ViewBinding替换Butterknife</h4><h4 id="组件化，插件化，热修复"><a href="#组件化，插件化，热修复" class="headerlink" title="组件化，插件化，热修复"></a>组件化，插件化，热修复</h4><h4 id="Kotlin理解"><a href="#Kotlin理解" class="headerlink" title="Kotlin理解"></a>Kotlin理解</h4><h4 id="ConstraintLayout"><a href="#ConstraintLayout" class="headerlink" title="ConstraintLayout"></a>ConstraintLayout</h4><h1 id="Java基础篇"><a href="#Java基础篇" class="headerlink" title="Java基础篇"></a>Java基础篇</h1><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><h4 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h4><p>不管指令怎么重排序，在单线程下执行结果不能改变</p><h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>一个操作的执行结果需要对另一个操作可见，则两个操作之间必须存在happens-before关系，主要强调在多线程情况中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControlDep</span>&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">      a = <span class="number">1</span>; <span class="comment">//1</span></span><br><span class="line">      flag = <span class="literal">true</span>; <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(flag)&#123; <span class="comment">//3</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a * a; <span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在两个线程A，B，当A执行init发生了重排序，即先执行2，在执行1，当执行2时，B执行了use方法，但是B拿到的a还是0，所以i &#x3D; 0，而正确的答案应该是i &#x3D; 1</p><p>解决上面问题有两种方案：</p><ol><li>内存屏障（volatile），禁止关于a的指令重排</li><li>synchronized锁，锁住该对象或者该类</li></ol><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p><img src="https://img-blog.csdnimg.cn/20210302003053823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1NjAwMA==,size_16,color_FFFFFF,t_70" alt="img"></p><p>本地方法栈，程序计数器，虚拟机栈都是线程私有的，不存在线程安全<br>方法区和堆区，所有线程共享的，需要加锁保证线程安全</p><ul><li>程序计数器：占用内存小，线程私有，生命周期与线程相同，大致为字节码行号指示器</li><li>虚拟机栈：java方法执行的内存模型，包含局部变量表，操作栈，动态链接，方法出口等信息，用于管理java方法的调用，使用连续的内存空间</li><li>本地方法栈：本地方法栈用于管理<strong>本地方法</strong>的调用</li></ul><hr><ul><li>堆区：与jvm生命周期相同，存储所有的对象实例（包括数组）</li><li>方法区：存储已被加载的类信息，常量池，静态变量，即使编译器编译后的代码</li></ul><blockquote><p>静态变量创建在方法区，程序结束后回收，与堆无关</p></blockquote><blockquote><p>stack的大小默认为1M，如果是递归调用，大概只支持800多次</p></blockquote><h4 id="JVM内存模型的三大特性"><a href="#JVM内存模型的三大特性" class="headerlink" title="JVM内存模型的三大特性"></a>JVM内存模型的三大特性</h4><p><strong>原子性</strong>：多线程情况下，一旦一个线程开始执行，就不能被其他线程干扰</p><p>可见行：当一个线程修改了变量后及时更新到主存</p><p>有序性：处理器在执行运算的时候，会对程序代码进行乱序执行优化，也叫做重排序优化</p><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p><img src="https://pic4.zhimg.com/80/v2-40cbacd540b1555badbbf89132aace5f_1440w.jpg" alt="img"></p><h4 id="如何判断对象是个垃圾？"><a href="#如何判断对象是个垃圾？" class="headerlink" title="如何判断对象是个垃圾？"></a>如何判断对象是个垃圾？</h4><ol><li>引用计数法<br>要操作对象必须使用引用，所以通过引用计数来判断对象是否需要被回收。因为无法解决循环引用的问题，所以JAVA中并没有采用这种方式（python中采用）</li><li>可达性分析法<br>为了解决循环引用的问题，使用可达性分析。通过一系列的”GC ROOT”对象作为起点进行搜索，如果在”GC ROOT”和对象之间没有可达路径，那么该对象为不可达对象，并标记一次，标记两次后就会被回收。<br>“GC ROOT”：<ul><li>虚拟机栈中引用的对象（栈帧中的本地变量表）；</li><li>方法区中的常量引用的对象；</li><li>方法区中的类静态属性引用的对象；</li><li>本地方法栈中JNI（Native方法）的引用对象。</li><li>活跃线程对象<blockquote><p>垃圾回收机制是针对堆区的回收</p></blockquote></li></ul></li></ol><h4 id="比较常见的将对象判定为可回收变量"><a href="#比较常见的将对象判定为可回收变量" class="headerlink" title="比较常见的将对象判定为可回收变量"></a>比较常见的将对象判定为可回收变量</h4><ol><li>某个引用对象为null<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li>已经指向某个对象的引用指向新的对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj1 = obj2;</span><br></pre></td></tr></table></figure></li><li>局部引用所指向的对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">.....</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>循环每执行完一次，生成的Object对象都会成为可回收的对象。</li><li>只有弱引用修饰的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; wr = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;world&quot;</span>));</span><br></pre></td></tr></table></figure></li></ol><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ol><li>标记清除算法<br>将可回收对象标记后指定删除对象<br>缺点：产生大量内存碎片</li><li>复制算法<br>为了解决内存碎片的问题，提出复制算法。把内存按容量分成两份，当一份用完了，将还存活的对象复制在另一块对象中，把已使用的内存空间一次性清理掉<br>缺点：空间上的两倍消耗，可使用内存空间减半</li><li>标记整理算法<br>为了充分利用内存空间，在标记回收对象后，将存活对象向一端移动，然后清理掉端边界以外的内存</li><li>分代回收算法<br>将内存分为新生代，老年代和永久代。<br>新生代：<br>使用复制算法，回收大量对象，但不是按照1:1分配内存空间，将内存空间分为3份，较大的Eden和两块较小的Survivor空间，每次使用Eden和一块Survivor，当进行回收时，会将Eden和一块Survivor中存活的对象复制到另一个Survivor中。（比例为8:1:1）<br>老年代：<br>使用标记整理算法（和标记清除算法—-垃圾收集器种说），回收少量对象<br>永久代：<br>存在于方法区，不属于堆区，用来存储class类，常量，方法描述等，对永久代的回收主要包含两种：废弃常量和无用的类</li></ol><p>注意: 在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。</p><blockquote><p>新生代 &#x3D; 1&#x2F;3的堆空间大小，老年代 &#x3D; 2&#x2F;3的对空间大小</p></blockquote><blockquote><p>新创建的对象都是在Eden区，<strong>大对象</strong>因为在新生代复制会影响性能，则直接创建在老年代</p></blockquote><blockquote><p>在Survivor中复制一次，就年龄计数+1，当年龄大大于15岁时，会移动到老年区</p></blockquote><h4 id="jdk7和jdk8上的JVM内存结构的变化？"><a href="#jdk7和jdk8上的JVM内存结构的变化？" class="headerlink" title="jdk7和jdk8上的JVM内存结构的变化？"></a>jdk7和jdk8上的JVM内存结构的变化？</h4><p>jdk7:</p><ol><li><img src="https://pic4.zhimg.com/80/v2-d3426c78d9d7f20874b25377bd37c193_720w.jpg" alt="堆和方法区的物理存储"><br>在物理存储上，堆区和方法区是连续的，但是在逻辑上是分离的，因为物理存储上是存在一起的，所以在Full GC时，会触发堆永久代的回收</li></ol><p>jdk8:</p><ol><li>取消永久代，将类的结构等信息放入Native内存区，常量池和静态变量&#x2F;全局变量存储在堆区</li><li>方法区存在元空间中，Native内存区就是元空间区</li></ol><blockquote><p>Native Memory（本地内存），空间不足，不会触发gc</p></blockquote><h4 id="为什么使用元空间替代永久代？"><a href="#为什么使用元空间替代永久代？" class="headerlink" title="为什么使用元空间替代永久代？"></a>为什么使用元空间替代永久代？</h4><p>避免永久代的OOM发生，因为需要加载的类的总数，方法总数难以确定，分配的空间也难以确定，为了避免OOM，使用元空间，理论上可以获得本地内存中所有可用的空间</p><h4 id="字符常量池存在那？"><a href="#字符常量池存在那？" class="headerlink" title="字符常量池存在那？"></a>字符常量池存在那？</h4><p>1.6：存储在方法区<br>1.7：对象存储在堆区中，引用存在字符串常量池，都在堆中<br>1.8：存储在堆区中</p><h4 id="运行时常量池在哪？"><a href="#运行时常量池在哪？" class="headerlink" title="运行时常量池在哪？"></a>运行时常量池在哪？</h4><p>1.8的时候移动到元空间中，之前都在方法区中</p><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p><img src="https://pic3.zhimg.com/80/v2-f5426caf176fac7d2d7edcf43e127eaa_1440w.jpg" alt="img"><br>java种使用的是HotSpot虚拟机，HotSpot一共7种垃圾收集器，大致分为3类：<br>新生代收集器：Serial，ParNew，Parllel Scavenge<br>老年代收集器：Serial Old，CMS，Parllel Old<br>回收整个堆的G1收集器</p><ul><li>Serial（复制）：新生代单线程收集器，在标记和清理都是单线程，优点是效率高，缺点是停留时间长。</li><li>ParNew（复制）：新生代并行收集器，Serial的多线程版本，在多核cpu环境下比Serial表现更好（只有他能和CMS配合）</li><li>Parllel Scavenge（复制）：新生代并行收集器，追求高吞吐量，高效利用CPU。尽快完成程序的运算任务，适合后台应用等对交互场景要求不高的场景。<br>吞吐量 &#x3D; 用户线程时间&#x2F;（用户线程时间+GC线程时间），缩短工作线程的等待时间</li><li>Serial Old（标记-整理）：老年代的单线程收集器，老年版的单线程</li><li>Parllel Old（标记-整理）：老年代的并行收集器，老年版的Parllel Scavenge</li><li>CMS（Concurrent Mark Sweep）（标记-清除）：老年代并行收集器，以获取最短回收停顿时间为目标，具有高并发，低停顿的特点。追求最短GC回收停顿时间，就是GC的时间更短<br>缺点：<ol><li>对CPU资源异常敏感，应用程序变慢，吞吐率下降</li><li>无法处理浮动垃圾。因为在标记和清除的时候，工作线程是运行的，所以期间会产生新的垃圾，但是本次无法回收。</li><li>产生大量内存碎片，会提前触发Full GC</li></ol></li><li>G1（Garbage First）(标记-整理)：java并行收集器，G1的回收范围包含新生代和老年代。他用来作为下一代的收集器，保存新生代和老年代的概念，但是内部将Java堆划分为多个大小相等Region独立区域<br>优点：<ol><li>并行和并发。使用多个CPU缩短回收停顿时间，与用户线程并发执行</li><li>分带收集。独立去管理整个堆区间，能够采用不同的方式去处理<strong>新创建对</strong>象和<strong>已经存活了一段时间、熬过多次GC的旧对象</strong>，以获取更好的收集效果</li><li>使用标记-整理算法。无内存碎片产生。</li><li>可预测的停顿。可以使开发者制定一个时间长度，在该时间长度内，需要完成垃圾回收。</li></ol></li></ul><blockquote><p>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的组合</p></blockquote><h4 id="gc的种类和方式"><a href="#gc的种类和方式" class="headerlink" title="gc的种类和方式"></a>gc的种类和方式</h4><ol><li>Minor GC：新生代GC<ul><li>当Eden（[‘id(ə)n]）区放满的时候，触发Minor GC</li></ul></li><li>Major GC：老年代GC</li><li>Full GC：全局GC（青年+老年）<ul><li>System.gc()方法有可能触发Full GC</li><li>老年代存储满了</li><li>永久代存储满了，触发Full GC，针对常量池的回收和类型的卸载</li><li>Minor GC后放入老年代大小&gt;老年代可用内存，即老年代放不下</li><li>Minor GC后，放入一个1区中时，放不下，溢出来部分放入老年区，老年区放不下就会触发Full GC<blockquote><p>GC会触发“stop-the-world”，即工作线程全部关闭，进行gc回收，当gc回收结束后，才会执行任务</p></blockquote></li></ul></li></ol><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><a href="https://blog.csdn.net/qq_36520235/article/details/82417949">（1）美团面试题：Hashmap的结构，1.7和1.8有哪些区别，史上最深入的分析</a></p><h4 id="简述-3"><a href="#简述-3" class="headerlink" title="简述"></a>简述</h4><p>影响性能的两个参数：</p><ul><li><p>初始容量：2的幂，默认是16</p></li><li><p>加载因子：什么时候扩容的标志，默认0.75，即16*0.75&#x3D;12的时候开始hashmap扩容（容量为原来的2倍）</p></li><li><p>最大容量：2的30次方，如果大于，则使用2的30次方的大小</p></li><li><p>可以存储key &#x3D;&#x3D; null，value &#x3D;&#x3D; null，key &#x3D;&#x3D; null则存储在table[0]位置</p></li><li><p>删除元素的本质是“删除单向链表的节点”</p></li><li><p>Entry是单向链表</p></li></ul><p>计算key的hash值，并将hash值添加到对应的链表中，若key存在，则更新vlaue值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;  <span class="comment">//计算出来的hash值</span></span><br><span class="line">    <span class="keyword">final</span> K key;     <span class="comment">//key</span></span><br><span class="line">    V value;         <span class="comment">//value</span></span><br><span class="line">    Node&lt;K,V&gt; next;  <span class="comment">//链表next引用</span></span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>和修改</p><ul><li>因为是非synchronized的，非线程安全，所以比较快</li><li>HashMap可以接受null键和null值</li></ul><h4 id="数组下标index的计算过程"><a href="#数组下标index的计算过程" class="headerlink" title="数组下标index的计算过程"></a>数组下标index的计算过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组长度-1 &amp; hash值</span></span><br><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>同等于hash值对数组长度的求余</p><h4 id="描述一下具体的put过程"><a href="#描述一下具体的put过程" class="headerlink" title="描述一下具体的put过程"></a>描述一下具体的put过程</h4><ol><li>对key求hash值，然后计算数组下标</li><li>如果数组下标没有碰撞，将Node放置在数组中</li><li>如果碰撞，将Node以链表的形式连接在后面</li><li>如果链表长度超过阈值（8），将链表转化为红黑树，链表长度低于6，则将红黑树转回链表</li><li>如果节点存在，则替换旧值</li><li>如果数组快满了（最大容量16*加载因子0.75），就需要resize（扩容两倍）</li></ol><h4 id="为什么选择6和8-？"><a href="#为什么选择6和8-？" class="headerlink" title="为什么选择6和8 ？"></a>为什么选择6和8 ？</h4><p>因为中间7的位置放置频繁的数据结构切换后，影响性能</p><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><ol><li>计算key的hash，在计算index值</li><li>在数组中查找index值，在比对key值，取出value，复杂度最好是O(1)，最坏为O(n)</li></ol><h4 id="为什么不直接使用红黑树？"><a href="#为什么不直接使用红黑树？" class="headerlink" title="为什么不直接使用红黑树？"></a>为什么不直接使用红黑树？</h4><p>空间和时间的选择，链短的时候空间上占用小，时间还好，转化为红黑树后，便于查找，但是耗费空间。</p><h4 id="处理hash冲突的方法有以下几种："><a href="#处理hash冲突的方法有以下几种：" class="headerlink" title="处理hash冲突的方法有以下几种："></a>处理hash冲突的方法有以下几种：</h4><ol><li>开放地址法（线性探测再散列（碰撞后，位置后挪，数组长度+x）x可为正数，二次探测再散列（数组长度+x的平方）x可为正负数，平方后均为正数）</li><li>再哈希法（多种计算哈希的方法，相同则替换方法，直到算出不重复的哈希值）</li><li>链地址法（链表）</li><li>建立公共溢出区（建立一个溢出表，存放冲突的数据）</li></ol><h4 id="HashMap的性能慢原因？"><a href="#HashMap的性能慢原因？" class="headerlink" title="HashMap的性能慢原因？"></a>HashMap的性能慢原因？</h4><ul><li>数据类型自动装箱问题</li><li>resize扩容重新计算index值和hashcode，重新赋值（1.7）<br>1.8后，扩容位置 &#x3D; hash值 &amp; 数组长度，如果为0，则不动，反之则反</li></ul><h4 id="线程不安全会导致什么"><a href="#线程不安全会导致什么" class="headerlink" title="线程不安全会导致什么"></a>线程不安全会导致什么</h4><p>环状链表，resize（扩容）时头插法导致环形链表（1.7版本）</p><p>都存在数据丢失的问题数据丢失，1.8版本修复环形链表（尾插）</p><h4 id="HashMap中默认容量为什么是2的幂？"><a href="#HashMap中默认容量为什么是2的幂？" class="headerlink" title="HashMap中默认容量为什么是2的幂？"></a>HashMap中默认容量为什么是2的幂？</h4><p>因为如果不是2的幂，可能会造成更多的hash碰撞（index 下标碰撞）<br>假设n为17，n-1的二进制为10000，01001和01101算出的index值均为0<br>假设n为16，n-1的二进制为01111，01001和01101算出的index值不同</p><h4 id="hashcode计算原理"><a href="#hashcode计算原理" class="headerlink" title="hashcode计算原理"></a>hashcode计算原理</h4><p>对于int类型，hashcode为它本身，eg：int i &#x3D; 1;   hashcode &#x3D; 1;<br>对于对象来说，hashcode是内部地址和对象值的一个映射</p><h4 id="hash-算法原理"><a href="#hash-算法原理" class="headerlink" title="hash()算法原理"></a>hash()算法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到key的hashCode()，在将该值与该值的高16位（h无符号右移16位）进行亦或运算（相同为0，不同为1）</p><h4 id="HashTable的理解"><a href="#HashTable的理解" class="headerlink" title="HashTable的理解"></a>HashTable的理解</h4><p>put和get方法是用了synchronized修饰，锁住了整个map，同一时刻只有一个线程可以操作</p><p>不可以存储null值和null健</p><h4 id="SparseArray理解"><a href="#SparseArray理解" class="headerlink" title="SparseArray理解"></a>SparseArray理解</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>装箱，int数据类型—-&gt;Integer对象，拆箱，Integer对象—-&gt;int数据类型</p><p>默认容量是10</p><ul><li>key是int值（避免装箱问题），使用二分查找寻找key，同样也是用二分插入，从小到大排列好的</li><li>两个数组，一组存放key（int []），一组存放value(object [])</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mKeys[i] = key;</span><br><span class="line">mValues[i] = value;</span><br></pre></td></tr></table></figure><ul><li>如果冲突，直接替换value的值</li></ul><p>二分插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">           <span class="comment">//二分法一分而二，数组中间下标</span></span><br><span class="line">           <span class="keyword">final</span> <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="comment">//二分法一分而二，数组中间下标处的值</span></span><br><span class="line">           <span class="keyword">final</span> <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> array[mid];</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (midVal &lt; value) &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               如果数组中间处的值比要找的值小，代表要找的值</span></span><br><span class="line"><span class="comment">               在数组的中后部部分，所以当前下标取值为mid + 1</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               lo = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; value) &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               如果数组中间处的值比要找的值大，代表要找的值</span></span><br><span class="line"><span class="comment">               在数组的前中部部分，所以当前下标取值为mid - 1</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               hi = mid - <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//数组中间处的值与要找的值相等，直接返回数组中部的下标mid</span></span><br><span class="line">               <span class="keyword">return</span> mid;  <span class="comment">// value found</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>第一个值放到最中间位置</p><p>第二个值如果大于中间的值放置在左边的中间位置</p><p>………….</p><p>put方法中，容量充足，计算key值所需存放的index，如果key相同，就直接替换value，如果不同，就insert数组，后续index元素后移，新key放置在index上</p><h5 id="较HashMap的优点"><a href="#较HashMap的优点" class="headerlink" title="较HashMap的优点"></a>较HashMap的优点</h5><ul><li>节省内存</li><li>性能更好，避免装箱问题</li><li>数据量不达到千级，key为int值，可以用SparseArray替换HashMap</li></ul><h4 id="SparseArray与HashMap的比较，应用场景是？"><a href="#SparseArray与HashMap的比较，应用场景是？" class="headerlink" title="SparseArray与HashMap的比较，应用场景是？"></a>SparseArray与HashMap的比较，应用场景是？</h4><ol><li>SparseArray采用的不是哈希算法，HashMap采用的是哈希算法</li><li>SparseArray采用的是两个一维数组分别用于存储键和值，HashMap采用的是一维数组+单向链表&#x2F;红黑树</li><li>SparseArray key只能是int类型，而HashMap可以任何类型</li><li>SparseArray  key是有序存储（升序），而HashMap不是</li><li>SparseArray 默认容量是10，而HashMap默认容量是16</li><li>SparseArray 内存使用要优于HashMap，因为：<ul><li>SparseArray key是int类型，而HashMap是Object</li><li>SparseArray value的存储被不像HashMap一样需要额外的需要一个实体类（Node）进行包装</li></ul></li><li>SparseArray查找元素总体而言比HashMap要逊色，因为SparseArray查找是需要经过二分法的过程，而HashMap不存在冲突的情况其技术处的hash对应的下标直接就可以取到值</li></ol><p>针对上面与HashMap的比较，采用SparseArray还是HashMap，建议根据如下需求选取：</p><ol><li>如果对内存要求比较高，而对查询效率没什么大的要求，可以是使用SparseArray</li><li>数量在百级别的SparseArray比HashMap有更好的优势</li><li>要求key是int类型的，因为HashMap会对int自定装箱变成Integer类型</li><li>要求key是有序的且是升序</li></ol><h4 id="ArrayMap的理解"><a href="#ArrayMap的理解" class="headerlink" title="ArrayMap的理解"></a>ArrayMap的理解</h4><p>内部也使用二分算法进行存储和查找，设计上更多考虑了内存中的优化</p><ul><li>int []存储hash值，array[index]存储key，array[index+1]存储value</li></ul><blockquote><p>数据量最好在千级以内</p></blockquote><h4 id="ArrayMap和SparseArray怎么进行选取？"><a href="#ArrayMap和SparseArray怎么进行选取？" class="headerlink" title="ArrayMap和SparseArray怎么进行选取？"></a>ArrayMap和SparseArray怎么进行选取？</h4><ol><li>如果key为int，那么选取SparseArray进行存储， 不存在封&#x2F;拆箱问题</li><li>如果key不为int，则使用ArrayMap</li></ol><h4 id="TreeMap的理解"><a href="#TreeMap的理解" class="headerlink" title="TreeMap的理解"></a>TreeMap的理解</h4><p>TreeMap是一个二叉树的结构，红黑树</p><p>不允许重复的key</p><p>TreeMap没有调优选项，因为其红黑树总保持在平衡状态</p><h4 id="TreeMap和HashMap的区别？"><a href="#TreeMap和HashMap的区别？" class="headerlink" title="TreeMap和HashMap的区别？"></a>TreeMap和HashMap的区别？</h4><ol><li>TreeMap由红黑树构成，HashMap由数组+链表&#x2F;红黑树构成</li><li>HashMap元素没有顺序，TreeMap元素会根据可以进行升序排序</li><li>HashMap进行插入，查找，删除最好，TreeMap进行自然顺序便利或者自定义顺序便利比较好</li></ol><h4 id="ThreadLocal的理解"><a href="#ThreadLocal的理解" class="headerlink" title="ThreadLocal的理解"></a>ThreadLocal的理解</h4><p><a href="https://www.cnblogs.com/wang-meng/p/12856648.html#:~:text=ThreadLocalMap%20%E6%9C%89%E7%82%B9%E7%B1%BB%E4%BC%BC%20HashMap%20%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8F%AA%E6%98%AF%20HashMap%20%E6%98%AF%E7%94%B1%20%E6%95%B0%E7%BB%84%2B%E9%93%BE%E8%A1%A8%20%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E8%80%8C,key%20%E6%98%AF%20ThreadLocal%3C%3F%3E%20k%20%EF%BC%8C%E7%BB%A7%E6%89%BF%E8%87%AA%20WeakReference%20%EF%BC%8C%20%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%88%91%E4%BB%AC%E5%B8%B8%E8%AF%B4%E7%9A%84%E5%BC%B1%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E3%80%82">面试官：小伙子，听说你看过ThreadLocal源码？（万字图文深度解析ThreadLocal）</a></p><p>线程隔离，数据不交叉</p><ul><li>ThreadLocalMap，每个thread都存在一个变量ThreadLocalMap threadLocals</li><li>threadLocalMap中存在Entry，同ThreadLocal之间为弱引用关系</li><li>ThreadLocalMap中key为ThreadLocal的弱引用，value为Entry，内部为一个object对象</li><li>table默认大小为16，存在初始容量（16）和阈值（16*2&#x2F;3）</li><li>在ThreadLocal中使用get()和set()方法初始化threadLocals</li><li>get、set、remove方法将key&#x3D;&#x3D;null的数据清除</li><li>table是环形数组</li></ul><p>线性探测法避免哈希冲突，增量查找没有被占用的地方</p><p>通过hashcode计算索引位置，如果key值相同，则替换，不同就nextIndex，继续判断，直到插入数据</p><p>ThreadLocal就是管理每个线程中的ThreadLocalMap，所以线程隔离了。</p><h4 id="ThreadLocalMap的理解"><a href="#ThreadLocalMap的理解" class="headerlink" title="ThreadLocalMap的理解"></a>ThreadLocalMap的理解</h4><p>新建ThreadLcoal的时候，创建一个ThreadLocalMap对象，计算hash的时候使用0x61c88647这个值，他是黄金分割数，导致计算出来的hash值比较均匀，这样回大大减少hash冲突，内部在采用线性探测法解决冲突<br>set：</p><ol><li>根据key计算出数组索引值</li><li>遍历该索引值的链表，如果为空，直接将value赋值，如果key相等，直接更新value，如果key不相等，使用线性探测法再次检测。</li></ol><h4 id="ThreadLocal使用弱引用的原因"><a href="#ThreadLocal使用弱引用的原因" class="headerlink" title="ThreadLocal使用弱引用的原因"></a>ThreadLocal使用弱引用的原因</h4><p>key使用了弱引用，如果key使用强引用，那么当ThreadLocal的对象被回收了，但ThreadLocalMap还持有ThreadLocal的强引用，回导致ThreadLocal不会被回收，导致内存泄漏</p><h4 id="ThreadLocal的内存泄漏"><a href="#ThreadLocal的内存泄漏" class="headerlink" title="ThreadLocal的内存泄漏"></a>ThreadLocal的内存泄漏</h4><ul><li>避免使用static修饰ThreadLocal：延长生命周期，可能造成内存泄漏</li><li>ThreadLocal弱引用被gc回收后，则key为null，object对象没有被回收，只有当再次调用set，get，remove方法的时候才会清楚key为null的对象</li></ul><h4 id="ThreadLocalMap清理过期key的方式"><a href="#ThreadLocalMap清理过期key的方式" class="headerlink" title="ThreadLocalMap清理过期key的方式"></a>ThreadLocalMap清理过期key的方式</h4><ol><li>探测式清理<br>本该放在4的位置上的值，放到了7的位置上，当5过时后，将7的数据挪到5的位置上</li><li>启发式清理<br>遍历数组，清理数据</li></ol><h4 id="ConcurrentHashMap和HashMap的区别"><a href="#ConcurrentHashMap和HashMap的区别" class="headerlink" title="ConcurrentHashMap和HashMap的区别"></a>ConcurrentHashMap和HashMap的区别</h4><p>jdk  1.7 ReentrantLock+segments + hashEntry(不可变)</p><img src="https://upload-images.jianshu.io/upload_images/2843224-25151c12024f0bfb.png" width="50%"/><ul><li>线程安全，分段线程锁，hashtable是整段锁，所以性能有所提高</li><li>默认分配16个锁，比Hashtable效率高16倍</li><li>hashEnty是final的，不能被修改，只要被修改，该节点之前的链就要重新创建，采用头插插入，所以顺序反转</li><li>获取size，因为是多线程访问，所以size会获取三遍，如果前后两个相等就返回，假设不相等，就将Segment加锁后计算。</li></ul><p>jdk 1.8 ： synchronized +node+volatile+红黑树</p><p>put：</p><ol><li>根据key的hash值算出Node数组的相应位置</li><li>如果该Node不为空，且当前该节点不处于移动状态，则对节点加synchronized锁，进行遍历节点插入操作</li><li>如果是红黑树节点，向红黑树插入操作</li><li>如果大于8个，拓展为红黑树</li></ol><p>get：</p><ol><li>计算hash值，定位到该table索引位置，如果是首节点符合就返回</li><li>如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，通知在新表中查找该节点，匹配就返回</li><li>以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null</li></ol><p>1.7和1.8的区别：</p><ol><li><p>1.7：ReentrantLock+segments + hashEntry(不可变)</p><pre><code>  1.8：synchronized +node+volatile+红黑树</code></pre></li><li><p>1.8的锁的粒度更低，锁的是一个链表（table[i]），而1.7锁的是一个小的hashmap（segement）</p></li><li><p>ReentrantLock性能比synchronized差</p></li></ol><p>扩容：</p><p>1.7下进行小HashMap（segement）扩容操作</p><p>1.8下使用synchrozied节点加锁，所以可以通过多个线程扩容处理。一个线程创建新的ConcurrentHashMap，并设置大小，多个线程将旧的内容添加到新的map中，如果添加过的内容就会设置标记，其他线程就不会处理</p><h4 id="为什么只有hashmap可以存储null值和null键"><a href="#为什么只有hashmap可以存储null值和null键" class="headerlink" title="为什么只有hashmap可以存储null值和null键"></a>为什么只有hashmap可以存储null值和null键</h4><p>因为hashmap是线程不安全的，而在其他中都是线程安全的，在多线程访问时，无法判断key为null是没有找到，还是key为null</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="常见锁"><a href="#常见锁" class="headerlink" title="常见锁"></a>常见锁</h3><h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><ol><li><p>公平锁&#x2F;非公平锁</p><ul><li>公平锁：多个线程按照申请锁的顺序获取锁。</li><li>非公平锁：多个线程申请锁并不是按照顺序获取锁，有可能先申请后获取锁。（Synchronized）</li></ul><blockquote><p>ReentrantLock默认是非公平锁，通过构造传参可设置为公平锁。非公平锁的优点在于吞吐量比公平锁大</p></blockquote></li><li><p>可重入锁：又名递归锁，指在外层方法获取锁以后，在进入内层方法也会自动获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">()</span> <span class="keyword">throws</span> <span class="title function_">Exception</span><span class="params">()</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    setB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">()</span> <span class="keyword">throws</span> <span class="title function_">Exception</span><span class="params">()</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不是可重入锁，那么setB方法不会被当前线程执行，容易造成死锁</p><blockquote><p>synchronized是可重入锁</p></blockquote></li><li><p>独享锁&#x2F;共享锁</p><ul><li>独享锁：一个锁一次只能被一个线程所持有（ReentrantLock，synchronized）</li><li>共享锁：一个锁被多个线程所持有。（ReadWriteLock）</li></ul></li><li><p>互斥锁&#x2F;读写锁<br>上面讲的独享锁&#x2F;共享锁就是一种广义的说法，互斥锁&#x2F;读写锁就是具体的实现。<br>互斥锁在Java中的具体实现就是ReentrantLock<br>读写锁在Java中的具体实现就是ReadWriteLock</p></li><li><p>乐观锁&#x2F;悲观锁</p><ul><li>悲观锁：对同一数据的并发操作，一定会发生修改的。（利用各种锁实现）</li><li>乐观锁：对同一数据的并发操作，一定不会发生修改的。（无锁编程，CAS算法，自旋实现原子操作的更新）</li></ul></li><li><p>分段锁<br>是一种锁的设计，并不是具体的锁，在1.7版本的ConcurrentHashMap中，使用分段锁设计，该分段锁又称为Segment，map中每一个链表由ReentrantLock修饰</p></li><li><p>偏向锁&#x2F;轻量级锁&#x2F;重量级锁<br>这三种锁是描述synchronized的三种状态。</p><ul><li>偏向锁：一段同步代码一直被一个线程访问，那么会自动获取锁，降低获取锁的代价</li><li>轻量级锁：当锁是偏向锁的时候，被另一个线程访问，偏向锁会升级为轻量级锁，其他线程通过自旋的方式获取锁，不会阻塞，提高性能</li><li>重量级锁：在轻量级锁的基础上，自旋达到上限就会阻塞，升级为重量级锁，会让其他线程进入阻塞，影响性能。</li></ul><blockquote><p>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后无法降为偏向锁，这种升级无法降级的策略目的就是为了提高获得锁和释放锁的效率。</p></blockquote></li><li><p>自旋锁<br>获取锁的过程中，不会立即阻塞，会采用循环的方式获取锁，<strong>减少线程切换上下文的消耗</strong>，缺点是循环会<strong>消耗cpu</strong></p></li></ol><h4 id="java中常用锁的类型"><a href="#java中常用锁的类型" class="headerlink" title="java中常用锁的类型"></a>java中常用锁的类型</h4><ol><li>synchronized：非公平，悲观，独享，互斥，可重入，重量级锁</li><li>ReentrantLock：默认非公平（可公平），悲观，独享，互斥，可重入，重量级锁</li></ol><blockquote><p>CAS，全称为Compare-And-Swap，是一条CPU的原子指令，其作用是让CPU比较后原子地更新某个位置的值，实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM 只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。</p></blockquote><h3 id="synchronized和volatile"><a href="#synchronized和volatile" class="headerlink" title="synchronized和volatile"></a>synchronized和volatile</h3><h4 id="简述synchronized的原理"><a href="#简述synchronized的原理" class="headerlink" title="简述synchronized的原理"></a>简述synchronized的原理</h4><p>可见性：表示A修改的值对于B执行时可以看见A修改后的值</p><ul><li>内部使用<strong>monitorenter</strong>指令，同时只有一个线程可以获取monitor</li><li>未获取monitor的线程会被阻塞，等待获取monitor</li><li>线程A获取主内存值后加锁，在本地内存更新值（临时区）后，推送到主内存，通过synchronized隐式通知线程B访问主存获取值，在B的把本地内存更新值后推送到主存，重复以上操作。</li></ul><p>通过Monitor对象来实现方法和代码块的同步，存在monitorEnter和monitorExit指令，插入程序中，在一个线程访问时，通过Monitor进行线程阻塞</p><h4 id="synchronized修饰静态方法、⾮静态方法区别"><a href="#synchronized修饰静态方法、⾮静态方法区别" class="headerlink" title="synchronized修饰静态方法、⾮静态方法区别"></a>synchronized修饰静态方法、⾮静态方法区别</h4><p>静态方法：该类的对象，new出来的多个实例对象是被一个锁锁住的，多线程访问需要等待</p><p>非静态方法：实例对象</p><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>修饰成员变量，保证可见性，下一个操作再上一个操作之上。++操作不保证和原子性，</p><p>将本地缓存同步到主存中，使其他本地缓存失效，本地缓存通过嗅探检查自己的缓存是否过期。（下一次访问，主存不会主动通知）</p><p>volatile无法保证原子性，可以使用乐观锁的重试机制进行优化</p><h4 id="synchronized和volatile区别"><a href="#synchronized和volatile区别" class="headerlink" title="synchronized和volatile区别"></a>synchronized和volatile区别</h4><ul><li><p>Synchronized 引起线程阻塞，而volatile不会</p></li><li><p>区别在于，synchronized是隐式通知B去主存获取值，volatile是B主动通过嗅探的方法发现自己的内存过期后去主存做同步</p></li><li><p>synchronized：先清空工作内存→在主内存中拷贝最新变量的副本到工作内存→执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。</p></li><li><p>都存在可见性，但是volatile不具备原子性，所以不会造成线程阻塞</p><p>假设某一时刻i&#x3D;10，线程A读取10到自己的工作内存，A对该值进行加一操作，但正准备将11赋给i时，由于此时i的值并未改变，B读取了主存的值仍为10到自己的工作内存，并执行了加一操作，正准备将11赋给i时，A将11赋给了i，由于volatile的影响，立即同步到主存，主存中的值为11，并使得B工作内存中的i失效，B执行第三步，虽然此时B工作内存中的i失效了，但是第三步是将11赋给i，对B来说，我只是赋值操作，并没有使用i这个动作，所以这一步并不会去刷新主存，B将11赋值给i，并立即同步到主存，主存中的值仍为11。虽然A&#x2F;B都执行了加一操作，但主存却为11，这就是最终结果不是10000的原因。</p></li><li><p>synchronized修饰方法，类，变量，代码块，volatile只能修饰变量</p></li></ul><h4 id="synchronized修饰不同对象的区别"><a href="#synchronized修饰不同对象的区别" class="headerlink" title="synchronized修饰不同对象的区别"></a>synchronized修饰不同对象的区别</h4><ol><li>修饰类：作用的对象是这个类的所有对象</li><li>方法：作用对象是这个方法的对象</li><li>静态方法：作用对象是这个类的对象</li><li>代码块：作用对象是这个代码块的对象</li></ol><h4 id="悲观锁和乐观锁（CAS）"><a href="#悲观锁和乐观锁（CAS）" class="headerlink" title="悲观锁和乐观锁（CAS）"></a>悲观锁和乐观锁（CAS）</h4><p>悲观锁：当前线程获得锁会阻塞其他线程（sychronized）</p><p>乐观锁：不会添加锁，会存在三个值内存实际值，内存的旧值，更新的新值，如果内存实际值和旧值相等，则没有线程修改该值，将更新的新值直接赋值给内存，如果不相等，就重新尝试赋值操作（volatile）</p><p>CAS的缺点：</p><ol><li>ABA问题，A-&gt;B-&gt;A，乐观锁认为没有变化，都是A，所以直接赋值</li><li>重新赋值的话，会导致时间过长。</li></ol><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>CAS+AQS实现，乐观锁</p><p>AQS（单链表队列）维护一个等待队列，将获取不到锁的线程放入到队列中进行等待，当当前线程执行结束后，进行出队操作，使用一个volatile的int成员变量（state）来表示同步状态</p><p>通过ReentrantLock的Lock方法进行加锁</p><p>通过ReentrantLock的unLock方法进行解锁</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h4 id="新建线程有几种方式？"><a href="#新建线程有几种方式？" class="headerlink" title="新建线程有几种方式？"></a>新建线程有几种方式？</h4><ol><li>new Thread</li><li>新建Runnable对象</li><li>新建Callable或者Future对象</li><li>线程池使用</li></ol><h4 id="new-Thread的弊端"><a href="#new-Thread的弊端" class="headerlink" title="new Thread的弊端"></a>new Thread的弊端</h4><p>执行一个异步任务你还只是如下new Thread吗？<br>new Thread的弊端如下：</p><ol><li>每次new Thread新建对象性能差。</li><li>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。</li><li>缺乏更多功能，如定时执行、定期执行、线程中断。</li></ol><p>相比new Thread，Java提供的四种线程池的好处在于：</p><ol><li>重用存在的线程，减少对象创建、消亡的开销，性能佳。</li><li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</li><li>提供定时执行、定期执行、单线程、并发数控制等功能。</li></ol><h4 id="线程池-2"><a href="#线程池-2" class="headerlink" title="线程池"></a>线程池</h4><p><a href="#%E7%AE%80%E8%BF%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0">简述线程池</a></p><h4 id="线程的5种状态"><a href="#线程的5种状态" class="headerlink" title="线程的5种状态"></a>线程的5种状态</h4><ul><li>NEW：创建一个新线程</li><li>RUNNABLE：可运行</li><li>BLOCKED：阻塞</li><li>WAITING：进入等待状态</li><li>TIMED_WAITING：等待结束，重新获取锁</li><li>TERMINATED：结束</li><li>RUNNING：运行中</li><li>READY：就绪</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/4840092-f85e70e2262b7878.png" alt="img"></p><p>一般来说分为五大状态：</p><p><img src="http://www.runoob.com/wp-content/uploads/2014/09/716271-20170320112245721-1831918220.jpg" alt="img"></p><ol><li>新建（New）：<br>创建线程对象，进入新建状态。eg：Thread thread &#x3D; new Thread();</li><li>就绪（Runnable）：<br>调用thread.start()方法，随时可被cpu执行</li><li>运行（Runnable）：<br>CPU执行线程</li><li>阻塞（Blocked）：<br>出于某些原因，cpu放弃线程执行，线程进入暂停状态<ul><li>等待阻塞：调用wait方法，进行阻塞，线程等待某工作完成</li><li>同步阻塞：在获取Synchronized同步锁时，进行等待</li><li>其他阻塞：通过调用线程的sleep()或join()或发出了I&#x2F;O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态。</li></ul></li><li>死亡（Dead）：<br>堪称执行完毕或者因异常退出，线程死亡，回收</li></ol><h4 id="start和run的区别？sleep和wait的区别？join-yield，interrupt"><a href="#start和run的区别？sleep和wait的区别？join-yield，interrupt" class="headerlink" title="start和run的区别？sleep和wait的区别？join,yield，interrupt"></a>start和run的区别？sleep和wait的区别？join,yield，interrupt</h4><ul><li>start是启动一个线程</li><li>run只是Thread的实现方法，主要实现是Runnable的接口回调run方法</li><li>sleep不会释放对象锁，只是暂停了线程的运行，当指定时间到了，就恢复运行状态</li><li>wait方法放弃对象锁，只有调用了notify()方法，才会重新获取锁，进入运行状态</li><li>join方法是规定线程的执行顺序，如果在B线程中调用了A的join方法，那么，直到A执行完毕，才会执行B，按照顺序串行执行。实际内部方法是调用了wait方法，让B处于等待状态，A执行完成后，启动B</li></ul><blockquote><p>注意：wait方法是调用u哦在线程放弃对象锁，所以在B线程调用A的join方法，只是让B等待了。</p></blockquote><ul><li>yield方法，通知cpu该线程任务不紧急，可以被暂停让其他线程运行</li><li>interrupt方法，中断通知线程，具体操作由线程执行，根据不同状态，执行不同逻辑</li></ul><h4 id="线程t1、t2、t3，如何保证他们顺序执行？"><a href="#线程t1、t2、t3，如何保证他们顺序执行？" class="headerlink" title="线程t1、t2、t3，如何保证他们顺序执行？"></a>线程t1、t2、t3，如何保证他们顺序执行？</h4><p>t3开始中调用t2.join()，t2开始中调用t1.join()。</p><p>t1执行完毕后，t2中t1.join()方法不阻塞，即t1执行完，执行t2中的方法，后续类似<br>使用CountDownLacth，进行计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//引用t1线程，等待t1线程执行完</span></span><br><span class="line">                   t1.join();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//引用t2线程，等待t2线程执行完</span></span><br><span class="line">                   t2.join();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       t3.start();</span><br><span class="line">       t2.start();</span><br><span class="line">       t1.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>资源竞争互相等待</p><p>假设线程A，线程B，资源A，资源B</p><p>线程A访问资源A，持有资源A锁，线程B访问资源B，持有资源B锁，而后线程A要访问资源B，但是线程B持有资源B锁，线程A等待，线程B要访问资源A，但是线程A持有资源A锁。所以B等待。</p><p>结果就是A、B相互等待对方释放资源，造成死锁。</p><h4 id="一个线程崩溃会影响其他线程吗？"><a href="#一个线程崩溃会影响其他线程吗？" class="headerlink" title="一个线程崩溃会影响其他线程吗？"></a>一个线程崩溃会影响其他线程吗？</h4><p>不一定。<br>如果崩溃发生在堆区（线程共享区域），会导致其他线程崩溃。<br>如果崩溃发生在栈区（线程私有区域），不会导致其他线程的崩溃</p><h2 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h2><ol><li>反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；</li><li>每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；</li><li>反射也是考虑了线程安全的，放心使用；</li><li>反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；</li><li>反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；</li><li>当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；</li><li>调度反射方法，最终是由jvm执行invoke0()执行；</li></ol><p>使用反射从jvm中的二进制码文件中读取数据</p><h4 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h4><p>.java–&gt;.class–&gt;java.lang.Class对象</p><p>编译过程：</p><ul><li>将.java文件编译成机器可以识别<strong>的二进制文件</strong>.class</li><li>.class文件中存储着类文件的各种信息。<br>比如版本号、类的名字、字段的描述和描述符、方法名称和描述、是不是public、类索引、字段表集合，方法集合等等数据</li><li>JVM从二进制文件.class中取出并拿到内存解析</li><li>类加载器获取类的二进制信息，并在内存中生成java.lang.Class对象</li><li>最后开始类的生命周期并初始化（先静态后非静态和构造，先父类在子类）</li></ul><p>而反射操作的就是内存中的java.lang.Class对象。</p><blockquote><p>总结来说.class是一种有顺序的结构文件,而Class对象就是对这种文件的一种表示，所以我们能从Class对象中获取关于类的所有信息，这就是反射的原理。</p></blockquote><h4 id="为什么反射耗时？"><a href="#为什么反射耗时？" class="headerlink" title="为什么反射耗时？"></a>为什么反射耗时？</h4><ol><li>校验时间长</li><li>基本类型的封箱和拆箱</li><li>方法内联</li></ol><h4 id="什么是内联函数？"><a href="#什么是内联函数？" class="headerlink" title="什么是内联函数？"></a>什么是内联函数？</h4><p>方法调用过多会进行内敛优化，减少方法的嵌套层级，加快执行，缓解栈的空间存储</p><h4 id="反射可以修改final类型的成员变量吗？"><a href="#反射可以修改final类型的成员变量吗？" class="headerlink" title="反射可以修改final类型的成员变量吗？"></a>反射可以修改final类型的成员变量吗？</h4><p>已知final修饰后不会被修改，所以获取这个变量的时候就直接帮你在编译阶段就给赋值了</p><blockquote><p>编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。</p></blockquote><p>所以上述的getName方法经过JVM编译内联优化后会变成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印出来也是Bob</span></span><br><span class="line">System.out.println(user.name)</span><br><span class="line"><span class="comment">//经过内联优化</span></span><br><span class="line">System.out.println(<span class="string">&quot;Bob&quot;</span>)</span><br></pre></td></tr></table></figure><p>反射是可以修改final变量的，但是如果是<strong>基本数据类型</strong>或者<strong>String类型</strong>的时候，无法通过对象获取修改后的值，因为JVM对其进行了内联优化。</p><h4 id="反射可以修改static值吗？"><a href="#反射可以修改static值吗？" class="headerlink" title="反射可以修改static值吗？"></a>反射可以修改static值吗？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field.get(<span class="literal">null</span>) 可以获取静态变量。</span><br><span class="line">Field.set(<span class="literal">null</span>,object) 可以修改静态变量。</span><br></pre></td></tr></table></figure><h2 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h2><h4 id="简析-1"><a href="#简析-1" class="headerlink" title="简析"></a>简析</h4><p>java中的异常分为2大类，Error和Exception。Error中有StackOverFlowError和OutOfMemoryError。Exception分为IOException和RuntimeException。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTEvMjcvMTM1NDAyMDQxN181MTc2LmpwZw?x-oss-process=image/format,png" alt="异常"></p><h4 id="Java中检查型异常和非检查型异常有什么区别？"><a href="#Java中检查型异常和非检查型异常有什么区别？" class="headerlink" title="Java中检查型异常和非检查型异常有什么区别？"></a>Java中检查型异常和非检查型异常有什么区别？</h4><p>检查型异常 extends Exception（编译时异常）：需要使用try catch进行捕获，否则会出错，继承自Exception</p><p>非检查型异常 extends RuntimeException（运行时异常）：不需要捕获，在必要时才会报错，</p><h4 id="try-catch-finally-return执行顺序？"><a href="#try-catch-finally-return执行顺序？" class="headerlink" title="try-catch-finally-return执行顺序？"></a>try-catch-finally-return执行顺序？</h4><ol><li>不管是否有异常产生，finally块中代码都会执行</li><li>当try和catch中有return语句时，finally块仍然会执行</li><li>finally是在return后面的表达式运算执行的，所以函数返回值在finally执行前确定的，无论finally中的代码怎么样，返回的值都不会改变，仍然是之前return语句中保存的值</li><li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值</li></ol><h4 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h4><p>throw用在方法内部，抛出异常</p><p>throws用在方法外部，在方法中抛出异常</p><h4 id="栈溢出StackOverFlowError发生的几种情况？"><a href="#栈溢出StackOverFlowError发生的几种情况？" class="headerlink" title="栈溢出StackOverFlowError发生的几种情况？"></a>栈溢出StackOverFlowError发生的几种情况？</h4><p>递归，栈内存存满，函数调用栈太深</p><h4 id="Java常见异常有哪些"><a href="#Java常见异常有哪些" class="headerlink" title="Java常见异常有哪些"></a>Java常见异常有哪些</h4><p>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</p><p>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</p><p>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</p><p>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</p><p>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</p><p>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</p><p>java.lang.ArithmeticException：算术条</p><p>件异常。譬如：整数除零等。</p><p>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</p><p>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</p><p>java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</p><p>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</p><p>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</p><p>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</p><p>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</p><p>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</p><h2 id="linux进程通信有几种"><a href="#linux进程通信有几种" class="headerlink" title="linux进程通信有几种"></a>linux进程通信有几种</h2><p>Linux中的进程间通信有哪些？解释Binder通信为什么高效？Binder通信有什么限制？</p><p>Linux中的进程间通信有如下几种：</p><ul><li>信号（signal）</li><li>消息队列</li><li>共享内存（Shared Memory）<br>共享内存允许两个或多个进程进程共享同一块内存(这块内存会映射到各个进程自己独立的地址空间)从而使得这些进程可以相互通信。</li><li>管道&#x2F;命名管道(Pipe)<br>Pipe这个词很形象地描述了通信双方的行为，即进程A与进程B。一根管道同时具有读取端和写入端。比如进程A从write end写入，那么进程B就可以从read end读取数据。</li><li>Socket<br>本地和服务端各自维护一个“文件”，在建立连接打开后，向自己的文件中写入数据，供对方读取</li></ul><p>Binder通信是Android系统特有的IPC机制，Binder的优点有以下几个：</p><ol><li>性能：Binder的效率高，只需要一次内存拷贝；而Linux中的管道、消息队列、套接字都需要2次；共享内存的方式不需要拷贝数据，但是有多进程同步的问题。</li><li>稳定性：Binder的架构是基于C&#x2F;S结构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</li><li>安全性：传统的 IPC 接收方无法获得对方可靠的进程用户ID&#x2F;进程ID（UID&#x2F;PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID&#x2F;PID是否满足访问权限。从安全角度，Binder的安全性更高。</li></ol><p>Binder通信的另外一个限制是最多16个线程。最多只能传输1M的数据，否则会有TransactionTooLarge的Exception。</p><h2 id="CountDownLatch原理"><a href="#CountDownLatch原理" class="headerlink" title="CountDownLatch原理"></a>CountDownLatch原理</h2><p>存在4个线程，想在4个线程都执行完毕后执行另一个线程，</p><p>countDownLatch是采用计数器的原理，存在两个方法:</p><p>countDown：计数-1</p><p>await：线程挂起，当计数为0时，执行其后的逻辑</p><h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><h4 id="泛型简述"><a href="#泛型简述" class="headerlink" title="泛型简述"></a>泛型简述</h4><p>java中泛型即是“参数化类型”，即该泛型类型是一个参数传入</p><blockquote><p>只在程序的源代码中存在，在编译后的字节码中已经替换为原生类型，这种方法称为伪泛型。</p></blockquote><p>java中的泛型只在编译时期有效，正确检验泛型的结果后，会将泛型相关的信息擦出，并在对象进入和离开的方法边界上添加<code>类型检查</code>和<code>类型转化</code>的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">classStringArrayList</span> <span class="operator">=</span> stringArrayList.getClass();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">classIntegerArrayList</span> <span class="operator">=</span> integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(classStringArrayList==classIntegerArrayList)&#123;   <span class="comment">//返回true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;类型相同&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>泛型有<code>泛型类</code>、<code>泛型方法</code>和<code>泛型接口</code></p><p>泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FruitGenerator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitGenerator</span> <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Pear&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span>&#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型对方法重载的影响？"><a href="#泛型对方法重载的影响？" class="headerlink" title="泛型对方法重载的影响？"></a>泛型对方法重载的影响？</h4><p>方法不能进行重载，会报错，<code>两种方法都有相同的擦除</code>，在编译期间进行泛型擦除的，会导致擦出后都一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listMethod</span><span class="params">(List&lt;String&gt; list1)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listMethod</span><span class="params">(List&lt;Integer&gt; list2)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h4 id="java类的初始化流程"><a href="#java类的初始化流程" class="headerlink" title="java类的初始化流程"></a>java类的初始化流程</h4><p>父类到子类，静态到（非静态，构造），变量—–&gt;代码块</p><p>父类静态变量—-父类静态代码块—-子类静态变量—-子类静态代码块—-父类非静态—-父类构造—-子类非静态—-子类构造</p><h4 id="jvm类加载机制的7个流程"><a href="#jvm类加载机制的7个流程" class="headerlink" title="jvm类加载机制的7个流程"></a>jvm类加载机制的7个流程</h4><h2 id="加载—–验证——准备——解析——初始化——-使用——卸载JVM将-java文件加载成二进制文件-class加载：1-获取二进制流class文件2-将静态存储结构转换为方法区中运行时的数据结构，存储到方法区中3-在堆中生成一个java对象，作为方法区的引用-获取-class文件并在堆中生成一个class对象，将加载的类结构信息存储在方法区"><a href="#加载—–验证——准备——解析——初始化——-使用——卸载JVM将-java文件加载成二进制文件-class加载：1-获取二进制流class文件2-将静态存储结构转换为方法区中运行时的数据结构，存储到方法区中3-在堆中生成一个java对象，作为方法区的引用-获取-class文件并在堆中生成一个class对象，将加载的类结构信息存储在方法区" class="headerlink" title="加载—–验证——准备——解析——初始化——-使用——卸载JVM将.java文件加载成二进制文件.class加载：1. 获取二进制流class文件2. 将静态存储结构转换为方法区中运行时的数据结构，存储到方法区中3. 在堆中生成一个java对象，作为方法区的引用&gt; 获取.class文件并在堆中生成一个class对象，将加载的类结构信息存储在方法区"></a>加载—–验证——准备——解析——初始化——-使用——卸载<br>JVM将.java文件加载成二进制文件.class<br>加载：<br>1. 获取二进制流class文件<br>2. 将静态存储结构转换为方法区中运行时的数据结构，存储到方法区中<br>3. 在堆中生成一个java对象，作为方法区的引用<br>&gt; 获取.class文件并在堆中生成一个class对象，将加载的类结构信息存储在方法区</h2><p>验证：JVM规范校验，代码逻辑校验</p><p>准备：为类变量分配内存并设置类变量的初始化，如果变量被final修饰，会直接放入对应的常量池中，并赋值</p><p>解析：常量池符号引用替换为内存的直接引用</p><p>（上述三种统称为连接）</p><hr><p>初始化：执行代码逻辑，对静态变量，静态代码块和类对象进行初始化</p><p>使用：使用初始化好的class对象</p><p>卸载：销毁创建class对象，负责运行的jvm退出内存</p><h5 id="全局变量和局部变量的区别"><a href="#全局变量和局部变量的区别" class="headerlink" title="全局变量和局部变量的区别"></a>全局变量和局部变量的区别</h5><ol><li>全局变量应用于整个类文件。局部变量只在方法执行期间存在，之后被回收。静态局部变量对本函数体始终可见</li><li>全局变量，全局静态变量，局部静态变量都在静态存储空间。局部变量在栈（虚拟机栈）中分配空间</li><li>全局变量初始化需要赋值，局部变量不需要赋值</li><li>一个<strong>类</strong>中不能声明同名全局变量，一个<strong>方法</strong>中不能声明同名局部变量。若全局变量和局部变量同名，则在方法中全局变量不生效。</li></ol><h5 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h5><p>当JVM碰到new字节码的时候，会先判断类是否已经初始化，如果没有初始化（有可能类还没有加载，如果是隐式装载，此时应该还没有类加载，就会先进行装载、验证、准备、解析四个阶段），然后进行类初始化。<br>如果已经初始化过了，就直接开始类对象的实例化工作，这时候会调用类对象的<init>方法。</p><h5 id="类初始化的时机"><a href="#类初始化的时机" class="headerlink" title="类初始化的时机"></a>类初始化的时机</h5><ol><li>初始化main方法的主类</li><li>new 关键字触发，如果类还没有被初始化</li><li>访问静态方法和静态字段时，目标对象类没有被初始化，则进行初始化操作</li><li>子类初始化过程中，如果发现父类没有初始化，则先初始化父类</li><li>通过反射API调用时，如果类没有初始化，则进行初始化操作</li><li>第一次调用java.lang.invoke.MethodHandle 实例时，需要初始化 MethodHandle 指向方法所在的类。</li></ol><h5 id="类的实例化触发时机"><a href="#类的实例化触发时机" class="headerlink" title="类的实例化触发时机"></a>类的实例化触发时机</h5><ol><li>new 触发实例化，创建对象</li><li>反射，class.newnIstance()和constructor.newnIstance()方法触发创建对象</li><li>Clone方法创建对象</li><li>使用序列化和反序列化的机制创建对象</li></ol><h5 id="类的初始化和类的实例化的区别"><a href="#类的初始化和类的实例化的区别" class="headerlink" title="类的初始化和类的实例化的区别"></a>类的初始化和类的实例化的区别</h5><p>类的初始化：为静态成员赋值，执行静态代码块<br>类的实例化：执行非静态方法和构造方法</p><ol><li>类的初始化只会执行一次，静态代码块只会执行一次</li><li>类的实例化会执行多次，每次实例化执行一次</li></ol><h5 id="在类都没有初始化完毕之前，能直接进行实例化相应的对象吗"><a href="#在类都没有初始化完毕之前，能直接进行实例化相应的对象吗" class="headerlink" title="在类都没有初始化完毕之前，能直接进行实例化相应的对象吗?"></a>在类都没有初始化完毕之前，能直接进行实例化相应的对象吗?</h5><p>正常情况下是先类初始化，再类实例化<br>在非正常情况下，比如在静态变量中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Person2</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person2</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">value4</span> <span class="operator">=</span> <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        value1 = <span class="number">101</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        value1 = <span class="number">102</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person2</span><span class="params">()</span>&#123;</span><br><span class="line">        value1 = <span class="number">103</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行public static Person2 p &#x3D; new Person2();这样就会直接实例化，然后在执行类的初始化，所以会打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">23123</span></span><br></pre></td></tr></table></figure><h5 id="多线程进行类的初始化会出问题吗？"><a href="#多线程进行类的初始化会出问题吗？" class="headerlink" title="多线程进行类的初始化会出问题吗？"></a>多线程进行类的初始化会出问题吗？</h5><p>不会，类初始化<Clinit>方法是阻塞的，多线程访问，只会有一个线程执行，其他阻塞。</p><h5 id="一个实例变量在对象初始化的过程中最多可以被赋值几次？"><a href="#一个实例变量在对象初始化的过程中最多可以被赋值几次？" class="headerlink" title="一个实例变量在对象初始化的过程中最多可以被赋值几次？"></a>一个实例变量在对象初始化的过程中最多可以被赋值几次？</h5><p>4次</p><ol><li>对象被创建时候，分配内存会把实例变量赋予默认值，这是肯定会发生的。</li><li>实例变量本身初始化的时候，就给他赋值一次，也就是int value1&#x3D;100。</li><li>初始化代码块的时候，也赋值一次。</li><li>构造函数中，在进行赋值一次。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        value1 = <span class="number">102</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person3</span><span class="params">()</span>&#123;</span><br><span class="line">        value1 = <span class="number">103</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h4><h5 id="高刷手机，60hz，120hz指的是什么？"><a href="#高刷手机，60hz，120hz指的是什么？" class="headerlink" title="高刷手机，60hz，120hz指的是什么？"></a>高刷手机，60hz，120hz指的是什么？</h5><p>屏幕刷新率，1s内屏幕刷新的次数。这个参数由手机硬件决定<br>一般大于60hz的就是高刷收集，特点在于刷新频率更高，就算存在丢帧、卡顿，也能保持稳定性。</p><h5 id="屏幕的刷新过程"><a href="#屏幕的刷新过程" class="headerlink" title="屏幕的刷新过程"></a>屏幕的刷新过程</h5><p>从左到右，从上到下，顺序显示像素点。当整个屏幕刷新完毕，即一个垂直刷新周期后，（1000&#x2F;60）16ms后再次刷新<br>一般一个图形界面的绘制，需要CPU准备数据，然后GPU进行绘制，绘制完写入缓存区，然后屏幕按照刷新频率来从这个缓存区中取图形显示。</p><p>所以整个刷新过程是CPU，GPU，屏幕（Display）三方合作的工作关系。</p><h5 id="帧率，VSYNC是什么"><a href="#帧率，VSYNC是什么" class="headerlink" title="帧率，VSYNC是什么"></a>帧率，VSYNC是什么</h5><p>帧率：GPU一秒内渲染绘制的操作的帧数，单位是fps，所以一般帧数和屏幕刷新度保持一致是效果最好的情况，不会导致一方浪费</p><p>VSYNC：垂直同步，作用是让帧率和屏幕刷新率保持一致，防止卡顿和跳帧。由于CPU和GPU绘制图像的时间不稳定，所以可能会发生卡顿情况，也就是下一帧的数据还没准备好无法正常显示在屏幕上，设置垂直同步后，要求CPU和GPU在16ms之内将下一帧的数据处理好，那么屏幕刷新的时候就可以直接从缓存中获取下一帧的数据并显示出来</p><h5 id="屏幕中单缓存，双缓存，三缓存"><a href="#屏幕中单缓存，双缓存，三缓存" class="headerlink" title="屏幕中单缓存，双缓存，三缓存"></a>屏幕中单缓存，双缓存，三缓存</h5><ol><li>单缓存：CPU计算好数据传递给GPU，GPU图像绘制后放到缓存区，display从缓存中获取数据并刷新屏幕<br>缺点：当第二帧的数据还没生成完成时，会导致屏幕中有一部分第一帧的数据，导致一个屏幕同时显示了两帧的数据</li><li>双缓存：CPU计算好数据传递到GPU，GPU图像会之后放入缓存区BackBuffer，当到达VSYNC垂直同步时间，将数据同步到缓存区FrameBuffer中，display从缓存区FrameBuffer中获取数据并显示<br>缺点：如果在一个垂直同步的时间内CPU+GPU没有渲染完成（开始绘制的时间在下次垂直同步时间附近，导致只有一小份垂直同步时间在绘制），就会浪费一个VSYNC垂直同步时间，当VSYNC垂直同步时间来临时，GPU正在处理数据，那么不会开启下一帧的处理，当GPU处理结束后，无法触发下一帧的数据处理，就会导致卡顿的情况</li><li>三缓存数据：当在一个垂直同步时间内没有完成处理，就会出现第三个缓存区，在第二个垂直同步时间，缓存下一帧的数据，这样两个缓存交替处理，保证FrameBuffer会拿到最新的数据，保证了显示的流畅度</li></ol><h5 id="代码中修改了UI，屏幕是怎么进行刷新的？"><a href="#代码中修改了UI，屏幕是怎么进行刷新的？" class="headerlink" title="代码中修改了UI，屏幕是怎么进行刷新的？"></a>代码中修改了UI，屏幕是怎么进行刷新的？</h5><p>当调用invalidate&#x2F;requestLayout中进行重绘工作时，会向VSYNC垂直同步服务请求，等待下一次VSYNC垂直同步时间，执行界面绘制刷新操作，CPU-&gt;GPU-&gt;Display</p><h5 id="如果界面保持静止不变，屏幕会刷新吗？图像会被重新绘制吗？"><a href="#如果界面保持静止不变，屏幕会刷新吗？图像会被重新绘制吗？" class="headerlink" title="如果界面保持静止不变，屏幕会刷新吗？图像会被重新绘制吗？"></a>如果界面保持静止不变，屏幕会刷新吗？图像会被重新绘制吗？</h5><p>屏幕不会刷新，不会重新绘制，如果屏幕不变，程序就收不到垂直同步时间，自动过滤，不处理屏幕刷新操作，只有当界面改变时，才会请求VSYNC垂直同步服务，触发下一次VSYNC垂直同步刷新屏幕</p><h4 id="jvm垃圾回收机制"><a href="#jvm垃圾回收机制" class="headerlink" title="jvm垃圾回收机制"></a>jvm垃圾回收机制</h4><p>首先介绍4个引用</p><p>强引用：在使用时不会被回收</p><p>软引用：系统内存不足时会被回收</p><p>弱引用：下一次gc会被回收</p><p>虚引用：任何时候都可能被回收</p><h2 id="小知识点-1"><a href="#小知识点-1" class="headerlink" title="小知识点"></a>小知识点</h2><h4 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h4><ol><li>抽象类中可包含普通方法+实现，接口类中只存在抽象方法，没有具体实现</li><li>抽象类中的值可以是任何类型的，接口中的值必须是public static final修饰的</li><li>一个类只能继承一个抽象类，一个类可以实现多个接口类</li><li>抽象类存在构造函数，接口类没有</li><li>抽象类中包含初始化块，接口中没有</li></ol><h4 id="static和final的区别"><a href="#static和final的区别" class="headerlink" title="static和final的区别"></a>static和final的区别</h4><p>static</p><p>是可以直接调用的（类名.方法&#x2F;变量），</p><p>可修饰属性，方法，代码段，内部类</p><p>所有对象只有一个值</p><p>final</p><p>可修饰属性，方法，类，局部变量</p><p>final修饰变量不可被更改值，方法不能被重写，类不能被继承</p><p>修饰集和的话，其引用不变，集和可以自由变化</p><h4 id="java是值传递还是引用传递"><a href="#java是值传递还是引用传递" class="headerlink" title="java是值传递还是引用传递"></a>java是值传递还是引用传递</h4><p>如果是基本类型就是值传递</p><p>引用类型就是引用传递</p><p>String表现为值传递，但是其实是作为形参后重新创建了对象，引用已经变化，所以是值传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    changeValue(str); </span><br><span class="line">    System.out.println(<span class="string">&quot;str值为: &quot;</span> + str);  <span class="comment">// str未被改变，str = &quot;123&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">changeValue</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Bobo&quot;</span>, <span class="number">15</span>);</span><br><span class="line">    changeValue1(student);   <span class="comment">// student值未改变，不为null! 输出结果 student值为 name:Bobo、age:15</span></span><br><span class="line">    <span class="comment">// changeValue2(student);  // student值被改变，输出结果 student值为 name:Lily、age:20</span></span><br><span class="line">    System.out.println(<span class="string">&quot;student值为 name: &quot;</span> + student.name + <span class="string">&quot;、age:&quot;</span> + student.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">changeValue1</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">    student = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">changeValue2</span><span class="params">(Student student)</span>  &#123;    </span><br><span class="line">     student.name = <span class="string">&quot;Lily&quot;</span>;    </span><br><span class="line">     student.age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="String、StringBuilder、StringBuffer的区别"><a href="#String、StringBuilder、StringBuffer的区别" class="headerlink" title="String、StringBuilder、StringBuffer的区别"></a>String、StringBuilder、StringBuffer的区别</h4><p>String是不可变的，每次赋值都是重新创建对象，对内存和性能都有损耗</p><p>StringBuilder是非线程安全的，存储通过一个可变长度的字符数组（char[]）。</p><p>append值时，如果所需长度大于分配长度，新建数组长度为（2倍+2），如果所需长度大于(2倍+2)，则使用所需长度大小，否则，使用(2倍+2)长度，默认长度为16，有参构造&#x3D;16+参数长度</p><p>StringBuffer是线程安全的</p><p>效率上由快到慢：StringBuilder &gt; StringBuffer &gt; String</p><h4 id="String为什么是final（不可变）的？"><a href="#String为什么是final（不可变）的？" class="headerlink" title="String为什么是final（不可变）的？"></a>String为什么是final（不可变）的？</h4><p>final+private保证了其不可修改性</p><ol><li>不可变性保证了线程安全</li><li>不可变后避免了深拷贝，将String值放在字符串常量池（堆内）中，供其他方引用，提高效率，节约内存</li></ol><h4 id="hashcode、equals和-的区别？"><a href="#hashcode、equals和-的区别？" class="headerlink" title="hashcode、equals和&#x3D;&#x3D; 的区别？"></a>hashcode、equals和&#x3D;&#x3D; 的区别？</h4><p>hashcode：</p><ol><li>基本类型就是改值</li><li>引用类型是对象在内存地址的映射</li></ol><p>equals：</p><ol><li>在object中equals方法等效于&#x3D;&#x3D;</li><li>在其他方法中，重写了equals方法，会判断值是否相等</li></ol><p>&#x3D;&#x3D;：</p><ol><li>基本类型比对的是值</li><li>引用对象比对的是内存地址的映射</li></ol><p>对于String，Integer对象，他们重写了equals方法，所以其equals方法可以判断值是否相等，而&#x3D;&#x3D;只能判断引用是否相等</p><h4 id="进程，线程，协程的区别？阻塞和非阻塞的区别？"><a href="#进程，线程，协程的区别？阻塞和非阻塞的区别？" class="headerlink" title="进程，线程，协程的区别？阻塞和非阻塞的区别？"></a>进程，线程，协程的区别？阻塞和非阻塞的区别？</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>进程包含线程<br>进程是CPU分配资源的最小单位</p><h5 id="线程-1"><a href="#线程-1" class="headerlink" title="线程"></a>线程</h5><p>线程包含协程<br>线程是独立运行和独立调度的基本单位（CPU上真正执行的是线程）<br>线程间共享进程内资源<br>线程的调度切换比进程快</p><h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><p>协程是存在线程之上，通过异步IO处理执行多个协程的操作<br>协程的调度切换比线程快</p><h5 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h5><p>阻塞就是线程被cpu挂起，不执行线程逻辑<br>非阻塞就是线程不被cpu挂起，执行线程逻辑</p><h5 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h5><p>并发是你执行一下，我执行一下，轮着执行<br>并行是一起执行</p><h5 id="协程和线程的比较"><a href="#协程和线程的比较" class="headerlink" title="协程和线程的比较"></a>协程和线程的比较</h5><ol><li>协程运行在线程之上</li><li>线程执行由内核控制（内核态执行），控制线程切换消耗资源（抢先式），协程由程序执行（也就是在用户态执行）</li><li>协程比线程更加轻量</li><li>多核处理器的情况下，多个线程是可以并行的，但是运行的协程的函数却只有一个，其他协程都会被suspend（阻塞）。即协程是并发的，但不是并行的。</li><li>执行密集型IO操作，性能提高</li><li>在协程之间的切换不需要涉及任何系统调用或任何阻塞调用</li></ol><h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p><img src="https://static.oschina.net/uploads/img/201604/21095604_vhHX.png" alt="img"></p><ol><li><p>多路复用IO</p><p>执行A事件，同时执行B事件，通过状态下发，获取A，B执行状态</p></li><li><p>信号驱动IO</p></li><li><p>异步IO</p><p>执行A事件，通过异步处理，当A事件处理完成不哦，通知主进程&#x2F;线程</p></li><li><p>阻塞IO：</p><p>执行完A事件，在执行B事件</p></li><li><p>非阻塞IO</p><p>执行A事件，同时执行B事件，一直监听A，B的执行过程</p></li></ol><h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h1><h4 id="kotlin协程？"><a href="#kotlin协程？" class="headerlink" title="kotlin协程？"></a>kotlin协程？</h4><p>kotlin协程使用<code>Coroutine</code>，通过使用<code>函数挂起</code>(非阻塞挂起)的方式来保证协程的使用，内部使用状态机来管理协程的挂起点</p><p>每当遇到<code>suspend</code>修饰的方法，都有可能会挂起当前的协程，通过<code>GlobalScope.launch</code>或者其他方式执行suspend修饰的方法时，进行挂起操作</p><h4 id="suspend，runBlocking，launch，withContext，async，doAsync之间的区别"><a href="#suspend，runBlocking，launch，withContext，async，doAsync之间的区别" class="headerlink" title="suspend，runBlocking，launch，withContext，async，doAsync之间的区别"></a>suspend，runBlocking，launch，withContext，async，doAsync之间的区别</h4><p>suspend：挂起函数的标志</p><p>runBlocking：阻塞式全局协程</p><p>launch：非阻塞全局协程</p><p>withContext：任务是串行的</p><p>async：任务是并行的</p><p>doAsync：封装java的Future类，便于线程切换的，并非协程</p><h1 id="网络篇"><a href="#网络篇" class="headerlink" title="网络篇"></a>网络篇</h1><h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><h4 id="简述一次完整的Http请求过程"><a href="#简述一次完整的Http请求过程" class="headerlink" title="简述一次完整的Http请求过程"></a>简述一次完整的Http请求过程</h4><p>通过域名请求后————&gt;DNS域名解析为ip地址————&gt;中间路由跳转————&gt;直接访问ip地址进行三次握手————&gt;tcp三次握手成功后进行通信响应———&gt;tcp四次挥手结束通信</p><p>客户端：</p><ol><li>在浏览器输入网址。</li><li>浏览器解析网址，并生成http请求消息。</li><li>浏览器调用系统解析器，发送消息到DNS服务器查询域名对应的ip。</li><li>拿到ip后，和请求消息一起交给操作系统协议栈的TCP模块。</li><li>将数据分成一个个数据包，并加上TCP报头形成TCP数据包。</li><li>TCP报头包括发送方端口号、接收方端口号、数据包的序号、ACK号。</li><li>然后将TCP消息交给IP模块。</li><li>IP模块会添加IP头部和MAC头部。</li><li>IP头部包括IP地址，为IP模块使用，MAC头部包括MAC地址，为数据链路层使用。</li><li>IP模块会把整个消息包交给网络硬件，也就是数据链路层，比如以太网，WIFI等。</li><li>然后网卡会将这些包转换成电信号或者在光信号，通过网线或者光纤发送出去，再由路由器等转发设备送达接收方。</li></ol><p>服务器端：</p><ol><li>数据包到达服务器的数据链路层，比如以太网，然后会将其转换为数据包（数字信号）交给IP模块。</li><li>IP模块会将MAC头部和IP头部后面的内容，也就是TCP数据包发送给TCP模块。</li><li>TCP模块会解析TCP头信息，然后和客户端沟通表示收到这个数据包了。</li><li>TCP模块在收到消息的所有数据包之后，就会封装好消息，生成相应报文发给应用层，也就是HTTP层。</li><li>HTTP层收到消息，比如是HTML数据，就会解析这个HTML数据，最终绘制到浏览器页面上。</li></ol><h4 id="简述三次握手和四次挥手"><a href="#简述三次握手和四次挥手" class="headerlink" title="简述三次握手和四次挥手"></a>简述三次握手和四次挥手</h4><p><img src="http://img-blog.csdn.net/20180208112533496" alt="img"><br>三次握手：<br>客户端发送一个随机seq&#x3D;100<br>服务端返回一个随机seq&#x3D;200，ack&#x3D;100+1<br>客户端返回一个ack&#x3D;200+1</p><p>四次挥手：<br>客户端发送一个FIN&#x3D;1，seq&#x3D;100<br>服务端发送一个ack&#x3D;100+1<br>服务端发送一个FIN&#x3D;1，seq&#x3D;200<br>客户端发送一个ack&#x3D;200+1</p><p>服务端发送两次的原因是需要等待服务器处理当前任务完毕。</p><h4 id="为什么需要三次握手而不是2次或者4次？"><a href="#为什么需要三次握手而不是2次或者4次？" class="headerlink" title="为什么需要三次握手而不是2次或者4次？"></a>为什么需要三次握手而不是2次或者4次？</h4><blockquote><p>防止已失效的连接请求又传送到服务器端，因而产生错误</p></blockquote><p>两次的话，服务端是不知道自己的请求是否成功发送到客户端的。但是服务端又会认为连接建立成功了。假设第二次丢失了，客户端认为服务端没有响应，就会重发一次，这样已经失效的连接请求就会传送到服务端。</p><p>tcp是可靠的双方通信协议，所以双方都会生成一个初始的序列号供双方确认，如果改成两次，只会确定客户端对于服务端具有可靠性，而服务端对客户端没有可靠性</p><p>四次的话，太过繁琐</p><h4 id="为什么握手需要三次？挥手却需要四次？"><a href="#为什么握手需要三次？挥手却需要四次？" class="headerlink" title="为什么握手需要三次？挥手却需要四次？"></a>为什么握手需要三次？挥手却需要四次？</h4><p>因为挥手的时候需要等待服务器将本次连接中的所有保文都处理完，在发送关闭状态，说白了，服务器需要等待自身进入可关闭状态</p><h4 id="握手可以携带数据信息吗？"><a href="#握手可以携带数据信息吗？" class="headerlink" title="握手可以携带数据信息吗？"></a>握手可以携带数据信息吗？</h4><p>第三次请求可以携带数据信息，客户端认为连接已经建立的，就可以携带参数，但是前两次不能，容易造成对服务器的攻击</p><h4 id="为什么TIME-WAIT状态需要等待2MSL才能转换到CLOSE状态？"><a href="#为什么TIME-WAIT状态需要等待2MSL才能转换到CLOSE状态？" class="headerlink" title="为什么TIME_WAIT状态需要等待2MSL才能转换到CLOSE状态？"></a>为什么TIME_WAIT状态需要等待2MSL才能转换到CLOSE状态？</h4><ol><li>保证最后一次能成功到达服务器。最后一次客户端发送给服务端的确认信息可能丢失，如果丢失，服务端会有重试机制，等待一来一回的时间，也就是2MSL的时间，如果没有接收到服务端的重试请求，就认为服务端接收了，等到了就刷新2MSL时间</li><li>等待2MSL的时间也是为了<strong>防止失效连接的请求报文会出现在新连接</strong>中，防止第三次重试请求能被客户端接受，不会干扰其他请求</li></ol><h4 id="SSL层在传输层还是应用层？"><a href="#SSL层在传输层还是应用层？" class="headerlink" title="SSL层在传输层还是应用层？"></a>SSL层在传输层还是应用层？</h4><p>SSL层在传输层和应用层之间，是一个SSL层</p><h4 id="滑动窗口？"><a href="#滑动窗口？" class="headerlink" title="滑动窗口？"></a>滑动窗口？</h4><h4 id="拥塞控制？"><a href="#拥塞控制？" class="headerlink" title="拥塞控制？"></a>拥塞控制？</h4><h4 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h4><p>1、基于连接与无连接；</p><p>2、对系统资源的要求（TCP较多，UDP少）；</p><p>3、UDP程序结构较简单；</p><p>4、流模式与数据报模式 ；</p><p>5、TCP保证数据正确性，UDP可能丢包；</p><p>6、TCP保证数据顺序，UDP不保证。</p><h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><ul><li><p>1XX - 临时消息。服务器收到请求，需要请求者继续操作。</p></li><li><p>2XX - 请求成功。请求成功收到，理解并处理。</p></li><li><p>3XX - 重定向。需要进一步的操作以完成请求。</p></li><li><p>4XX - 客户端错误。请求包含语法错误或无法完成请求。</p></li><li><p>5XX - 服务器错误。服务器在处理请求的过程中发生了错误。</p></li></ul><p>200：客户端请求成功<br>301：资源（网页等）被永久转移到其他URL<br>302：重定向，临时跳转<br>400：客户端请求存在语法错误，不能给被服务器理解（Bad Request）<br>404：请求资源不存在，错误的URL<br>500：服务器内部发生了不可预料的错误<br>502：网关错误（Bad Getway）<br>503：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。（Server Unavailable）</p><h4 id="简述TCP和UDP的区别"><a href="#简述TCP和UDP的区别" class="headerlink" title="简述TCP和UDP的区别"></a>简述TCP和UDP的区别</h4><p>TCP：需要数据准确、顺序不能错、要求稳定可靠的场景就需要用到TCP。<br>UDP：数据即时性</p><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><p>tcp内部是由socket协议填充的</p><h4 id="简述https的加密过程"><a href="#简述https的加密过程" class="headerlink" title="简述https的加密过程"></a>简述https的加密过程</h4><p>RSA是非对称加密，AES是对称加密</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/882dee9d98c9455bbb51cc73f22d0487~tplv-k3u1fbpfcp-zoom-1.image" alt="加密过程"></p><ol><li>客户端请求服务端进行访问</li><li>服务端创建RSA，获得私钥和公钥</li><li>服务端发送公钥给客户端</li><li>客户端经过复杂的证书验证</li><li>客户端生成AES密钥</li><li>将AES密钥经过RSA公钥加密后发送给服务端</li><li>服务端通过RSA私钥解密获取AES密钥</li><li>客户端和服务端后续通过AES密钥进行通信</li></ol><h4 id="为什么要使用RSA加密形式交换AES密钥，不直接使用RSA加密？"><a href="#为什么要使用RSA加密形式交换AES密钥，不直接使用RSA加密？" class="headerlink" title="为什么要使用RSA加密形式交换AES密钥，不直接使用RSA加密？"></a>为什么要使用RSA加密形式交换AES密钥，不直接使用RSA加密？</h4><p>因为RSA加密有性能上的损耗，加解密过程会比较耗时，不适用于频繁通信过程，而AES加密比较快捷</p><h4 id="简述中间人攻击，如何解决？（dns劫持）"><a href="#简述中间人攻击，如何解决？（dns劫持）" class="headerlink" title="简述中间人攻击，如何解决？（dns劫持）"></a>简述中间人攻击，如何解决？（dns劫持）</h4><ol><li>客户端访问域名A，向服务端进行请求</li><li>中间人劫持dns，使之指向私人ip  B。即客户端同B建立https连接</li><li>B在和A建立https连接</li><li>服务端创建RSA，获得公钥（S）和私钥（S）</li><li>服务端发送公钥（S）给客户端</li><li>中间人拦截信息，获得公钥（S）</li><li>生成RSA公钥（中）和私钥（中），并将公钥（中）发送给客户端</li><li>客户端生成AES密钥</li><li>使用公钥（中）加密AES密钥，并发送给服务端</li><li>中间人拦截信息，获得加密信息，使用私钥（中）进行解密，获得AES密钥</li><li>中间人使用公钥（S）加密AES密钥，并发送给服务端</li><li>服务端通过私钥（S）进行解密，获得AES密钥。</li></ol><p>到此为止，中间人持有客户端和服务端交换的AES密钥，可以进行消息拦截，并解密信息</p><p>解决方案：将RSA公钥交给CA机构，CA机构添加上域名，有效期等将其制作成证书，在用CA机构的私钥进行加密后放置在服务器上，当客户端请求时，返回加密后信息，客户端从CA机构获取公钥（一般情况下内置在机器中）进行解密，成功解密后，获取的信息，域名等可以匹配上，则CA验证通过，获得服务器公钥，走下面流程。</p><blockquote><p>https 无法防止中间人攻击，只有做证书固定ssl-pinning 或者 apk中预置证书做自签名验证可以防中间人攻击</p></blockquote><blockquote><p>证书固定（Certificate Pinning）是指Client端内置Server端真正的公钥证书。在HTTPS请求时，Server端发给客户端的公钥证书必须与Client端内置的公钥证书一致，请求才会成功。</p></blockquote><h4 id="http分层"><a href="#http分层" class="headerlink" title="http分层"></a>http分层</h4><p><img src="http://bkimg.cdn.bcebos.com/pic/0dd7912397dda144d48ab350bbb7d0a20df48655" alt="img"></p><p><img src="http://images2015.cnblogs.com/blog/705728/201604/705728-20160424234824085-667046040.png" alt="img"></p><p><img src="http://img-blog.csdn.net/20170822222325781" alt="img"></p><h4 id="dns污染"><a href="#dns污染" class="headerlink" title="dns污染"></a>dns污染</h4><p>国家或地区防止摸一个网站被访问，是dns发送出错误的ip地址，使之无法访问</p><p>使用代理服务器和vpn</p><h4 id="http1-0、http1-1和http2-0的区别"><a href="#http1-0、http1-1和http2-0的区别" class="headerlink" title="http1.0、http1.1和http2.0的区别"></a>http1.0、http1.1和http2.0的区别</h4><p>1.0：短暂连接，重复访问，连接无法复用</p><p>1.1：支持持久连接，长连接，优化1.0带来的性能问题，可以多路复用（数量限制），串行处理，一条失败，后续全部失败，<strong>同步</strong></p><p>2.0：优化多路复用机制，header压缩，并行处理，<strong>异步</strong></p><p>3.0：UDP</p><h1 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h1><table><thead><tr><th>排序方法</th><th>时间复杂度（平均）</th><th>时间复杂度（最坏)</th><th>时间复杂度（最好)</th><th>空间复杂度</th><th>稳定性</th><th>复杂性</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n2)O(n2)</td><td>O(n2)O(n2)</td><td>O(n)O(n)</td><td>O(1)O(1)</td><td>稳定</td><td>简单</td></tr><tr><td>希尔排序</td><td>O(nlog2n)O(nlog2n)</td><td>O(n2)O(n2)</td><td>O(n)O(n)</td><td>O(1)O(1)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>直接选择排序</td><td>O(n2)O(n2)</td><td>O(n2)O(n2)</td><td>O(n2)O(n2)</td><td>O(1)O(1)</td><td>不稳定</td><td>简单</td></tr><tr><td>堆排序</td><td>O(nlog2n)O(nlog2n)</td><td>O(nlog2n)O(nlog2n)</td><td>O(nlog2n)O(nlog2n)</td><td>O(1)O(1)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>冒泡排序</td><td>O(n2)O(n2)</td><td>O(n2)O(n2)</td><td>O(n)O(n)</td><td>O(1)O(1)</td><td>稳定</td><td>简单</td></tr><tr><td>快速排序</td><td>O(nlog2n)O(nlog2n)</td><td>O(n2)O(n2)</td><td>O(nlog2n)O(nlog2n)</td><td>O(nlog2n)O(nlog2n)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>归并排序</td><td>O(nlog2n)O(nlog2n)</td><td>O(nlog2n)O(nlog2n)</td><td>O(nlog2n)O(nlog2n)</td><td>O(n)O(n)</td><td>稳定</td><td>较复杂</td></tr><tr><td>基数排序</td><td>O(d(n+r))O(d(n+r))</td><td>O(d(n+r))O(d(n+r))</td><td>O(d(n+r))O(d(n+r))</td><td>O(n+r)O(n+r)</td><td>稳定</td><td>较复杂</td></tr></tbody></table><h4 id="冒泡排序-BubbleSort"><a href="#冒泡排序-BubbleSort" class="headerlink" title="冒泡排序(BubbleSort)"></a>冒泡排序(BubbleSort)</h4><p>依次比较两个相邻的元素，如果顺序错误就交换，直到跑完所有元素，那么最后一个元素就是最大（最小）的值，在接着按照上述操作进行排序。</p><p>时间复杂度：O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> a[])</span>&#123;</span><br><span class="line">       <span class="type">int</span> temp;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;a.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                   temp = a[j];</span><br><span class="line">                   a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                   a[j+<span class="number">1</span>] = temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>第一趟找出最小的放在第一个，第二趟找出第二小的放在第二个，。。。。。</p><p>时间复杂度：O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span> a[])</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;j&lt;a.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]&gt;a[j])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">                    a[i] = a[j];</span><br><span class="line">                    a[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序（QuickSort）"><a href="#快速排序（QuickSort）" class="headerlink" title="快速排序（QuickSort）"></a>快速排序（QuickSort）</h4><p>分治法：将一大块分解成若干小块，一块一块算</p><ul><li>设置一边的值为哨兵</li><li>将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li><li>在对剩下的区间进行排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">//结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(left &lt;right)&#123;</span><br><span class="line">        <span class="comment">//每一趟排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> division(a,left,right);</span><br><span class="line">        <span class="comment">//哨兵两边开始排序</span></span><br><span class="line">        <span class="comment">//左边</span></span><br><span class="line">        quickSort(a,left,base-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//右边</span></span><br><span class="line">        quickSort(a,base+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用分治法排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">division</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">//哨兵</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> a[left];</span><br><span class="line">    <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">        <span class="comment">//哨兵在左边，所以right左移</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; a[right]&gt;=base)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left != right) &#123;</span><br><span class="line">            a[left] = a[right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//哨兵在右边，所以left右移</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; a[left]&lt;=base)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left != right) &#123;</span><br><span class="line">            a[right] = a[left];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[left] = base;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>二分插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">           <span class="comment">//二分法一分而二，数组中间下标</span></span><br><span class="line">           <span class="keyword">final</span> <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="comment">//二分法一分而二，数组中间下标处的值</span></span><br><span class="line">           <span class="keyword">final</span> <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> array[mid];</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (midVal &lt; value) &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               如果数组中间处的值比要找的值小，代表要找的值</span></span><br><span class="line"><span class="comment">               在数组的中后部部分，所以当前下标取值为mid + 1</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               lo = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; value) &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">               如果数组中间处的值比要找的值大，代表要找的值</span></span><br><span class="line"><span class="comment">               在数组的前中部部分，所以当前下标取值为mid - 1</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               hi = mid - <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//数组中间处的值与要找的值相等，直接返回数组中部的下标mid</span></span><br><span class="line">               <span class="keyword">return</span> mid;  <span class="comment">// value found</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>插入排序</p><p>从尾部开始遍历，每次–，比他大的值后移一位，直到找到相等或者比它小的，直接赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="扑克牌算法"><a href="#扑克牌算法" class="headerlink" title="扑克牌算法"></a>扑克牌算法</h4><h4 id="根节点到目标节点的路径"><a href="#根节点到目标节点的路径" class="headerlink" title="根节点到目标节点的路径"></a>根节点到目标节点的路径</h4><h4 id="找出最小的k个数"><a href="#找出最小的k个数" class="headerlink" title="找出最小的k个数"></a>找出最小的k个数</h4><ol><li>使用快速排序：O(nlogn)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] getLeastNumbers1(<span class="type">int</span>[] input, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span> || input.length &lt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] output = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    pivotFindMinK(input, output, k, <span class="number">0</span>, input.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pivotFindMinK</span><span class="params">(<span class="type">int</span>[] numbers, <span class="type">int</span>[] output, <span class="type">int</span> k, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="literal">null</span> || numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> numbers[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (numbers[right] &gt; temp &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        numbers[left] = numbers[right];</span><br><span class="line">        <span class="keyword">while</span> (numbers[left] &lt;= temp &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        numbers[right] = numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">    numbers[left] = temp;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; k-<span class="number">1</span>) &#123;</span><br><span class="line">        pivotFindMinK(numbers, output, k, start, left - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; k-<span class="number">1</span>) &#123;</span><br><span class="line">        pivotFindMinK(numbers, output, k, right + <span class="number">1</span>, end);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.arraycopy(numbers, <span class="number">0</span>, output, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>新建一个数组，放入数组前k个数，并由小到大排列好，遍历原数组，如果存在比新数组中的值更小，插入排序，而后得到新数组。</li><li>小根堆实现，按顺序放入小根堆—大顶堆（父节点&lt;&#x3D;子节点），小根堆大小为k，超过大小，删除堆顶元素，相反的话，加入大根堆—小顶堆（父节点&gt;&#x3D;子节点）</li></ol><h4 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用递归的二分查找</span></span><br><span class="line"><span class="comment"> *title:recursionBinarySearch</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> arr 有序数组</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> key 待查找关键字</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@return</span> 找到的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">recursionBinarySearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> key,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(key &lt; arr[low] || key &gt; arr[high] || low &gt; high)&#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (low + high) / <span class="number">2</span>;<span class="comment">//初始中间位置</span></span><br><span class="line"><span class="keyword">if</span>(arr[middle] &gt; key)&#123;</span><br><span class="line"><span class="comment">//比关键字大则关键字在左区域</span></span><br><span class="line"><span class="keyword">return</span> recursionBinarySearch(arr, key, low, middle - <span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle] &lt; key)&#123;</span><br><span class="line"><span class="comment">//比关键字小则关键字在右区域</span></span><br><span class="line"><span class="keyword">return</span> recursionBinarySearch(arr, key, middle + <span class="number">1</span>, high);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个整形数组里求两个数的和能不能等于一个给定数"><a href="#一个整形数组里求两个数的和能不能等于一个给定数" class="headerlink" title="一个整形数组里求两个数的和能不能等于一个给定数"></a>一个整形数组里求两个数的和能不能等于一个给定数</h4><ol><li>如果数组是有序的，两个下标，如果相加大于给定数，左边–，如果小于给定数，右边++，直到数据相等或者右边等于左边</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">56</span>,<span class="number">456</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> a.length-<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">65</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i] + a[j] &gt;sum)&#123;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i] + a[j] &lt;sum)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(a[i] + <span class="string">&quot;+&quot;</span> + a[j] + <span class="string">&quot;=&quot;</span> + sum);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如果数组是无序的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                System.out.println(nums[map.get(nums[i])] + <span class="string">&quot;+&quot;</span> + nums[i] + <span class="string">&quot;=&quot;</span> + target);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> target-nums[i];</span><br><span class="line">            map.put(value,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] + sum &lt; nums[i])&#123;</span><br><span class="line">            sum = nums[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum +=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; max)&#123;</span><br><span class="line">            max = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, votes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(votes == <span class="number">0</span>) x = num;</span><br><span class="line">            votes += num == x ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(BinaryTreeNode root)</span> &#123;</span><br><span class="line">       BinaryTreeNode temp;</span><br><span class="line">       Queue&lt;BinaryTreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;BinaryTreeNode&gt;();</span><br><span class="line">       queue.offer(root);</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">           temp = queue.poll();</span><br><span class="line">           System.out.print(temp.getData() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span> (<span class="literal">null</span> != temp.getLeft())</span><br><span class="line">               queue.offer(temp.getLeft());</span><br><span class="line">           <span class="keyword">if</span> (<span class="literal">null</span> != temp.getRight()) &#123;</span><br><span class="line">               queue.offer(temp.getRight());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历递归的方式</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(BinaryTreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="literal">null</span> != root) &#123;</span><br><span class="line">           System.out.print(root.getData() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">           preOrder(root.getLeft());</span><br><span class="line">           preOrder(root.getRight());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">//前序遍历非递归的方式</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrderNonRecursive</span><span class="params">(BinaryTreeNode root)</span> &#123;</span><br><span class="line">       Stack&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;BinaryTreeNode&gt;();</span><br><span class="line">       stack.push(root);</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">           <span class="type">BinaryTreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">           System.out.print(node.getData() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span> (node.getRight() != <span class="literal">null</span>) &#123;</span><br><span class="line">               stack.push(node.getRight());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (node.getLeft() != <span class="literal">null</span>) &#123;</span><br><span class="line">               stack.push(node.getLeft());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//中序便利非递归</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list;</span><br><span class="line">       &#125;</span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">       stack.add(root);</span><br><span class="line">       <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">           <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">               stack.add(node);</span><br><span class="line">               stack.add(node.left);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               list.add(node.val);</span><br><span class="line">               <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                   stack.add(node.right);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">                       <span class="type">TreeNode</span> <span class="variable">node1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                       list.add(node1.val);</span><br><span class="line">                       <span class="keyword">if</span>(node1.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                           stack.add(node1.right);</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//后序遍历</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">       stack.add(root);</span><br><span class="line">       <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">           list.add(node.val);</span><br><span class="line">           <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">               stack.add(node.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">               stack.add(node.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> list.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           result.add(list.get(i));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//之字形打印</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; listList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> listList;</span><br><span class="line">       &#125;</span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       queue.add(root);</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">           <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> queue.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;count;j++)&#123;</span><br><span class="line">               <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">               <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                   list.addFirst(node.val);</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   list.add(node.val);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                   queue.add(node.left);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                   queue.add(node.right);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           i++;</span><br><span class="line">           <span class="keyword">if</span>(list.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               listList.add(list);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> listList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="两个view第一个公共父view"><a href="#两个view第一个公共父view" class="headerlink" title="两个view第一个公共父view"></a>两个view第一个公共父view</h4><ol><li>引入set集和，一个用来存贮a数据，将b放入a数组，当数组重复会返回false，放入另一个set中做返回。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title function_">getIds</span><span class="params">(Integer[] a, Integer[] b)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  Set&lt;Integer&gt; same = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();  <span class="comment">//用来存放两个数组中相同的元素</span></span><br><span class="line">  Set&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();  <span class="comment">//用来存放数组a中的元素</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">  temp.add(a[i]);   <span class="comment">//把数组a中的元素放到Set中，可以去除重复的元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; b.length; j++) &#123;</span><br><span class="line">    <span class="comment">//把数组b中的元素添加到temp中</span></span><br><span class="line">    <span class="comment">//如果temp中已存在相同的元素，则temp.add（b[j]）返回false</span></span><br><span class="line"><span class="keyword">if</span>(!temp.add(b[j]))</span><br><span class="line">same.add(b[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想知道两个数组的索引，使用map存储，key是值，value是数组索引，在进行map.containsKey()对比，找到则使用</p><ol start="2"><li>将a数组放入set中，将b轮询放入set中，返回false，则重复值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getIds</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[])</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Integer integer:a)&#123;</span><br><span class="line">            set1.add(integer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Integer j:b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set1.add(j))&#123;</span><br><span class="line">                System.out.println(j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>两个链表中第一个根节点</li></ol><p>两个指针分别跑两条链，短的跑完后，将长的头赋值过去，再开始跑，长的跑完亦然，最终两指针相交地方为两链表的第一个根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getNode</span><span class="params">(Node nodeA, Node nodeB)</span> &#123;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">pA</span> <span class="operator">=</span> nodeA;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">pB</span> <span class="operator">=</span> nodeB;</span><br><span class="line">       <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">           <span class="keyword">if</span> (pA.next == <span class="literal">null</span>) &#123;</span><br><span class="line">               pA = nodeB;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               pA = pA.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (pB.next == <span class="literal">null</span>) &#123;</span><br><span class="line">               pB = nodeA;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               pB = pB.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.print(pA.value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>二叉树的最近公共祖先<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode node;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        dps(root,p,q);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dps</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == p.val)&#123;</span><br><span class="line">            node = p;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == q.val)&#123;</span><br><span class="line">            node = q;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span> dps(root.left,p,q);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> dps(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(a &amp;&amp; b)&#123;</span><br><span class="line">            node = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a || b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="判断链表是不是环链，并返回入口"><a href="#判断链表是不是环链，并返回入口" class="headerlink" title="判断链表是不是环链，并返回入口"></a>判断链表是不是环链，并返回入口</h4><p>两个指针，一个一次跑一个，一个一次跑两个，相交的话就是存在环链</p><p>将跑的慢的从头开始一个一个跑，跑的快的从相交的点开始跑，一个一个跑，最终相遇的就是入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">isCircle</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">q</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) &#123;</span><br><span class="line">            p = p.next.next;</span><br><span class="line">            q = q.next;</span><br><span class="line">            <span class="keyword">if</span>(p == q)&#123;</span><br><span class="line">                <span class="keyword">while</span>(node != p)&#123;</span><br><span class="line">                  node = node.next;</span><br><span class="line">                  p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="有一个整型数组，包含正数和负数，将负数放在左边，且保证相对位置保持不变"><a href="#有一个整型数组，包含正数和负数，将负数放在左边，且保证相对位置保持不变" class="headerlink" title="有一个整型数组，包含正数和负数，将负数放在左边，且保证相对位置保持不变"></a>有一个整型数组，包含正数和负数，将负数放在左边，且保证相对位置保持不变</h4><p>转化成链表，遍历链表将复苏和单独成链后连接到剩下的正数链上</p><p>数组两个索引，一个索引记录负数的尾部，一个所以负责遍历，每找到一个负数，将其插入该值，后续值后移一位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> a[])</span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>;j&lt;a.length;j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(a[j]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[j];</span><br><span class="line">               <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j;</span><br><span class="line">               <span class="keyword">while</span>(i&lt;=k-<span class="number">1</span>)&#123;</span><br><span class="line">                   a[k] = a[k-<span class="number">1</span>];</span><br><span class="line">                   k--;</span><br><span class="line">               &#125;</span><br><span class="line">               a[i] = temp;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i:a)&#123;</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="打印蛇形矩阵"><a href="#打印蛇形矩阵" class="headerlink" title="打印蛇形矩阵"></a>打印蛇形矩阵</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[(r + <span class="number">1</span>) * (b + <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) res[x++] = matrix[t][i]; <span class="comment">// left to right.</span></span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t; i &lt;= b; i++) res[x++] = matrix[i][r]; <span class="comment">// top to bottom.</span></span><br><span class="line">            <span class="keyword">if</span>(l &gt; --r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r; i &gt;= l; i--) res[x++] = matrix[b][i]; <span class="comment">// right to left.</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt; --b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b; i &gt;= t; i--) res[x++] = matrix[i][l]; <span class="comment">// bottom to top.</span></span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求二叉树的叶子节点数"><a href="#求二叉树的叶子节点数" class="headerlink" title="求二叉树的叶子节点数"></a>求二叉树的叶子节点数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">testTree</span><span class="params">(Tree tree)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree.left==<span class="literal">null</span>&amp;&amp;tree.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;叶子节点：&quot;</span>+tree.val);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> testTree(tree.left)+testTree(tree.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="求二叉树的深度"><a href="#求二叉树的深度" class="headerlink" title="求二叉树的深度"></a>求二叉树的深度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算左子树的深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> treeDepth(root.left);</span><br><span class="line">        <span class="comment">// 计算右子树的深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> treeDepth(root.right);</span><br><span class="line">        <span class="comment">// 树root的深度=路径最长的子树深度 + 1</span></span><br><span class="line">        <span class="keyword">return</span> left &gt;= right ? (left + <span class="number">1</span>) : (right + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="数组最大和"><a href="#数组最大和" class="headerlink" title="数组最大和"></a>数组最大和</h4><p>累加值：一个一个累加的值</p><p>最大值：记录累加值的最大值</p><p>假设数组为最大，每次添加一个值，如果i-1的值&lt;0，那么把i放入累加值，如果&gt;0，那么将i的值加到累加值，如果累加值&gt;最大值，则更新最大值。</p><p>如果需要数组的最大和的下标，对最大值的下标进行记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>,-<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,-<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">begintime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span>  FindGreatestSumOfSubArray(array);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">endtime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;连续子数组的最大和为：&quot;</span>+result+<span class="string">&quot;,运行时间：&quot;</span>+(endtime - begintime) + <span class="string">&quot;ns&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">FindGreatestSumOfSubArray</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] currentsum = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        currentsum[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">greatsetsum</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;第1步：累加子数组和：&quot;</span>+currentsum[<span class="number">0</span>]+<span class="string">&quot;，最大子数组和：&quot;</span>+greatsetsum);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="comment">//下面是动态规划的状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span>(currentsum[i-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                currentsum[i] = currentsum[i-<span class="number">1</span>] + array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                currentsum[i] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据currentsum的值更新greatsetsum的值</span></span><br><span class="line">            <span class="keyword">if</span>(currentsum[i] &gt; greatsetsum)&#123;</span><br><span class="line">                greatsetsum  = currentsum[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;步：累加子数组和：&quot;</span>+currentsum[i]+<span class="string">&quot;，最大子数组和：&quot;</span>+greatsetsum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> greatsetsum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有面值为1，3，5的硬币若干，需要凑成11元需要多少硬币，凑成n元最少需要多少硬币？"><a href="#有面值为1，3，5的硬币若干，需要凑成11元需要多少硬币，凑成n元最少需要多少硬币？" class="headerlink" title="有面值为1，3，5的硬币若干，需要凑成11元需要多少硬币，凑成n元最少需要多少硬币？"></a>有面值为1，3，5的硬币若干，需要凑成11元需要多少硬币，凑成n元最少需要多少硬币？</h4><h1 id="模式篇"><a href="#模式篇" class="headerlink" title="模式篇"></a>模式篇</h1><h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><p>饿汉：线程安全，类初始化的时候就会触发类的实例化，所以保证只有一个，</p><p>缺点：但是会浪费内存，如果不使用单例，就会一直存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//在静态初始化器中创建单例实例，这段代码保证了线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">//Singleton类只有一个构造方法并且是被private修饰的，所以用户无法通过new方法创建该对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉：synchronized加锁线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//没有加入synchronized关键字的版本是线程不安全的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span>  Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断当前单例是否已经存在，若存在则返回，不存在则再建立单例</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>双重校验锁：双重加锁（线程安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>双重判断的原因？<ul><li>第一个判断减少锁的使用，提升性能</li><li>多个线程同时等待锁，当第一个创建后，就不需要其他线程重复重建</li></ul></li><li>volatile的理解<ul><li>禁止重排序导致instance获取失败（3）。</li></ul></li><li>new Singleton()方法执行时可能导致分配了空间，并指向了内存空间，但是没有赋值，这样另一个线程拿到后会导致出错</li></ol><p>静态内部类：（线程安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHelper</span>&#123;</span><br><span class="line">        <span class="comment">//声明成员变量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供接口获取该实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHelper.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举单例：(线程安全)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">调用方法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Singleton.INSTANCE.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">直接通过Singleton.INSTANCE.doSomething()的方式调用即可。方便、简洁又安全。</span><br></pre></td></tr></table></figure><h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><p>生产者添加数据，消费者自己从中间件中获取信息，通过中间件管理数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kangsx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mode1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Queue&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(list.size()&gt;=maxSize)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(i);</span><br><span class="line">                notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span> (list.size()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                i = list.remove();</span><br><span class="line">                notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Box box;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Box box)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.box = box;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.run();</span><br><span class="line">            box.put(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Box box;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Box box)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.box = box;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.run();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> box.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Box</span> <span class="variable">box</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line">        <span class="comment">//5个生产者</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Producer</span>(box).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5个消费者</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Consumer</span>(box).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h4><p>发布者发送数据到订阅者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kangsx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/5/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mode2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IObserver</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> temp)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IObservable</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(IObserver iObserver)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">(IObserver iObserver)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被观察者（发布者）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Observable</span> <span class="keyword">implements</span> <span class="title class_">IObservable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> ArrayList&lt;IObserver&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(IObserver iObserver)</span> &#123;</span><br><span class="line">            list.add(iObserver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">(IObserver iObserver)</span> &#123;</span><br><span class="line">            list.remove(iObserver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                list.get(i).update(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTemp</span><span class="params">(<span class="type">int</span> temp)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.temp = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察者1（订阅者）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Observer1</span> <span class="keyword">implements</span> <span class="title class_">IObserver</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> temp)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Observable1更新为 = &quot;</span> + temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察者2(订阅者)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Observer2</span> <span class="keyword">implements</span> <span class="title class_">IObserver</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> temp)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Observable2更新为 = &quot;</span> + temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Observable</span> <span class="variable">observable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Observable</span>();</span><br><span class="line">        <span class="type">Observer1</span> <span class="variable">observer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Observer1</span>();</span><br><span class="line">        <span class="type">Observer2</span> <span class="variable">observer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Observer2</span>();</span><br><span class="line">        observable.register(observer1);</span><br><span class="line">        observable.register(observer2);</span><br><span class="line">        observable.setTemp(<span class="number">32131232</span>);</span><br><span class="line">        observable.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>提供复杂参数的对象构造，完全由调用方选择参数配置，反之使用默认。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="comment">//显示器</span></span><br><span class="line">    String display;</span><br><span class="line">    <span class="comment">//cpu型号</span></span><br><span class="line">    String cpu;</span><br><span class="line">    <span class="comment">//主板型号</span></span><br><span class="line">    String mainBoard;</span><br><span class="line">    <span class="comment">//显卡型号</span></span><br><span class="line">    String gpu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.display = builder.display;</span><br><span class="line">        <span class="built_in">this</span>.cpu = builder.cpu;</span><br><span class="line">        <span class="built_in">this</span>.mainBoard = builder.mainBoard;</span><br><span class="line">        <span class="built_in">this</span>.gpu = builder.gpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;显示器是&quot;</span> + display + <span class="string">&quot;\ncpu是&quot;</span> + cpu + <span class="string">&quot;\n主板是&quot;</span> + mainBoard + <span class="string">&quot;\n显卡是&quot;</span> + gpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">        <span class="comment">//显示器</span></span><br><span class="line">        String display;</span><br><span class="line">        <span class="comment">//cpu型号</span></span><br><span class="line">        String cpu;</span><br><span class="line">        <span class="comment">//主板型号</span></span><br><span class="line">        String mainBoard;</span><br><span class="line">        <span class="comment">//显卡型号</span></span><br><span class="line">        String gpu;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.display = <span class="string">&quot;三星曲屏&quot;</span>;</span><br><span class="line">            <span class="built_in">this</span>.cpu = <span class="string">&quot;i5 8400&quot;</span>;</span><br><span class="line">            <span class="built_in">this</span>.mainBoard = <span class="string">&quot;华硕Z360-B&quot;</span>;</span><br><span class="line">            <span class="built_in">this</span>.gpu = <span class="string">&quot;GTX 1050Ti&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setDisplay</span><span class="params">(String display)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.display = display;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setcpu</span><span class="params">(String cpu)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setMainBoard</span><span class="params">(String mainBoard)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.mainBoard = mainBoard;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setGpu</span><span class="params">(String gpu)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.gpu = gpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Computer <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>.Builder()</span><br><span class="line">                .setcpu(<span class="string">&quot;i9 4700u&quot;</span>)</span><br><span class="line">                .setGpu(<span class="string">&quot;GTX 2060Ti&quot;</span>)</span><br><span class="line">                .setMainBoard(<span class="string">&quot;华硕Z480&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(computer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>对原有功能进行封装，访问对象不能直接访问原有功能，只能访问我们的功能传达，我们就是代理，作为原有功能和访问对象之间的中介</p><p>静态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="literal">null</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之前的预处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之后的后续处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IRetrofit</span> <span class="variable">iRetrofit</span> <span class="operator">=</span> (IRetrofit) Proxy.newProxyInstance(IRetrofit.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;IRetrofit.class&#125;, <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----调用前执行&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----调用前执行Object&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> method.invoke(IRetrofit.class, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">IRetrofit</span> <span class="variable">iRetrofit1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IRetrofit</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;------test1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kang</span><span class="params">()</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;------kang1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> method.invoke(iRetrofit1,args);</span><br><span class="line">                System.out.println(<span class="string">&quot;-------调用后执行&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        iRetrofit.kang();</span><br></pre></td></tr></table></figure><p>打印如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----调用前执行</span><br><span class="line">------kang1</span><br><span class="line">-------调用后执行</span><br></pre></td></tr></table></figure><p>即想调用那个方法都可以，在invoke中做了代理，利用反射执行该类</p><h1 id="设计六种原则"><a href="#设计六种原则" class="headerlink" title="设计六种原则"></a>设计六种原则</h1><h4 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h4><p>接口业务单一</p><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><h4 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h4><h4 id="接口隔离"><a href="#接口隔离" class="headerlink" title="接口隔离"></a>接口隔离</h4><h4 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h4><h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p>提高复用性，可拓展性，将业务抽取单一获取</p><p>根据业务功能进行划分，功能复杂时考虑分层思想+设计模式，如果业务简单，可以直接套用设计模式进行方案优化，最后业务决定框架选型，细节方面可以面向未来考虑 尽量保证良好的扩展和健壮性</p><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><p>widget树，skia 2d渲染引擎，</p><p>StatelessWidget：不能更新状态的布局，创建一次，永不可修改外观</p><p>StatefulWidget：可以更新界面，通过setState方法更新布局，外观</p><p>fish-redux</p><h2 id="Kotlin-1"><a href="#Kotlin-1" class="headerlink" title="Kotlin"></a>Kotlin</h2><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>完全兼容Java<br>更少的空指针异常<br>更少的代码量，更快的开发速度</p><h2 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h2><h4 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h4><p>action：用户触发程序</p><p>reducer：根据action，做不同响应，返回一个新state</p><p>store：存储state的集合，数据是不可变的</p><h2 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h2><h3 id="iot触发日志文件上传"><a href="#iot触发日志文件上传" class="headerlink" title="iot触发日志文件上传"></a>iot触发日志文件上传</h3><p>通过bugly埋点，如果无法解决或者问题不全，或者酒店反馈音箱有问题</p><p>存储：监听时间广播，整点会重新存储日志文件，进程设置adb命令存储文件</p><p>每次中断或者时间到了都会触发重新开辟文件存储和老文件删除（只存储72个文件，正常情况下对应72个小时的）</p><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>使用leakcanary检测内存泄漏，绑定生命周期，在onDestroy的时候创建弱引用，放置在弱引用队列中，手动gc，如果查到该Activity，就是造成了内存泄漏，会打印出dump栈堆信息</p><h3 id="selinux权限配置"><a href="#selinux权限配置" class="headerlink" title="selinux权限配置"></a>selinux权限配置</h3><p>ota中遇到的问题，ota升级失败后，再日志中分析问题，再对应的<code>.te</code>文件中添加权限配置，循环往复，最终关闭这个权限校验。</p><p>定义每个用户，进程，应用，文件的访问和转变的权限，使用安全策略组控制这些实体</p><h3 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h3><h4 id="如何检测？"><a href="#如何检测？" class="headerlink" title="如何检测？"></a>如何检测？</h4><ol><li><p>AOP（AspectJ）打点</p></li><li><p>程序打点</p></li><li><p>TraceView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始收集</span></span><br><span class="line">Debug.startMethodTracing(<span class="string">&quot;app_trace&quot;</span>);</span><br><span class="line"><span class="comment">//结束收集</span></span><br><span class="line">Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure><p>生成app_trace.trace文件，可以查看方法耗时</p></li><li><p>函数插桩（ASM）</p></li></ol><h4 id="具体的优化方案"><a href="#具体的优化方案" class="headerlink" title="具体的优化方案"></a>具体的优化方案</h4><ol><li>替换主题中theme，保证不会出现闪屏</li><li>decroView.post执行延时任务</li><li>IdleHandler闲置时间进行任务执行</li><li>异步线程池处理</li><li>基于dex文件的异步加载，在编译期间对dex按模块进行拆分，把一级页面及配置放置在第一个dex中，二三级页面及配置放置在第二个dex中。</li><li>在app启动过程中，不启动odex转化进程，在app启动后，自己启动一个odex进程，将转化后文件放入odex文件</li></ol><blockquote><p>在app启动过程中，android虚拟机会启动一个odex转化进程，将dex转化为odex，避免这个odex进程对前台app的影响很重要</p></blockquote><h4 id="主旨核心"><a href="#主旨核心" class="headerlink" title="主旨核心"></a>主旨核心</h4><ol><li>减法为主：尽量不影响主线程，能较少的启动就减少启动</li><li>异步为辅：耗时任务在异步调用</li><li>延迟为补：延迟加载增加全面性</li></ol><h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><p>在使用Aspect进行时间的监测时，发现Application和Activity中的初始化三方进程耗费了大量时间，在初始化时，我们开启了百度OTA服务，Bugly监测服务，咪咕音乐服务，阿里IOT服务，日志监测服务，Linphone语音服务，Ifly语音服务等，这些串行起来是比较耗时的。<br>所以我们采用开启一个线程池的方案，在子线程启动这些服务，对于OTA，IOT，日志检测，Linphone等服务不需要在第一时间初始化，所以放到线程池中根据执行顺序分别初始化。但是对于咪咕、Ifly和bugly来说，需要第一时间初始化，才能进行后边的逻辑，所以我们将这些服务优先初始化，并联合CountDownLatch，当必须的服务初始化完成后，才进入下面的流程。<br>对于必须要在主线程进行初始化的操作，可能会造成主线程繁忙卡顿，所以使用IdleHandler方法，在主线程空闲时执行，</p><p>具体优化了40%，由2.3s压缩到1.4s。</p><p>如果由任务A，B，C，D，要求C在A之后执行，D在B之后执行，那么直接将A,C合并为一个任务，放入线程池中运行，B、D合并为一个任务，放入线池程中执行，如需决定AC和BD的顺序，那么可以按照AC、BD的顺序依次放入子线程中。</p><p>通过异步线程池进行异步加载处理，使用有向无环图算法控制任务进入线程池的顺序，通过CountDownLatch控制线程的执行顺序，进行异步加载</p><h4 id="如何对IDLEHandler进行顺序划分？比如先执行B，在执行A"><a href="#如何对IDLEHandler进行顺序划分？比如先执行B，在执行A" class="headerlink" title="如何对IDLEHandler进行顺序划分？比如先执行B，在执行A"></a>如何对IDLEHandler进行顺序划分？比如先执行B，在执行A</h4><p>规划一个空闲队列，在Handler空闲时进行处理，每次出队优先级最高的，其他等到下次空闲在执行</p><h4 id="2-5是怎么计算的？"><a href="#2-5是怎么计算的？" class="headerlink" title="2-5是怎么计算的？"></a>2-5是怎么计算的？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(<span class="number">2</span>, Math.min(CPU_COUNT - <span class="number">1</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>CPU_COUNT - 1，是因为为了避免后台任务将 CPU 资源完全耗尽， 减掉的这个1 是留给我们 主线程 使用的。</p><p>cpu密集型的线程选择：n+1<br>io密集型的线程选择：</p><ol><li>2n+1</li><li>线程数 &#x3D; CPU核心数&#x2F;(1-阻塞系数)，一般情况下IO密集型的为0.8，0.9，可适当调整这个数值</li></ol><p>在改启动器中，我们存在的大都是cpu密集型任务，理论上选择n+1，但是目前在2-5中间进行选择</p><p>在最新版本的AsyncTask中的线程池已经设置为了5</p><p><a href="https://blog.csdn.net/weixin_44367006/article/details/106717676">如何选择线程池最优线程数</a></p><h4 id="如何看待app-startUp？"><a href="#如何看待app-startUp？" class="headerlink" title="如何看待app startUp？"></a>如何看待app startUp？</h4><p>官方提供的启动优化方案，可以规定初始化模块的运行顺序，配合AndroidManifest+ContentProvider进行初始化。</p><p>在Application的生命周期中，application.attachBaseContext()—-&gt;contentProvider.onCreate()—–&gt;application.onCreate()</p><p>通过创建一个ContentProvider，在ContentProvider中执行初始化事件，减轻application的负担。</p><p>缺点：</p><ol><li>只支持同步事件，没有线程池做异步处理</li><li>需要编写大量的xxInitializer类文件，配置AndroidManifest文</li></ol><h3 id="设计一个模块："><a href="#设计一个模块：" class="headerlink" title="设计一个模块："></a>设计一个模块：</h3><ol><li>接口的易用性，从易用出发</li><li>命名规范</li><li>尽量不依赖第三方库，避免重复引用</li><li>多端使用的一致性，比如都开放同一个端口</li><li>sdk包保证小而精</li><li>保证老旧版本的兼容性</li><li>这类配置项一般就不需要提供 get 方法，防止接口太多</li></ol><h3 id="组件化构件"><a href="#组件化构件" class="headerlink" title="组件化构件"></a>组件化构件</h3><h3 id="布局优化-1"><a href="#布局优化-1" class="headerlink" title="布局优化"></a>布局优化</h3><h4 id="view的布局"><a href="#view的布局" class="headerlink" title="view的布局"></a>view的布局</h4><h5 id="ConstraintLayout，FrameLayout，RelativeLayout和LinearLayout的区别"><a href="#ConstraintLayout，FrameLayout，RelativeLayout和LinearLayout的区别" class="headerlink" title="ConstraintLayout，FrameLayout，RelativeLayout和LinearLayout的区别"></a>ConstraintLayout，FrameLayout，RelativeLayout和LinearLayout的区别</h5><p>ConstraintLayout：约束布局，完美结合RelativeLayout和LinearLayout的属性，可以拖拽，可以放置在相对布局，也可以按比例设置view，很像flex，都是一层布局</p><p>FrameLayout：后一个布局会覆盖前一个布局，可以控制层级</p><p>RelativeLayout：相对位置的布局</p><p>LinearLayout：线性布局，水平，垂直，比例分配</p><h5 id="include，viewstub，merge的区别"><a href="#include，viewstub，merge的区别" class="headerlink" title="include，viewstub，merge的区别"></a>include，viewstub，merge的区别</h5><p>include：复用布局</p><p>viewstub：可以显示网络布局，默认显示一次，更加省cpu和内存，只会构建一次，</p><p>merge：去除不必要的节点嵌套（比如多个LinearLayout的嵌套）</p><p>尽量使用ConstraintLayout，RelativeLayout，使用include，viewstub加载网络异常界面显示，merge去掉不必要的节点</p><h4 id="布局优化-2"><a href="#布局优化-2" class="headerlink" title="布局优化"></a>布局优化</h4><ol><li>针对复杂布局使用ConstraintLayout，减少层级，实现类Flex布局，后期也可拓展为MotionLayout，添加动画</li><li>针对简单布局，使用LinearLayout布局，不增加嵌套层级情况下，性能最优，onMeasure渲染一次</li><li>使用include布局对公共布局进行封装，便于统一修改和查看</li><li>使用merge标签作为根布局进行include内布局的封装，当其他布局引用时，会直接当作include布局的根布局使用，减少嵌套布局层级</li><li>使用viewStub标签，第一次展示时不会进行绘制，他是一个轻量级的view，没有尺寸，当需要使用布局时（调用inflate()方法），才会进行加载</li><li>使用开发者选项中的过度绘制进行检查并优化布局</li></ol><h3 id="apk体积优化"><a href="#apk体积优化" class="headerlink" title="apk体积优化"></a>apk体积优化</h3><p>使用apk Analyzer分析apk，体积主要在lib库，assets库，res库</p><p>从150M压缩到50M，</p><ol><li><p>lib库中存放着三方库，所以需要对三方库进行整理，剔除不需要的库，针对so库，剔除其他架构的so库，只留了armeabi-v7a包。</p></li><li><p>assets库和res库中主要是一些音频文件，帧动画图片，gif图片等</p><ol><li>对图片进行压缩，使用<a href="https://tinypng.com/">tinypng</a>进行图片压缩（支持png和jpg格式）</li><li>大部分图片可以使用webp格式替换，减少体积</li><li>帧动画和gif尽量换成lottie动画</li></ol></li><li><p>使用lint删除无用资源和代码</p></li><li><p>大图换小图</p></li><li><p>代码优化整理复用</p></li><li><p>view整理复用</p></li><li><p>启动shrinkResources，移除不用的资源</p></li><li><p>大库换小库，能不用就不用</p></li><li><p>减小assets，raw的文件目录大小，尽量放置在网络上</p></li><li><p>调整需求，减少体量</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;框架篇&quot;&gt;&lt;a href=&quot;#框架篇&quot; class=&quot;headerlink&quot; title=&quot;框架篇&quot;&gt;&lt;/a&gt;框架篇&lt;/h1&gt;&lt;h2 id=&quot;EventBus&quot;&gt;&lt;a href=&quot;#EventBus&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="移动端" scheme="http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
    <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>茶道</title>
    <link href="http://yoursite.com/2021/05/31/%E9%9A%8F%E7%AC%94/%E8%8C%B6%E9%81%93/"/>
    <id>http://yoursite.com/2021/05/31/%E9%9A%8F%E7%AC%94/%E8%8C%B6%E9%81%93/</id>
    <published>2021-05-31T12:39:47.000Z</published>
    <updated>2023-12-19T06:50:38.183Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="茶的分类"><a href="#茶的分类" class="headerlink" title="茶的分类"></a>茶的分类</h3><p>根据茶的发酵程度去区分茶的种类，目前已知可以分为：<code>绿茶</code>、<code>红茶</code>、<code>青茶</code>、<code>白茶</code>、<code>黄茶</code>、<code>黑茶</code>。</p><h4 id="绿茶"><a href="#绿茶" class="headerlink" title="绿茶"></a>绿茶</h4><p>发酵度：0%（未发酵）</p><p>品种高达3000多种</p><p>绿茶的茶汤多呈现翠绿色、黄绿色等等；茶汤清澈，滋味甘醇。较为出名的绿茶有：西湖龙井、黄山毛峰、碧螺春等。</p><p>冲泡绿茶时宜用80-90度左右的热水冲泡。</p><h4 id="黄茶"><a href="#黄茶" class="headerlink" title="黄茶"></a>黄茶</h4><p>发酵度：10～20%</p><p>黄茶品种比较少</p><p>黄茶属微发酵的茶，其制作工艺和绿茶相似，只增加了一道“闷黄”的工艺，这是制作黄茶的关键，也是造就黄茶“黄叶黄汤”的主要工序。黄茶的茶汤橙中泛黄，没有绿茶的苦涩，更加香醇。</p><p>比较出名的有：君山银针、蒙顶黄芽、沩山毛尖等。</p><p>冲泡黄茶时宜用85-95度左右的热水冲泡。</p><h4 id="白茶"><a href="#白茶" class="headerlink" title="白茶"></a>白茶</h4><p>发酵度：10～30%</p><p>白茶可以说是福建独有，主要生产于福建的政和、福鼎、松溪等</p><p>白茶是轻度发酵的茶，发酵程度仅比黄茶稍多，其制法独特，不炒不揉，成茶外表满披白毫，色泽银白灰绿，故名“白茶“。</p><p>白茶的茶汤一般呈黄绿色，滋味清淡，有较强的回甘。</p><p>比较出名的白茶有：白毫银针、白牡丹、寿眉、福鼎大白茶等。</p><p>冲泡白茶时宜用90-100度左右的热水冲泡。</p><h4 id="青茶"><a href="#青茶" class="headerlink" title="青茶"></a>青茶</h4><p>发酵度：30～70%</p><p>最具代表性的就是“乌龙茶”，属于半发酵茶，介于不发酵茶（绿茶）和全发酵茶（红茶）之间。</p><p>青茶的茶汤呈蜜绿色，香气馥郁，回味甘鲜。</p><p>比较出名的有：铁观音、武夷岩茶（大红袍）、广东大叶青等。</p><p>冲泡青茶时宜用100度左右的热水冲泡。</p><h4 id="红茶"><a href="#红茶" class="headerlink" title="红茶"></a>红茶</h4><p>发酵度：95～100%</p><p>是绿茶后的第二大茶类，产区较为广泛，但比较多的省份为云南、安徽、福建、广东等</p><p>比较有名的品种有：正山小种、祁红、滇红、金骏眉等。</p><p>冲泡红茶时宜用80-85度左右的热水冲泡。</p><h4 id="黑茶"><a href="#黑茶" class="headerlink" title="黑茶"></a>黑茶</h4><p>发酵度：80～100%</p><p>黑茶生产历史悠久，在历史上一直都是供给边疆少数民族地区，目的是为了帮助边疆人民消化食物和平衡营养。</p><p>比较出名的有：云南普洱茶、安化黑茶、广西六堡茶、四川边茶等。</p><p>冲泡黑茶时宜用100度左右的热水冲泡。</p><h3 id="茶的制作流程"><a href="#茶的制作流程" class="headerlink" title="茶的制作流程"></a>茶的制作流程</h3><h4 id="主要制作流程"><a href="#主要制作流程" class="headerlink" title="主要制作流程"></a>主要制作流程</h4><h5 id="采茶"><a href="#采茶" class="headerlink" title="采茶"></a>采茶</h5><p>从茶树上采摘新鲜的茶叶。采摘茶枝顶端的茶尖部分，分为独芽、一芽一叶、一芽两叶。</p><ul><li><p>独芽：采摘最顶端小芽，茶叶品级为极品，茶叶不耐泡，只能品茶叶的清香和甘醇。如龙井茶。</p></li><li><p>一芽一叶：采摘最顶端小芽+一片叶子，味道甘醇</p></li><li><p>一芽两叶：采摘最顶端小芽+两片叶子，较前两者味道更加浓郁些，少了飘逸感，但是价格亲民</p></li></ul><h5 id="摊晾（晾青、晾晒）"><a href="#摊晾（晾青、晾晒）" class="headerlink" title="摊晾（晾青、晾晒）"></a>摊晾（晾青、晾晒）</h5><p>就是将采摘下的茶鲜叶均匀地摊放在篾垫、摊青筛或摊青机上的作业过程。</p><p>使叶子失水（含水量下降5%&#x3D;70%），变软，便于揉捻成条、球</p><h5 id="萎凋（走水）"><a href="#萎凋（走水）" class="headerlink" title="萎凋（走水）"></a>萎凋（走水）</h5><p>是指鲜叶摊在一定的设备和环境条件下，</p><p>萎凋叶的含水率一般比摊晾后鲜叶的含水率更低，大多在60%~64%。</p><h5 id="杀青"><a href="#杀青" class="headerlink" title="杀青"></a>杀青</h5><p>主要目的是通过高温破坏和钝化鲜叶中的氧化酶活性，抑制鲜叶中的茶多酚等的酶促氧化，蒸发鲜叶部分水分，使茶叶变软，便于<a href="https://baike.baidu.com/item/%E6%8F%89%E6%8D%BB/692144">揉捻</a>成形，同时散发青臭味，促进良好香气的形成。</p><p>主要有炒青、烘青、蒸青和晒青：</p><ul><li>炒青用高温铁锅炒制（如龙井、碧螺春、雨花茶等）；</li><li>烘青用烘笼或烘干机直接高温烘焙（如黄山毛峰、太平猴魁、高桥银峰等）；</li><li>蒸青：采用蒸汽杀青工艺制作（如煎茶、玉露、抹茶等）；</li><li>晒青：靠太阳晒干或先晒后烘，先晒后炒干（如滇青、川青、陕青等）。</li></ul><h5 id="闷黄"><a href="#闷黄" class="headerlink" title="闷黄"></a>闷黄</h5><p>是黄茶类制造工艺的特点，是形成黄色黄汤的关键工序。从杀青到黄茶干燥结束，都可以为茶叶的黄变创造适当的湿热工艺条件，但作为一个制茶工序，有的茶在杀青后闷黄，有的则在毛火后闷黄，有的闷炒交替进行。</p><h5 id="发酵（渥红）"><a href="#发酵（渥红）" class="headerlink" title="发酵（渥红）"></a>发酵（渥红）</h5><p>是红茶制作的独特阶段，经过发酵，叶色由绿变红，形成红茶红叶红汤的品质特点。</p><h5 id="揉捻"><a href="#揉捻" class="headerlink" title="揉捻"></a>揉捻</h5><p>通过揉捻使茶叶的细胞壁破裂，是茶叶变得更加柔软，释放出更多的营养成分</p><h5 id="干燥"><a href="#干燥" class="headerlink" title="干燥"></a>干燥</h5><p>除去茶叶中的水分</p><h5 id="覆火"><a href="#覆火" class="headerlink" title="覆火"></a>覆火</h5><p>再次去除茶叶中的水分</p><h5 id="紧压"><a href="#紧压" class="headerlink" title="紧压"></a>紧压</h5><p>将茶叶制成茶饼</p><h4 id="六大茶类的制作流程"><a href="#六大茶类的制作流程" class="headerlink" title="六大茶类的制作流程"></a>六大茶类的制作流程</h4><ul><li>绿茶：采茶—-&gt;晾晒—-&gt;杀青—-&gt;揉捻—-&gt;干燥</li><li>黄茶：采茶—-&gt;晾晒—-&gt;杀青—-&gt;揉捻—-&gt;闷黄—-&gt;干燥</li><li>白茶：采茶—-&gt;晾晒&#x2F;萎凋—-&gt;杀青—-&gt;干燥</li><li>青茶：采茶—-&gt;萎凋—-&gt;杀青—-&gt;揉捻—-&gt;干燥</li><li>红茶：采茶—-&gt;萎凋—-&gt;揉捻—-&gt;干燥</li><li>黑茶：采茶—-&gt;萎凋—-&gt;炒青—-&gt;揉捻—-&gt;渥堆—-&gt;干燥—-&gt;覆火—-&gt;紧压</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;茶的分类&quot;&gt;&lt;a href=&quot;#茶的分类&quot; class=&quot;headerlink&quot; title=&quot;茶的分类&quot;&gt;&lt;/a&gt;茶的分类&lt;/h3&gt;&lt;p&gt;根据茶的发酵程度去区分茶的种类，目前已知可以分为：&lt;code&gt;绿茶&lt;/code&gt;、&lt;code&gt;红茶</summary>
      
    
    
    
    <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
